var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var dist={};function commonjsRequire(e){throw new Error('Could not dynamically require "'+e+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var ort_min={exports:{}};/*!
 * ONNX Runtime Web v1.19.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */(function(module,exports){var ort=(()=>{var wc=Object.create,dr=Object.defineProperty,vc=Object.getOwnPropertyDescriptor,Ic=Object.getOwnPropertyNames,_c=Object.getPrototypeOf,Sc=Object.prototype.hasOwnProperty,En=(e=>typeof commonjsRequire<"u"?commonjsRequire:typeof Proxy<"u"?new Proxy(e,{get:(r,i)=>(typeof commonjsRequire<"u"?commonjsRequire:r)[i]}):e)(function(e){if(typeof commonjsRequire<"u")return commonjsRequire.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),x=(e,r)=>()=>(e&&(r=e(e=0)),r),tt=(e,r)=>()=>(r||e((r={exports:{}}).exports,r),r.exports),ze=(e,r)=>{for(var i in r)dr(e,i,{get:r[i],enumerable:!0})},ni=(e,r,i,o)=>{if(r&&typeof r=="object"||typeof r=="function")for(let u of Ic(r))!Sc.call(e,u)&&u!==i&&dr(e,u,{get:()=>r[u],enumerable:!(o=vc(r,u))||o.enumerable});return e},Ie=(e,r,i)=>(i=e!=null?wc(_c(e)):{},ni(!e||!e.__esModule?dr(i,"default",{value:e,enumerable:!0}):i,e)),hr=e=>ni(dr({},"__esModule",{value:!0}),e),mr,oe,ie,Oc,br,gr=x(()=>{mr=new Map,oe=[],ie=(e,r,i)=>{if(r&&typeof r.init=="function"&&typeof r.createInferenceSessionHandler=="function"){let o=mr.get(e);if(o===void 0)mr.set(e,{backend:r,priority:i});else{if(o.priority>i)return;if(o.priority===i&&o.backend!==r)throw new Error(`cannot register backend "${e}" using priority ${i}`)}if(i>=0){let u=oe.indexOf(e);u!==-1&&oe.splice(u,1);for(let n=0;n<oe.length;n++)if(mr.get(oe[n]).priority<=i){oe.splice(n,0,e);return}oe.push(e)}return}throw new TypeError("not a valid backend")},Oc=async e=>{let r=mr.get(e);if(!r)return"backend not found.";if(r.initialized)return r.backend;if(r.aborted)return r.error;{let i=!!r.initPromise;try{return i||(r.initPromise=r.backend.init(e)),await r.initPromise,r.initialized=!0,r.backend}catch(o){return i||(r.error=`${o}`,r.aborted=!0),r.error}finally{delete r.initPromise}}},br=async e=>{let r=e.executionProviders||[],i=r.map(c=>typeof c=="string"?c:c.name),o=i.length===0?oe:i,u,n=[],s=new Set;for(let c of o){let t=await Oc(c);typeof t=="string"?n.push({name:c,err:t}):(u||(u=t),u===t&&s.add(c))}if(!u)throw new Error(`no available backend found. ERR: ${n.map(c=>`[${c.name}] ${c.err}`).join(", ")}`);for(let{name:c,err:t}of n)i.includes(c)&&console.warn(`removing requested execution provider "${c}" from session options because it is not available: ${t}`);let p=r.filter(c=>s.has(typeof c=="string"?c:c.name));return[u,new Proxy(e,{get:(c,t)=>t==="executionProviders"?p:Reflect.get(c,t)})]}}),oi=x(()=>{gr()}),ii,ai=x(()=>{ii="1.19.0"}),si,xt,Dn=x(()=>{ai(),si="warning",xt={wasm:{},webgl:{},webgpu:{},versions:{common:ii},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);si=e}},get logLevel(){return si}},Object.defineProperty(xt,"logLevel",{enumerable:!0})}),$,ui=x(()=>{Dn(),$=xt}),li,fi,ci=x(()=>{li=(e,r)=>{let i=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);i.width=e.dims[3],i.height=e.dims[2];let o=i.getContext("2d");if(o!=null){let u,n;(r==null?void 0:r.tensorLayout)!==void 0&&r.tensorLayout==="NHWC"?(u=e.dims[2],n=e.dims[3]):(u=e.dims[3],n=e.dims[2]);let s=(r==null?void 0:r.format)!==void 0?r.format:"RGB",p=r==null?void 0:r.norm,c,t;p===void 0||p.mean===void 0?c=[255,255,255,255]:typeof p.mean=="number"?c=[p.mean,p.mean,p.mean,p.mean]:(c=[p.mean[0],p.mean[1],p.mean[2],0],p.mean[3]!==void 0&&(c[3]=p.mean[3])),p===void 0||p.bias===void 0?t=[0,0,0,0]:typeof p.bias=="number"?t=[p.bias,p.bias,p.bias,p.bias]:(t=[p.bias[0],p.bias[1],p.bias[2],0],p.bias[3]!==void 0&&(t[3]=p.bias[3]));let l=n*u,a=0,d=l,h=l*2,f=-1;s==="RGBA"?(a=0,d=l,h=l*2,f=l*3):s==="RGB"?(a=0,d=l,h=l*2):s==="RBG"&&(a=0,h=l,d=l*2);for(let g=0;g<n;g++)for(let y=0;y<u;y++){let w=(e.data[a++]-t[0])*c[0],m=(e.data[d++]-t[1])*c[1],v=(e.data[h++]-t[2])*c[2],T=f===-1?255:(e.data[f++]-t[3])*c[3];o.fillStyle="rgba("+w+","+m+","+v+","+T+")",o.fillRect(y,g,1,1)}if("toDataURL"in i)return i.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},fi=(e,r)=>{let i=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),o;if(i!=null){let u,n,s;(r==null?void 0:r.tensorLayout)!==void 0&&r.tensorLayout==="NHWC"?(u=e.dims[2],n=e.dims[1],s=e.dims[3]):(u=e.dims[3],n=e.dims[2],s=e.dims[1]);let p=r!==void 0&&r.format!==void 0?r.format:"RGB",c=r==null?void 0:r.norm,t,l;c===void 0||c.mean===void 0?t=[255,255,255,255]:typeof c.mean=="number"?t=[c.mean,c.mean,c.mean,c.mean]:(t=[c.mean[0],c.mean[1],c.mean[2],255],c.mean[3]!==void 0&&(t[3]=c.mean[3])),c===void 0||c.bias===void 0?l=[0,0,0,0]:typeof c.bias=="number"?l=[c.bias,c.bias,c.bias,c.bias]:(l=[c.bias[0],c.bias[1],c.bias[2],0],c.bias[3]!==void 0&&(l[3]=c.bias[3]));let a=n*u;if(r!==void 0&&(r.format!==void 0&&s===4&&r.format!=="RGBA"||s===3&&r.format!=="RGB"&&r.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let d=4,h=0,f=1,g=2,y=3,w=0,m=a,v=a*2,T=-1;p==="RGBA"?(w=0,m=a,v=a*2,T=a*3):p==="RGB"?(w=0,m=a,v=a*2):p==="RBG"&&(w=0,v=a,m=a*2),o=i.createImageData(u,n);for(let _=0;_<n*u;h+=d,f+=d,g+=d,y+=d,_++)o.data[h]=(e.data[w++]-l[0])*t[0],o.data[f]=(e.data[m++]-l[1])*t[1],o.data[g]=(e.data[v++]-l[2])*t[2],o.data[y]=T===-1?255:(e.data[T++]-l[3])*t[3]}else throw new Error("Can not access image data");return o}}),Ln,pi,di,hi,mi,bi=x(()=>{yr(),Ln=(e,r)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(r.height===void 0||r.width===void 0)throw new Error("Image height and width must be defined");if(r.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:i,width:o}=r,u=r.norm??{mean:255,bias:0},n,s;typeof u.mean=="number"?n=[u.mean,u.mean,u.mean,u.mean]:n=[u.mean[0],u.mean[1],u.mean[2],u.mean[3]??255],typeof u.bias=="number"?s=[u.bias,u.bias,u.bias,u.bias]:s=[u.bias[0],u.bias[1],u.bias[2],u.bias[3]??0];let p=r.format!==void 0?r.format:"RGBA",c=r.tensorFormat!==void 0&&r.tensorFormat!==void 0?r.tensorFormat:"RGB",t=i*o,l=c==="RGBA"?new Float32Array(t*4):new Float32Array(t*3),a=4,d=0,h=1,f=2,g=3,y=0,w=t,m=t*2,v=-1;p==="RGB"&&(a=3,d=0,h=1,f=2,g=-1),c==="RGBA"?v=t*3:c==="RBG"?(y=0,m=t,w=t*2):c==="BGR"&&(m=0,w=t,y=t*2);for(let T=0;T<t;T++,d+=a,f+=a,h+=a,g+=a)l[y++]=(e[d]+s[0])/n[0],l[w++]=(e[h]+s[1])/n[1],l[m++]=(e[f]+s[2])/n[2],v!==-1&&g!==-1&&(l[v++]=(e[g]+s[3])/n[3]);return c==="RGBA"?new ft("float32",l,[1,4,i,o]):new ft("float32",l,[1,3,i,o])},pi=async(e,r)=>{let i=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,o=typeof ImageData<"u"&&e instanceof ImageData,u=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,n=typeof e=="string",s,p=r??{},c=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},t=l=>l instanceof HTMLCanvasElement||l instanceof OffscreenCanvas?l.getContext("2d"):null;if(i){let l=c();l.width=e.width,l.height=e.height;let a=t(l);if(a!=null){let d=e.height,h=e.width;if(r!==void 0&&r.resizedHeight!==void 0&&r.resizedWidth!==void 0&&(d=r.resizedHeight,h=r.resizedWidth),r!==void 0){if(p=r,r.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");p.tensorFormat="RGBA",p.height=d,p.width=h}else p.tensorFormat="RGBA",p.height=d,p.width=h;a.drawImage(e,0,0),s=a.getImageData(0,0,h,d).data}else throw new Error("Can not access image data")}else if(o){let l,a;if(r!==void 0&&r.resizedWidth!==void 0&&r.resizedHeight!==void 0?(l=r.resizedHeight,a=r.resizedWidth):(l=e.height,a=e.width),r!==void 0&&(p=r),p.format="RGBA",p.height=l,p.width=a,r!==void 0){let d=c();d.width=a,d.height=l;let h=t(d);if(h!=null)h.putImageData(e,0,0),s=h.getImageData(0,0,a,l).data;else throw new Error("Can not access image data")}else s=e.data}else if(u){if(r===void 0)throw new Error("Please provide image config with format for Imagebitmap");let l=c();l.width=e.width,l.height=e.height;let a=t(l);if(a!=null){let d=e.height,h=e.width;return a.drawImage(e,0,0,h,d),s=a.getImageData(0,0,h,d).data,p.height=d,p.width=h,Ln(s,p)}else throw new Error("Can not access image data")}else{if(n)return new Promise((l,a)=>{let d=c(),h=t(d);if(!e||!h)return a();let f=new Image;f.crossOrigin="Anonymous",f.src=e,f.onload=()=>{d.width=f.width,d.height=f.height,h.drawImage(f,0,0,d.width,d.height);let g=h.getImageData(0,0,d.width,d.height);p.height=d.height,p.width=d.width,l(Ln(g.data,p))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(s!==void 0)return Ln(s,p);throw new Error("Input data provided is not supported - aborted tensor creation")},di=(e,r)=>{let{width:i,height:o,download:u,dispose:n}=r,s=[1,o,i,4];return new ft({location:"texture",type:"float32",texture:e,dims:s,download:u,dispose:n})},hi=(e,r)=>{let{dataType:i,dims:o,download:u,dispose:n}=r;return new ft({location:"gpu-buffer",type:i??"float32",gpuBuffer:e,dims:o,download:u,dispose:n})},mi=(e,r,i)=>new ft({location:"cpu-pinned",type:e,data:r,dims:i??[r.length]})}),ae,We,gi,yi,xi=x(()=>{ae=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),We=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),gi=!1,yi=()=>{if(!gi){gi=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,r=typeof BigUint64Array<"u"&&BigUint64Array.from,i=typeof Float16Array<"u"&&Float16Array.from;e&&(ae.set("int64",BigInt64Array),We.set(BigInt64Array,"int64")),r&&(ae.set("uint64",BigUint64Array),We.set(BigUint64Array,"uint64")),i?(ae.set("float16",Float16Array),We.set(Float16Array,"float16")):ae.set("float16",Uint16Array)}}}),Ti,wi,vi=x(()=>{yr(),Ti=e=>{let r=1;for(let i=0;i<e.length;i++){let o=e[i];if(typeof o!="number"||!Number.isSafeInteger(o))throw new TypeError(`dims[${i}] must be an integer, got: ${o}`);if(o<0)throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${o}`);r*=o}return r},wi=(e,r)=>{switch(e.location){case"cpu":return new ft(e.type,e.data,r);case"cpu-pinned":return new ft({location:"cpu-pinned",data:e.data,type:e.type,dims:r});case"texture":return new ft({location:"texture",texture:e.texture,type:e.type,dims:r});case"gpu-buffer":return new ft({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:r});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),ft,yr=x(()=>{ci(),bi(),xi(),vi(),ft=class{constructor(e,r,i){yi();let o,u;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,o=e.type,u=e.dims,e.location){case"cpu-pinned":{let s=ae.get(o);if(!s)throw new TypeError(`unsupported type "${o}" to create tensor from pinned buffer`);if(!(e.data instanceof s))throw new TypeError(`buffer should be of type ${s.name}`);this.cpuData=e.data;break}case"texture":{if(o!=="float32")throw new TypeError(`unsupported type "${o}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(o!=="float32"&&o!=="float16"&&o!=="int32"&&o!=="int64"&&o!=="uint32"&&o!=="uint8"&&o!=="bool")throw new TypeError(`unsupported type "${o}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let s,p;if(typeof e=="string")if(o=e,p=i,e==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");s=r}else{let c=ae.get(e);if(c===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(r)){if(e==="float16"&&c===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");e==="uint64"||e==="int64"?s=c.from(r,BigInt):s=c.from(r)}else if(r instanceof c)s=r;else throw new TypeError(`A ${o} tensor's data must be type of ${c}`)}else if(p=r,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let c=typeof e[0];if(c==="string")o="string",s=e;else if(c==="boolean")o="bool",s=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${c}.`)}else{let c=We.get(e.constructor);if(c===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);o=c,s=e}if(p===void 0)p=[s.length];else if(!Array.isArray(p))throw new TypeError("A tensor's dims must be a number array");u=p,this.cpuData=s,this.dataLocation="cpu"}let n=Ti(u);if(this.cpuData&&n!==this.cpuData.length)throw new Error(`Tensor's size(${n}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=u,this.size=n}static async fromImage(e,r){return pi(e,r)}static fromTexture(e,r){return di(e,r)}static fromGpuBuffer(e,r){return hi(e,r)}static fromPinnedBuffer(e,r,i){return mi(e,r,i)}toDataURL(e){return li(this,e)}toImageData(e){return fi(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,e&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return wi(this,e)}}}),rt,xr=x(()=>{yr(),rt=ft}),$n,Ii,Kt,Jt,kn=x(()=>{Dn(),$n=(e,r)=>{(typeof xt.trace>"u"?!xt.wasm.trace:!xt.trace)||console.timeStamp(`${e}::ORT::${r}`)},Ii=(e,r)=>{var u;let i=((u=new Error().stack)==null?void 0:u.split(/\r\n|\r|\n/g))||[],o=!1;for(let n=0;n<i.length;n++){if(o&&!i[n].includes("TRACE_FUNC")){let s=`FUNC_${e}::${i[n].trim().split(" ")[1]}`;r&&(s+=`::${r}`),$n("CPU",s);return}i[n].includes("TRACE_FUNC")&&(o=!0)}},Kt=e=>{(typeof xt.trace>"u"?!xt.wasm.trace:!xt.trace)||Ii("BEGIN",e)},Jt=e=>{(typeof xt.trace>"u"?!xt.wasm.trace:!xt.trace)||Ii("END",e)}}),Tr,_i=x(()=>{gr(),xr(),kn(),Tr=class yt{constructor(r){this.handler=r}async run(r,i,o){Kt();let u={},n={};if(typeof r!="object"||r===null||r instanceof rt||Array.isArray(r))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof i=="object"){if(i===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(i instanceof rt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(i)){if(i.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let t of i){if(typeof t!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(t)===-1)throw new RangeError(`'fetches' contains invalid output name: ${t}.`);u[t]=null}if(typeof o=="object"&&o!==null)n=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else{let t=!1,l=Object.getOwnPropertyNames(i);for(let a of this.outputNames)if(l.indexOf(a)!==-1){let d=i[a];(d===null||d instanceof rt)&&(t=!0,s=!1,u[a]=d)}if(t){if(typeof o=="object"&&o!==null)n=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else n=i}}else if(typeof i<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(typeof r[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(s)for(let t of this.outputNames)u[t]=null;let p=await this.handler.run(r,u,n),c={};for(let t in p)if(Object.hasOwnProperty.call(p,t)){let l=p[t];l instanceof rt?c[t]=l:c[t]=new rt(l.type,l.data,l.dims)}return Jt(),c}async release(){return this.handler.dispose()}static async create(r,i,o,u){Kt();let n,s={};if(typeof r=="string"){if(n=r,typeof i=="object"&&i!==null)s=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof Uint8Array){if(n=r,typeof i=="object"&&i!==null)s=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(r instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&r instanceof SharedArrayBuffer){let l=r,a=0,d=r.byteLength;if(typeof i=="object"&&i!==null)s=i;else if(typeof i=="number"){if(a=i,!Number.isSafeInteger(a))throw new RangeError("'byteOffset' must be an integer.");if(a<0||a>=l.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${l.byteLength}).`);if(d=r.byteLength-a,typeof o=="number"){if(d=o,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||a+d>l.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${l.byteLength-a}].`);if(typeof u=="object"&&u!==null)s=u;else if(typeof u<"u")throw new TypeError("'options' must be an object.")}else if(typeof o<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof i<"u")throw new TypeError("'options' must be an object.");n=new Uint8Array(l,a,d)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[p,c]=await br(s),t=await p.createInferenceSessionHandler(n,c);return Jt(),new yt(t)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),Si,Oi=x(()=>{_i(),Si=Tr}),Ai=x(()=>{}),Pi=x(()=>{}),Ei=x(()=>{}),Di=x(()=>{}),Ac,wr,Li=x(()=>{gr(),xr(),Ac="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",wr=class wt{constructor(r,i,o){this.handler=r,this.hasOptimizerModel=i,this.hasEvalModel=o}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(r,i){let o=r.evalModel||"",u=r.optimizerModel||"",n=i||{},[s,p]=await br(n);if(s.createTrainingSessionHandler){let c=await s.createTrainingSessionHandler(r.checkpointState,r.trainModel,o,u,p);return new wt(c,!!r.optimizerModel,!!r.evalModel)}else throw new Error(Ac)}typeNarrowingForRunStep(r,i,o,u,n){let s={},p={};if(typeof o!="object"||o===null||o instanceof rt||Array.isArray(o))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let c=!0;if(typeof u=="object"){if(u===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(u instanceof rt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(u)){if(u.length===0)throw new TypeError("'fetches' cannot be an empty array.");c=!1;for(let t of u){if(typeof t!="string")throw new TypeError("'fetches' must be a string array or an object.");if(i.indexOf(t)===-1)throw new RangeError(`'fetches' contains invalid output name: ${t}.`);s[t]=null}if(typeof n=="object"&&n!==null)p=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{let t=!1,l=Object.getOwnPropertyNames(u);for(let a of i)if(l.indexOf(a)!==-1){let d=u[a];(d===null||d instanceof rt)&&(t=!0,c=!1,s[a]=d)}if(t){if(typeof n=="object"&&n!==null)p=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else p=u}}else if(typeof u<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of r)if(typeof o[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(c)for(let t of i)s[t]=null;return[s,p]}convertHandlerReturnTypeToMapOfTensors(r){let i={};for(let o in r)if(Object.hasOwnProperty.call(r,o)){let u=r[o];u instanceof rt?i[o]=u:i[o]=new rt(u.type,u.data,u.dims)}return i}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(r,i,o){let[u,n]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,r,i,o),s=await this.handler.runTrainStep(r,u,n);return this.convertHandlerReturnTypeToMapOfTensors(s)}async runOptimizerStep(r){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(r||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(r,i,o){if(this.hasEvalModel){let[u,n]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,r,i,o),s=await this.handler.runEvalStep(r,u,n);return this.convertHandlerReturnTypeToMapOfTensors(s)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(r=!0){return this.handler.getParametersSize(r)}async loadParametersBuffer(r,i=!0){let o=await this.getParametersSize(i);if(r.length!==4*o)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(r,i)}async getContiguousParameters(r=!0){return this.handler.getContiguousParameters(r)}async release(){return this.handler.dispose()}}}),$i,ki=x(()=>{Li(),$i=wr}),Bn={};ze(Bn,{InferenceSession:()=>Si,TRACE:()=>$n,TRACE_FUNC_BEGIN:()=>Kt,TRACE_FUNC_END:()=>Jt,Tensor:()=>rt,TrainingSession:()=>$i,env:()=>$,registerBackend:()=>ie});var $t=x(()=>{oi(),ui(),Oi(),xr(),Ai(),Pi(),kn(),Ei(),Di(),ki()});function Zt(e,r,i,o){if(r===void 0)return Ec(e);if(i===void 0)vr(e,r);else if(typeof i=="number"&&o===void 0)vr(e,r);else if(typeof i=="string"&&o===void 0)vr(e,i,1,r);else if(typeof i=="string"&&typeof o=="number")vr(e,i,o,r);else throw new TypeError("input is valid")}function Ec(e){return{verbose:Zt.verbose.bind(null,e),info:Zt.info.bind(null,e),warning:Zt.warning.bind(null,e),error:Zt.error.bind(null,e),fatal:Zt.fatal.bind(null,e)}}function vr(e,r,i,o){let u=He[o||""]||He[""];Fi[e]<Fi[u.minimalSeverity]||(u.logDateTime&&(r=`${new Date().toISOString()}|${r}`),u.logSourceLocation,Pc[u.provider].log(e,r,o))}var Fn,Nn,Fi,Pc,Ni,He,z,_r,Sr,Or,Ir,vt=x(()=>{Fn=class{log(e,r,i){}},Nn=class{log(e,r,i){console.log(`${this.color(e)} ${i?"\x1B[35m"+i+"\x1B[0m ":""}${r}`)}color(e){switch(e){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${e}`)}}},Fi={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},Pc={none:new Fn,console:new Nn},Ni={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},He={"":Ni},(e=>{function r(t,l){e("verbose",t,l)}e.verbose=r;function i(t,l){e("info",t,l)}e.info=i;function o(t,l){e("warning",t,l)}e.warning=o;function u(t,l){e("error",t,l)}e.error=u;function n(t,l){e("fatal",t,l)}e.fatal=n;function s(t){He={},p("",t||{})}e.reset=s;function p(t,l){if(t==="*")s(l);else{let a=He[t]||Ni;He[t]={provider:l.provider||a.provider,minimalSeverity:l.minimalSeverity||a.minimalSeverity,logDateTime:l.logDateTime===void 0?a.logDateTime:l.logDateTime,logSourceLocation:l.logSourceLocation===void 0?a.logSourceLocation:l.logSourceLocation}}}e.set=p;function c(t){let l={};t.logLevel&&(l.minimalSeverity=t.logLevel),p("",l)}e.setWithEnv=c})(Zt||(Zt={})),z=Zt,_r=class{constructor(e,r,i,o,u,n){this.category=e,this.name=r,this.startTime=i,this.endCallback=o,this.timer=u,this.ctx=n}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},Sr=class{constructor(e,r,i,o){this.category=e,this.name=r,this.startTime=i,this.endTime=o}},Or=class{constructor(e,r,i){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=e===void 0?1e4:e,this._flushBatchSize=r===void 0?10:r,this._flushIntervalInMilliseconds=i===void 0?5e3:i}static create(e){return e===void 0?new this:new this(e.maxNumberEvents,e.flushBatchSize,e.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=Ir(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(e,r,i,o){let u=this._started?this.begin(e,r,o):void 0,n=!1,s=i();if(s&&typeof s.then=="function")return n=!0,new Promise((p,c)=>{s.then(async t=>{u&&await u.end(),p(t)},async t=>{u&&await u.end(),c(t)})});if(!n&&u){let p=u.end();if(p&&typeof p.then=="function")return new Promise((c,t)=>{p.then(()=>{c(s)},l=>{t(l)})})}return s}begin(e,r,i){if(!this._started)throw new Error("profiler is not started yet");if(i===void 0){let o=Ir();return this.flush(o),new _r(e,r,o,u=>this.endSync(u))}else{let o=i.beginTimer();return new _r(e,r,0,async u=>this.end(u),o,i)}}async end(e){let r=await e.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new Sr(e.category,e.name,e.startTime,r)),this.flush(r))}endSync(e){let r=Ir();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new Sr(e.category,e.name,e.startTime,r)),this.flush(r))}logOneEvent(e){z.verbose(`Profiler.${e.category}`,`${(e.endTime-e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`)}flush(e){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||e-this._flushTime>=this._flushIntervalInMilliseconds){for(let r=this._flushPointer;this._flushPointer<r+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=Ir()}}get started(){return this._started}},Ir=typeof performance<"u"&&performance.now?()=>performance.now():Date.now});function Ci(e,r,i){for(let o of i){let u=o[0],n=o[1],s=o[2],p=o[3],c=o[4];if(e.opType===u){for(let t of r)if((t.domain===n||t.domain==="ai.onnx"&&n==="")&&Dc(t.version,s))return{opImpl:p,opInit:c}}}throw new TypeError(`cannot resolve operator '${e.opType}' with opsets: ${r.map(o=>`${o.domain||"ai.onnx"} v${o.version}`).join(", ")}`)}function Dc(e,r){if(r.endsWith("+")){let i=Number.parseInt(r.substring(0,r.length-1),10);return!isNaN(i)&&i<=e}else if(r.split("-").length===2){let i=r.split("-"),o=Number.parseInt(i[0],10),u=Number.parseInt(i[1],10);return!isNaN(o)&&!isNaN(u)&&o<=e&&e<=u}else return Number.parseInt(r,10)===e}var Ri=x(()=>{}),Gi=tt(e=>{e.__esModule=!0;var r=function(){function i(o){if(!o)throw new TypeError("Invalid argument; `value` has no value.");this.value=i.EMPTY,o&&i.isGuid(o)&&(this.value=o)}return i.isGuid=function(o){var u=o.toString();return o&&(o instanceof i||i.validator.test(u))},i.create=function(){return new i([i.gen(2),i.gen(1),i.gen(1),i.gen(1),i.gen(3)].join("-"))},i.createEmpty=function(){return new i("emptyguid")},i.parse=function(o){return new i(o)},i.raw=function(){return[i.gen(2),i.gen(1),i.gen(1),i.gen(1),i.gen(3)].join("-")},i.gen=function(o){for(var u="",n=0;n<o;n++)u+=((1+Math.random())*65536|0).toString(16).substring(1);return u},i.prototype.equals=function(o){return i.isGuid(o)&&this.value===o.toString()},i.prototype.isEmpty=function(){return this.value===i.EMPTY},i.prototype.toString=function(){return this.value},i.prototype.toJSON=function(){return{value:this.value}},i.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),i.EMPTY="00000000-0000-0000-0000-000000000000",i}();e.Guid=r});function H(e,r,i){this.low=e|0,this.high=r|0,this.unsigned=!!i}function ut(e){return(e&&e.__isLong__)===!0}function Mi(e){var r=Math.clz32(e&-e);return e?31-r:r}function se(e,r){var i,o,u;return r?(e>>>=0,(u=0<=e&&e<256)&&(o=Ui[e],o)?o:(i=V(e,0,!0),u&&(Ui[e]=i),i)):(e|=0,(u=-128<=e&&e<128)&&(o=Vi[e],o)?o:(i=V(e,e<0?-1:0,!1),u&&(Vi[e]=i),i))}function _t(e,r){if(isNaN(e))return r?qt:kt;if(r){if(e<0)return qt;if(e>=qi)return Ki}else{if(e<=-Wi)return ht;if(e+1>=Wi)return Xi}return e<0?_t(-e,r).neg():V(e%Se|0,e/Se|0,r)}function V(e,r,i){return new H(e,r,i)}function Gn(e,r,i){if(e.length===0)throw Error("empty string");if(typeof r=="number"?(i=r,r=!1):r=!!r,e==="NaN"||e==="Infinity"||e==="+Infinity"||e==="-Infinity")return r?qt:kt;if(i=i||10,i<2||36<i)throw RangeError("radix");var o;if((o=e.indexOf("-"))>0)throw Error("interior hyphen");if(o===0)return Gn(e.substring(1),r,i).neg();for(var u=_t(Ar(i,8)),n=kt,s=0;s<e.length;s+=8){var p=Math.min(8,e.length-s),c=parseInt(e.substring(s,s+p),i);if(p<8){var t=_t(Ar(i,p));n=n.mul(t).add(_t(c))}else n=n.mul(u),n=n.add(_t(c))}return n.unsigned=r,n}function Bt(e,r){return typeof e=="number"?_t(e,r):typeof e=="string"?Gn(e,r):V(e.low,e.high,typeof r=="boolean"?r:e.unsigned)}var It,Vi,Ui,Ar,zi,$c,Se,qi,Wi,Hi,kt,qt,_e,ji,Rn,Xi,Ki,ht,I,jt,Mn=x(()=>{It=null;try{It=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}H.prototype.__isLong__,Object.defineProperty(H.prototype,"__isLong__",{value:!0}),H.isLong=ut,Vi={},Ui={},H.fromInt=se,H.fromNumber=_t,H.fromBits=V,Ar=Math.pow,H.fromString=Gn,H.fromValue=Bt,zi=65536,$c=1<<24,Se=zi*zi,qi=Se*Se,Wi=qi/2,Hi=se($c),kt=se(0),H.ZERO=kt,qt=se(0,!0),H.UZERO=qt,_e=se(1),H.ONE=_e,ji=se(1,!0),H.UONE=ji,Rn=se(-1),H.NEG_ONE=Rn,Xi=V(-1,2147483647,!1),H.MAX_VALUE=Xi,Ki=V(-1,-1,!0),H.MAX_UNSIGNED_VALUE=Ki,ht=V(0,-2147483648,!1),H.MIN_VALUE=ht,I=H.prototype,I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*Se+(this.low>>>0):this.high*Se+(this.low>>>0)},I.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(ht)){var r=_t(e),i=this.div(r),o=i.mul(r).sub(this);return i.toString(e)+o.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var u=_t(Ar(e,6),this.unsigned),n=this,s="";;){var p=n.div(u),c=n.sub(p.mul(u)).toInt()>>>0,t=c.toString(e);if(n=p,n.isZero())return t+s;for(;t.length<6;)t="0"+t;s=""+t+s}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ht)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,r=31;r>0&&!(e&1<<r);r--);return this.high!=0?r+33:r+1},I.isZero=function(){return this.high===0&&this.low===0},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return(this.low&1)===1},I.isEven=function(){return(this.low&1)===0},I.equals=function(e){return ut(e)||(e=Bt(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low},I.eq=I.equals,I.notEquals=function(e){return!this.eq(e)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(e){return this.comp(e)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(e){return this.comp(e)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(e){return this.comp(e)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(e){return this.comp(e)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(e){if(ut(e)||(e=Bt(e)),this.eq(e))return 0;var r=this.isNegative(),i=e.isNegative();return r&&!i?-1:!r&&i?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(ht)?ht:this.not().add(_e)},I.neg=I.negate,I.add=function(e){ut(e)||(e=Bt(e));var r=this.high>>>16,i=this.high&65535,o=this.low>>>16,u=this.low&65535,n=e.high>>>16,s=e.high&65535,p=e.low>>>16,c=e.low&65535,t=0,l=0,a=0,d=0;return d+=u+c,a+=d>>>16,d&=65535,a+=o+p,l+=a>>>16,a&=65535,l+=i+s,t+=l>>>16,l&=65535,t+=r+n,t&=65535,V(a<<16|d,t<<16|l,this.unsigned)},I.subtract=function(e){return ut(e)||(e=Bt(e)),this.add(e.neg())},I.sub=I.subtract,I.multiply=function(e){if(this.isZero())return this;if(ut(e)||(e=Bt(e)),It){var r=It.mul(this.low,this.high,e.low,e.high);return V(r,It.get_high(),this.unsigned)}if(e.isZero())return this.unsigned?qt:kt;if(this.eq(ht))return e.isOdd()?ht:kt;if(e.eq(ht))return this.isOdd()?ht:kt;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Hi)&&e.lt(Hi))return _t(this.toNumber()*e.toNumber(),this.unsigned);var i=this.high>>>16,o=this.high&65535,u=this.low>>>16,n=this.low&65535,s=e.high>>>16,p=e.high&65535,c=e.low>>>16,t=e.low&65535,l=0,a=0,d=0,h=0;return h+=n*t,d+=h>>>16,h&=65535,d+=u*t,a+=d>>>16,d&=65535,d+=n*c,a+=d>>>16,d&=65535,a+=o*t,l+=a>>>16,a&=65535,a+=u*c,l+=a>>>16,a&=65535,a+=n*p,l+=a>>>16,a&=65535,l+=i*t+o*c+u*p+n*s,l&=65535,V(d<<16|h,l<<16|a,this.unsigned)},I.mul=I.multiply,I.divide=function(e){if(ut(e)||(e=Bt(e)),e.isZero())throw Error("division by zero");if(It){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var r=(this.unsigned?It.div_u:It.div_s)(this.low,this.high,e.low,e.high);return V(r,It.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?qt:kt;var i,o,u;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return qt;if(e.gt(this.shru(1)))return ji;u=qt}else{if(this.eq(ht)){if(e.eq(_e)||e.eq(Rn))return ht;if(e.eq(ht))return _e;var n=this.shr(1);return i=n.div(e).shl(1),i.eq(kt)?e.isNegative()?_e:Rn:(o=this.sub(e.mul(i)),u=i.add(o.div(e)),u)}else if(e.eq(ht))return this.unsigned?qt:kt;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();u=kt}for(o=this;o.gte(e);){i=Math.max(1,Math.floor(o.toNumber()/e.toNumber()));for(var s=Math.ceil(Math.log(i)/Math.LN2),p=s<=48?1:Ar(2,s-48),c=_t(i),t=c.mul(e);t.isNegative()||t.gt(o);)i-=p,c=_t(i,this.unsigned),t=c.mul(e);c.isZero()&&(c=_e),u=u.add(c),o=o.sub(t)}return u},I.div=I.divide,I.modulo=function(e){if(ut(e)||(e=Bt(e)),It){var r=(this.unsigned?It.rem_u:It.rem_s)(this.low,this.high,e.low,e.high);return V(r,It.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return V(~this.low,~this.high,this.unsigned)},I.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},I.clz=I.countLeadingZeros,I.countTrailingZeros=function(){return this.low?Mi(this.low):Mi(this.high)+32},I.ctz=I.countTrailingZeros,I.and=function(e){return ut(e)||(e=Bt(e)),V(this.low&e.low,this.high&e.high,this.unsigned)},I.or=function(e){return ut(e)||(e=Bt(e)),V(this.low|e.low,this.high|e.high,this.unsigned)},I.xor=function(e){return ut(e)||(e=Bt(e)),V(this.low^e.low,this.high^e.high,this.unsigned)},I.shiftLeft=function(e){return ut(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?V(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):V(0,this.low<<e-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(e){return ut(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?V(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):V(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(e){return ut(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?V(this.low>>>e|this.high<<32-e,this.high>>>e,this.unsigned):e===32?V(this.high,0,this.unsigned):V(this.high>>>e-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.rotateLeft=function(e){var r;return ut(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?V(this.high,this.low,this.unsigned):e<32?(r=32-e,V(this.low<<e|this.high>>>r,this.high<<e|this.low>>>r,this.unsigned)):(e-=32,r=32-e,V(this.high<<e|this.low>>>r,this.low<<e|this.high>>>r,this.unsigned))},I.rotl=I.rotateLeft,I.rotateRight=function(e){var r;return ut(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?V(this.high,this.low,this.unsigned):e<32?(r=32-e,V(this.high<<r|this.low>>>e,this.low<<r|this.high>>>e,this.unsigned)):(e-=32,r=32-e,V(this.low<<r|this.high>>>e,this.high<<r|this.low>>>e,this.unsigned))},I.rotr=I.rotateRight,I.toSigned=function(){return this.unsigned?V(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:V(this.low,this.high,!0)},I.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var e=this.high,r=this.low;return[r&255,r>>>8&255,r>>>16&255,r>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]},I.toBytesBE=function(){var e=this.high,r=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,r>>>24,r>>>16&255,r>>>8&255,r&255]},H.fromBytes=function(e,r,i){return i?H.fromBytesLE(e,r):H.fromBytesBE(e,r)},H.fromBytesLE=function(e,r){return new H(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,r)},H.fromBytesBE=function(e,r){return new H(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],r)},jt=H}),b,Pr=x(()=>{b={},b.Offset,b.Table,b.SIZEOF_SHORT=2,b.SIZEOF_INT=4,b.FILE_IDENTIFIER_LENGTH=4,b.SIZE_PREFIX_LENGTH=4,b.Encoding={UTF8_BYTES:1,UTF16_STRING:2},b.int32=new Int32Array(2),b.float32=new Float32Array(b.int32.buffer),b.float64=new Float64Array(b.int32.buffer),b.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,b.Long=function(e,r){this.low=e|0,this.high=r|0},b.Long.create=function(e,r){return e==0&&r==0?b.Long.ZERO:new b.Long(e,r)},b.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296},b.Long.prototype.equals=function(e){return this.low==e.low&&this.high==e.high},b.Long.ZERO=new b.Long(0,0),b.Builder=function(e){if(e)var r=e;else var r=1024;this.bb=b.ByteBuffer.allocate(r),this.space=r,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},b.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},b.Builder.prototype.forceDefaults=function(e){this.force_defaults=e},b.Builder.prototype.dataBuffer=function(){return this.bb},b.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},b.Builder.prototype.prep=function(e,r){e>this.minalign&&(this.minalign=e);for(var i=~(this.bb.capacity()-this.space+r)+1&e-1;this.space<i+e+r;){var o=this.bb.capacity();this.bb=b.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-o}this.pad(i)},b.Builder.prototype.pad=function(e){for(var r=0;r<e;r++)this.bb.writeInt8(--this.space,0)},b.Builder.prototype.writeInt8=function(e){this.bb.writeInt8(this.space-=1,e)},b.Builder.prototype.writeInt16=function(e){this.bb.writeInt16(this.space-=2,e)},b.Builder.prototype.writeInt32=function(e){this.bb.writeInt32(this.space-=4,e)},b.Builder.prototype.writeInt64=function(e){this.bb.writeInt64(this.space-=8,e)},b.Builder.prototype.writeFloat32=function(e){this.bb.writeFloat32(this.space-=4,e)},b.Builder.prototype.writeFloat64=function(e){this.bb.writeFloat64(this.space-=8,e)},b.Builder.prototype.addInt8=function(e){this.prep(1,0),this.writeInt8(e)},b.Builder.prototype.addInt16=function(e){this.prep(2,0),this.writeInt16(e)},b.Builder.prototype.addInt32=function(e){this.prep(4,0),this.writeInt32(e)},b.Builder.prototype.addInt64=function(e){this.prep(8,0),this.writeInt64(e)},b.Builder.prototype.addFloat32=function(e){this.prep(4,0),this.writeFloat32(e)},b.Builder.prototype.addFloat64=function(e){this.prep(8,0),this.writeFloat64(e)},b.Builder.prototype.addFieldInt8=function(e,r,i){(this.force_defaults||r!=i)&&(this.addInt8(r),this.slot(e))},b.Builder.prototype.addFieldInt16=function(e,r,i){(this.force_defaults||r!=i)&&(this.addInt16(r),this.slot(e))},b.Builder.prototype.addFieldInt32=function(e,r,i){(this.force_defaults||r!=i)&&(this.addInt32(r),this.slot(e))},b.Builder.prototype.addFieldInt64=function(e,r,i){(this.force_defaults||!r.equals(i))&&(this.addInt64(r),this.slot(e))},b.Builder.prototype.addFieldFloat32=function(e,r,i){(this.force_defaults||r!=i)&&(this.addFloat32(r),this.slot(e))},b.Builder.prototype.addFieldFloat64=function(e,r,i){(this.force_defaults||r!=i)&&(this.addFloat64(r),this.slot(e))},b.Builder.prototype.addFieldOffset=function(e,r,i){(this.force_defaults||r!=i)&&(this.addOffset(r),this.slot(e))},b.Builder.prototype.addFieldStruct=function(e,r,i){r!=i&&(this.nested(r),this.slot(e))},b.Builder.prototype.nested=function(e){if(e!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},b.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},b.Builder.prototype.slot=function(e){this.vtable[e]=this.offset()},b.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},b.Builder.growByteBuffer=function(e){var r=e.capacity();if(r&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var i=r<<1,o=b.ByteBuffer.allocate(i);return o.setPosition(i-r),o.bytes().set(e.bytes(),i-r),o},b.Builder.prototype.addOffset=function(e){this.prep(b.SIZEOF_INT,0),this.writeInt32(this.offset()-e+b.SIZEOF_INT)},b.Builder.prototype.startObject=function(e){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=e;for(var r=0;r<e;r++)this.vtable[r]=0;this.isNested=!0,this.object_start=this.offset()},b.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var e=this.offset(),r=this.vtable_in_use-1;r>=0&&this.vtable[r]==0;r--);for(var i=r+1;r>=0;r--)this.addInt16(this.vtable[r]!=0?e-this.vtable[r]:0);var o=2;this.addInt16(e-this.object_start);var u=(i+o)*b.SIZEOF_SHORT;this.addInt16(u);var n=0,s=this.space;e:for(r=0;r<this.vtables.length;r++){var p=this.bb.capacity()-this.vtables[r];if(u==this.bb.readInt16(p)){for(var c=b.SIZEOF_SHORT;c<u;c+=b.SIZEOF_SHORT)if(this.bb.readInt16(s+c)!=this.bb.readInt16(p+c))continue e;n=this.vtables[r];break}}return n?(this.space=this.bb.capacity()-e,this.bb.writeInt32(this.space,n-e)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-e,this.offset()-e)),this.isNested=!1,e},b.Builder.prototype.finish=function(e,r,i){var o=i?b.SIZE_PREFIX_LENGTH:0;if(r){var u=r;if(this.prep(this.minalign,b.SIZEOF_INT+b.FILE_IDENTIFIER_LENGTH+o),u.length!=b.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+b.FILE_IDENTIFIER_LENGTH);for(var n=b.FILE_IDENTIFIER_LENGTH-1;n>=0;n--)this.writeInt8(u.charCodeAt(n))}this.prep(this.minalign,b.SIZEOF_INT+o),this.addOffset(e),o&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},b.Builder.prototype.finishSizePrefixed=function(e,r){this.finish(e,r,!0)},b.Builder.prototype.requiredField=function(e,r){var i=this.bb.capacity()-e,o=i-this.bb.readInt32(i),u=this.bb.readInt16(o+r)!=0;if(!u)throw new Error("FlatBuffers: field "+r+" must be set")},b.Builder.prototype.startVector=function(e,r,i){this.notNested(),this.vector_num_elems=r,this.prep(b.SIZEOF_INT,e*r),this.prep(i,e*r)},b.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},b.Builder.prototype.createString=function(e){if(e instanceof Uint8Array)var r=e;else for(var r=[],i=0;i<e.length;){var o,u=e.charCodeAt(i++);if(u<55296||u>=56320)o=u;else{var n=e.charCodeAt(i++);o=(u<<10)+n+-56613888}o<128?r.push(o):(o<2048?r.push(o>>6&31|192):(o<65536?r.push(o>>12&15|224):r.push(o>>18&7|240,o>>12&63|128),r.push(o>>6&63|128)),r.push(o&63|128))}this.addInt8(0),this.startVector(1,r.length,1),this.bb.setPosition(this.space-=r.length);for(var i=0,s=this.space,p=this.bb.bytes();i<r.length;i++)p[s++]=r[i];return this.endVector()},b.Builder.prototype.createLong=function(e,r){return b.Long.create(e,r)},b.ByteBuffer=function(e){this.bytes_=e,this.position_=0},b.ByteBuffer.allocate=function(e){return new b.ByteBuffer(new Uint8Array(e))},b.ByteBuffer.prototype.clear=function(){this.position_=0},b.ByteBuffer.prototype.bytes=function(){return this.bytes_},b.ByteBuffer.prototype.position=function(){return this.position_},b.ByteBuffer.prototype.setPosition=function(e){this.position_=e},b.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},b.ByteBuffer.prototype.readInt8=function(e){return this.readUint8(e)<<24>>24},b.ByteBuffer.prototype.readUint8=function(e){return this.bytes_[e]},b.ByteBuffer.prototype.readInt16=function(e){return this.readUint16(e)<<16>>16},b.ByteBuffer.prototype.readUint16=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8},b.ByteBuffer.prototype.readInt32=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8|this.bytes_[e+2]<<16|this.bytes_[e+3]<<24},b.ByteBuffer.prototype.readUint32=function(e){return this.readInt32(e)>>>0},b.ByteBuffer.prototype.readInt64=function(e){return new b.Long(this.readInt32(e),this.readInt32(e+4))},b.ByteBuffer.prototype.readUint64=function(e){return new b.Long(this.readUint32(e),this.readUint32(e+4))},b.ByteBuffer.prototype.readFloat32=function(e){return b.int32[0]=this.readInt32(e),b.float32[0]},b.ByteBuffer.prototype.readFloat64=function(e){return b.int32[b.isLittleEndian?0:1]=this.readInt32(e),b.int32[b.isLittleEndian?1:0]=this.readInt32(e+4),b.float64[0]},b.ByteBuffer.prototype.writeInt8=function(e,r){this.bytes_[e]=r},b.ByteBuffer.prototype.writeUint8=function(e,r){this.bytes_[e]=r},b.ByteBuffer.prototype.writeInt16=function(e,r){this.bytes_[e]=r,this.bytes_[e+1]=r>>8},b.ByteBuffer.prototype.writeUint16=function(e,r){this.bytes_[e]=r,this.bytes_[e+1]=r>>8},b.ByteBuffer.prototype.writeInt32=function(e,r){this.bytes_[e]=r,this.bytes_[e+1]=r>>8,this.bytes_[e+2]=r>>16,this.bytes_[e+3]=r>>24},b.ByteBuffer.prototype.writeUint32=function(e,r){this.bytes_[e]=r,this.bytes_[e+1]=r>>8,this.bytes_[e+2]=r>>16,this.bytes_[e+3]=r>>24},b.ByteBuffer.prototype.writeInt64=function(e,r){this.writeInt32(e,r.low),this.writeInt32(e+4,r.high)},b.ByteBuffer.prototype.writeUint64=function(e,r){this.writeUint32(e,r.low),this.writeUint32(e+4,r.high)},b.ByteBuffer.prototype.writeFloat32=function(e,r){b.float32[0]=r,this.writeInt32(e,b.int32[0])},b.ByteBuffer.prototype.writeFloat64=function(e,r){b.float64[0]=r,this.writeInt32(e,b.int32[b.isLittleEndian?0:1]),this.writeInt32(e+4,b.int32[b.isLittleEndian?1:0])},b.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+b.SIZEOF_INT+b.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var e="",r=0;r<b.FILE_IDENTIFIER_LENGTH;r++)e+=String.fromCharCode(this.readInt8(this.position_+b.SIZEOF_INT+r));return e},b.ByteBuffer.prototype.__offset=function(e,r){var i=e-this.readInt32(e);return r<this.readInt16(i)?this.readInt16(i+r):0},b.ByteBuffer.prototype.__union=function(e,r){return e.bb_pos=r+this.readInt32(r),e.bb=this,e},b.ByteBuffer.prototype.__string=function(e,r){e+=this.readInt32(e);var i=this.readInt32(e),o="",u=0;if(e+=b.SIZEOF_INT,r===b.Encoding.UTF8_BYTES)return this.bytes_.subarray(e,e+i);for(;u<i;){var n,s=this.readUint8(e+u++);if(s<192)n=s;else{var p=this.readUint8(e+u++);if(s<224)n=(s&31)<<6|p&63;else{var c=this.readUint8(e+u++);if(s<240)n=(s&15)<<12|(p&63)<<6|c&63;else{var t=this.readUint8(e+u++);n=(s&7)<<18|(p&63)<<12|(c&63)<<6|t&63}}}n<65536?o+=String.fromCharCode(n):(n-=65536,o+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return o},b.ByteBuffer.prototype.__indirect=function(e){return e+this.readInt32(e)},b.ByteBuffer.prototype.__vector=function(e){return e+this.readInt32(e)+b.SIZEOF_INT},b.ByteBuffer.prototype.__vector_len=function(e){return this.readInt32(e+this.readInt32(e))},b.ByteBuffer.prototype.__has_identifier=function(e){if(e.length!=b.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+b.FILE_IDENTIFIER_LENGTH);for(var r=0;r<b.FILE_IDENTIFIER_LENGTH;r++)if(e.charCodeAt(r)!=this.readInt8(this.position_+b.SIZEOF_INT+r))return!1;return!0},b.ByteBuffer.prototype.createLong=function(e,r){return b.Long.create(e,r)}}),P,qe=x(()=>{Pr(),(e=>{(r=>{(i=>{(o=>(o[o.UNDEFINED=0]="UNDEFINED",o[o.FLOAT=1]="FLOAT",o[o.INT=2]="INT",o[o.STRING=3]="STRING",o[o.TENSOR=4]="TENSOR",o[o.GRAPH=5]="GRAPH",o[o.FLOATS=6]="FLOATS",o[o.INTS=7]="INTS",o[o.STRINGS=8]="STRINGS",o[o.TENSORS=9]="TENSORS",o[o.GRAPHS=10]="GRAPHS",o[o.SPARSE_TENSOR=11]="SPARSE_TENSOR",o[o.SPARSE_TENSORS=12]="SPARSE_TENSORS"))(i.AttributeType||(i.AttributeType={}))})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{(o=>(o[o.UNKNOWN=0]="UNKNOWN",o[o.VALUE=1]="VALUE",o[o.PARAM=2]="PARAM"))(i.DimensionValueType||(i.DimensionValueType={}))})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{(o=>(o[o.UNDEFINED=0]="UNDEFINED",o[o.FLOAT=1]="FLOAT",o[o.UINT8=2]="UINT8",o[o.INT8=3]="INT8",o[o.UINT16=4]="UINT16",o[o.INT16=5]="INT16",o[o.INT32=6]="INT32",o[o.INT64=7]="INT64",o[o.STRING=8]="STRING",o[o.BOOL=9]="BOOL",o[o.FLOAT16=10]="FLOAT16",o[o.DOUBLE=11]="DOUBLE",o[o.UINT32=12]="UINT32",o[o.UINT64=13]="UINT64",o[o.COMPLEX64=14]="COMPLEX64",o[o.COMPLEX128=15]="COMPLEX128",o[o.BFLOAT16=16]="BFLOAT16",o[o.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",o[o.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",o[o.FLOAT8E5M2=19]="FLOAT8E5M2",o[o.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"))(i.TensorDataType||(i.TensorDataType={}))})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{(o=>(o[o.Primitive=0]="Primitive",o[o.Fused=1]="Fused"))(i.NodeType||(i.NodeType={}))})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{(o=>(o[o.NONE=0]="NONE",o[o.tensor_type=1]="tensor_type",o[o.sequence_type=2]="sequence_type",o[o.map_type=3]="map_type"))(i.TypeInfoValue||(i.TypeInfoValue={}))})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsShape(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsShape(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}dim(n,s){let p=this.bb.__offset(this.bb_pos,4);return p?(s||new e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+p)+n*4),this.bb):null}dimLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}static startShape(n){n.startObject(1)}static addDim(n,s){n.addFieldOffset(0,s,0)}static createDimVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startDimVector(n,s){n.startVector(4,s,4)}static endShape(n){return n.endObject()}static createShape(n,s){return o.startShape(n),o.addDim(n,s),o.endShape(n)}}i.Shape=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsDimension(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimension(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}value(n){let s=this.bb.__offset(this.bb_pos,4);return s?(n||new e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}denotation(n){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,n):null}static startDimension(n){n.startObject(2)}static addValue(n,s){n.addFieldOffset(0,s,0)}static addDenotation(n,s){n.addFieldOffset(1,s,0)}static endDimension(n){return n.endObject()}static createDimension(n,s,p){return o.startDimension(n),o.addValue(n,s),o.addDenotation(n,p),o.endDimension(n)}}i.Dimension=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsDimensionValue(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimensionValue(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}dimType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt8(this.bb_pos+n):0}dimValue(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}dimParam(n){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__string(this.bb_pos+s,n):null}static startDimensionValue(n){n.startObject(3)}static addDimType(n,s){n.addFieldInt8(0,s,0)}static addDimValue(n,s){n.addFieldInt64(1,s,n.createLong(0,0))}static addDimParam(n,s){n.addFieldOffset(2,s,0)}static endDimensionValue(n){return n.endObject()}static createDimensionValue(n,s,p,c){return o.startDimensionValue(n),o.addDimType(n,s),o.addDimValue(n,p),o.addDimParam(n,c),o.endDimensionValue(n)}}i.DimensionValue=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsTensorTypeAndShape(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensorTypeAndShape(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}elemType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):0}shape(n){let s=this.bb.__offset(this.bb_pos,6);return s?(n||new e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startTensorTypeAndShape(n){n.startObject(2)}static addElemType(n,s){n.addFieldInt32(0,s,0)}static addShape(n,s){n.addFieldOffset(1,s,0)}static endTensorTypeAndShape(n){return n.endObject()}static createTensorTypeAndShape(n,s,p){return o.startTensorTypeAndShape(n),o.addElemType(n,s),o.addShape(n,p),o.endTensorTypeAndShape(n)}}i.TensorTypeAndShape=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsMapType(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsMapType(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}keyType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):0}valueType(n){let s=this.bb.__offset(this.bb_pos,6);return s?(n||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startMapType(n){n.startObject(2)}static addKeyType(n,s){n.addFieldInt32(0,s,0)}static addValueType(n,s){n.addFieldOffset(1,s,0)}static endMapType(n){return n.endObject()}static createMapType(n,s,p){return o.startMapType(n),o.addKeyType(n,s),o.addValueType(n,p),o.endMapType(n)}}i.MapType=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsSequenceType(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSequenceType(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}elemType(n){let s=this.bb.__offset(this.bb_pos,4);return s?(n||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startSequenceType(n){n.startObject(1)}static addElemType(n,s){n.addFieldOffset(0,s,0)}static endSequenceType(n){return n.endObject()}static createSequenceType(n,s){return o.startSequenceType(n),o.addElemType(n,s),o.endSequenceType(n)}}i.SequenceType=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(n,s,p,c){return n.prep(4,12),n.writeInt32(c),n.writeInt32(p),n.writeInt32(s),n.offset()}}i.EdgeEnd=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsNodeEdge(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNodeEdge(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}nodeIndex(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readUint32(this.bb_pos+n):0}inputEdges(n,s){let p=this.bb.__offset(this.bb_pos,6);return p?(s||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+p)+n*12,this.bb):null}inputEdgesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}outputEdges(n,s){let p=this.bb.__offset(this.bb_pos,8);return p?(s||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+p)+n*12,this.bb):null}outputEdgesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNodeEdge(n){n.startObject(3)}static addNodeIndex(n,s){n.addFieldInt32(0,s,0)}static addInputEdges(n,s){n.addFieldOffset(1,s,0)}static startInputEdgesVector(n,s){n.startVector(12,s,4)}static addOutputEdges(n,s){n.addFieldOffset(2,s,0)}static startOutputEdgesVector(n,s){n.startVector(12,s,4)}static endNodeEdge(n){return n.endObject()}static createNodeEdge(n,s,p,c){return o.startNodeEdge(n),o.addNodeIndex(n,s),o.addInputEdges(n,p),o.addOutputEdges(n,c),o.endNodeEdge(n)}}i.NodeEdge=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsNode(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNode(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}name(n){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,n):null}docString(n){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,n):null}domain(n){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__string(this.bb_pos+s,n):null}sinceVersion(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):0}index(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readUint32(this.bb_pos+n):0}opType(n){let s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__string(this.bb_pos+s,n):null}type(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.readInt32(this.bb_pos+n):0}executionProviderType(n){let s=this.bb.__offset(this.bb_pos,18);return s?this.bb.__string(this.bb_pos+s,n):null}inputs(n,s){let p=this.bb.__offset(this.bb_pos,20);return p?this.bb.__string(this.bb.__vector(this.bb_pos+p)+n*4,s):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,s){let p=this.bb.__offset(this.bb_pos,22);return p?this.bb.__string(this.bb.__vector(this.bb_pos+p)+n*4,s):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}attributes(n,s){let p=this.bb.__offset(this.bb_pos,24);return p?(s||new e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+p)+n*4),this.bb):null}attributesLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCounts(n){let s=this.bb.__offset(this.bb_pos,26);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+n*4):0}inputArgCountsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCountsArray(){let n=this.bb.__offset(this.bb_pos,26);return n?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}implicitInputs(n,s){let p=this.bb.__offset(this.bb_pos,28);return p?this.bb.__string(this.bb.__vector(this.bb_pos+p)+n*4,s):null}implicitInputsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNode(n){n.startObject(13)}static addName(n,s){n.addFieldOffset(0,s,0)}static addDocString(n,s){n.addFieldOffset(1,s,0)}static addDomain(n,s){n.addFieldOffset(2,s,0)}static addSinceVersion(n,s){n.addFieldInt32(3,s,0)}static addIndex(n,s){n.addFieldInt32(4,s,0)}static addOpType(n,s){n.addFieldOffset(5,s,0)}static addType(n,s){n.addFieldInt32(6,s,0)}static addExecutionProviderType(n,s){n.addFieldOffset(7,s,0)}static addInputs(n,s){n.addFieldOffset(8,s,0)}static createInputsVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startInputsVector(n,s){n.startVector(4,s,4)}static addOutputs(n,s){n.addFieldOffset(9,s,0)}static createOutputsVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startOutputsVector(n,s){n.startVector(4,s,4)}static addAttributes(n,s){n.addFieldOffset(10,s,0)}static createAttributesVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startAttributesVector(n,s){n.startVector(4,s,4)}static addInputArgCounts(n,s){n.addFieldOffset(11,s,0)}static createInputArgCountsVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addInt32(s[p]);return n.endVector()}static startInputArgCountsVector(n,s){n.startVector(4,s,4)}static addImplicitInputs(n,s){n.addFieldOffset(12,s,0)}static createImplicitInputsVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startImplicitInputsVector(n,s){n.startVector(4,s,4)}static endNode(n){return n.endObject()}static createNode(n,s,p,c,t,l,a,d,h,f,g,y,w,m){return o.startNode(n),o.addName(n,s),o.addDocString(n,p),o.addDomain(n,c),o.addSinceVersion(n,t),o.addIndex(n,l),o.addOpType(n,a),o.addType(n,d),o.addExecutionProviderType(n,h),o.addInputs(n,f),o.addOutputs(n,g),o.addAttributes(n,y),o.addInputArgCounts(n,w),o.addImplicitInputs(n,m),o.endNode(n)}}i.Node=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsValueInfo(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsValueInfo(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}name(n){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,n):null}docString(n){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,n):null}type(n){let s=this.bb.__offset(this.bb_pos,8);return s?(n||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startValueInfo(n){n.startObject(3)}static addName(n,s){n.addFieldOffset(0,s,0)}static addDocString(n,s){n.addFieldOffset(1,s,0)}static addType(n,s){n.addFieldOffset(2,s,0)}static endValueInfo(n){return n.endObject()}static createValueInfo(n,s,p,c){return o.startValueInfo(n),o.addName(n,s),o.addDocString(n,p),o.addType(n,c),o.endValueInfo(n)}}i.ValueInfo=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsTypeInfo(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTypeInfo(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}denotation(n){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,n):null}valueType(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readUint8(this.bb_pos+n):0}value(n){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__union(n,this.bb_pos+s):null}static startTypeInfo(n){n.startObject(3)}static addDenotation(n,s){n.addFieldOffset(0,s,0)}static addValueType(n,s){n.addFieldInt8(1,s,0)}static addValue(n,s){n.addFieldOffset(2,s,0)}static endTypeInfo(n){return n.endObject()}static createTypeInfo(n,s,p,c){return o.startTypeInfo(n),o.addDenotation(n,s),o.addValueType(n,p),o.addValue(n,c),o.endTypeInfo(n)}}i.TypeInfo=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsOperatorSetId(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsOperatorSetId(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}domain(n){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,n):null}version(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}static startOperatorSetId(n){n.startObject(2)}static addDomain(n,s){n.addFieldOffset(0,s,0)}static addVersion(n,s){n.addFieldInt64(1,s,n.createLong(0,0))}static endOperatorSetId(n){return n.endObject()}static createOperatorSetId(n,s,p){return o.startOperatorSetId(n),o.addDomain(n,s),o.addVersion(n,p),o.endOperatorSetId(n)}}i.OperatorSetId=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsTensor(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensor(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}name(n){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,n):null}docString(n){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,n):null}dims(n){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readInt64(this.bb.__vector(this.bb_pos+s)+n*8):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}dataType(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):0}rawData(n){let s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readUint8(this.bb.__vector(this.bb_pos+s)+n):0}rawDataLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}rawDataArray(){let n=this.bb.__offset(this.bb_pos,12);return n?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}stringData(n,s){let p=this.bb.__offset(this.bb_pos,14);return p?this.bb.__string(this.bb.__vector(this.bb_pos+p)+n*4,s):null}stringDataLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}static startTensor(n){n.startObject(6)}static addName(n,s){n.addFieldOffset(0,s,0)}static addDocString(n,s){n.addFieldOffset(1,s,0)}static addDims(n,s){n.addFieldOffset(2,s,0)}static createDimsVector(n,s){n.startVector(8,s.length,8);for(let p=s.length-1;p>=0;p--)n.addInt64(s[p]);return n.endVector()}static startDimsVector(n,s){n.startVector(8,s,8)}static addDataType(n,s){n.addFieldInt32(3,s,0)}static addRawData(n,s){n.addFieldOffset(4,s,0)}static createRawDataVector(n,s){n.startVector(1,s.length,1);for(let p=s.length-1;p>=0;p--)n.addInt8(s[p]);return n.endVector()}static startRawDataVector(n,s){n.startVector(1,s,1)}static addStringData(n,s){n.addFieldOffset(5,s,0)}static createStringDataVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startStringDataVector(n,s){n.startVector(4,s,4)}static endTensor(n){return n.endObject()}static createTensor(n,s,p,c,t,l,a){return o.startTensor(n),o.addName(n,s),o.addDocString(n,p),o.addDims(n,c),o.addDataType(n,t),o.addRawData(n,l),o.addStringData(n,a),o.endTensor(n)}}i.Tensor=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsSparseTensor(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSparseTensor(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}values(n){let s=this.bb.__offset(this.bb_pos,4);return s?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}indices(n){let s=this.bb.__offset(this.bb_pos,6);return s?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}dims(n){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readInt64(this.bb.__vector(this.bb_pos+s)+n*8):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSparseTensor(n){n.startObject(3)}static addValues(n,s){n.addFieldOffset(0,s,0)}static addIndices(n,s){n.addFieldOffset(1,s,0)}static addDims(n,s){n.addFieldOffset(2,s,0)}static createDimsVector(n,s){n.startVector(8,s.length,8);for(let p=s.length-1;p>=0;p--)n.addInt64(s[p]);return n.endVector()}static startDimsVector(n,s){n.startVector(8,s,8)}static endSparseTensor(n){return n.endObject()}static createSparseTensor(n,s,p,c){return o.startSparseTensor(n),o.addValues(n,s),o.addIndices(n,p),o.addDims(n,c),o.endSparseTensor(n)}}i.SparseTensor=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsAttribute(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsAttribute(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}name(n){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,n):null}docString(n){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,n):null}type(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.readInt32(this.bb_pos+n):0}f(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readFloat32(this.bb_pos+n):0}i(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}s(n){let s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__string(this.bb_pos+s,n):null}t(n){let s=this.bb.__offset(this.bb_pos,16);return s?(n||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}g(n){let s=this.bb.__offset(this.bb_pos,18);return s?(n||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}floats(n){let s=this.bb.__offset(this.bb_pos,20);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+n*4):0}floatsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}floatsArray(){let n=this.bb.__offset(this.bb_pos,20);return n?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}ints(n){let s=this.bb.__offset(this.bb_pos,22);return s?this.bb.readInt64(this.bb.__vector(this.bb_pos+s)+n*8):this.bb.createLong(0,0)}intsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}strings(n,s){let p=this.bb.__offset(this.bb_pos,24);return p?this.bb.__string(this.bb.__vector(this.bb_pos+p)+n*4,s):null}stringsLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}tensors(n,s){let p=this.bb.__offset(this.bb_pos,26);return p?(s||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+p)+n*4),this.bb):null}tensorsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}graphs(n,s){let p=this.bb.__offset(this.bb_pos,28);return p?(s||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+p)+n*4),this.bb):null}graphsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startAttribute(n){n.startObject(13)}static addName(n,s){n.addFieldOffset(0,s,0)}static addDocString(n,s){n.addFieldOffset(1,s,0)}static addType(n,s){n.addFieldInt32(2,s,0)}static addF(n,s){n.addFieldFloat32(3,s,0)}static addI(n,s){n.addFieldInt64(4,s,n.createLong(0,0))}static addS(n,s){n.addFieldOffset(5,s,0)}static addT(n,s){n.addFieldOffset(6,s,0)}static addG(n,s){n.addFieldOffset(7,s,0)}static addFloats(n,s){n.addFieldOffset(8,s,0)}static createFloatsVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addFloat32(s[p]);return n.endVector()}static startFloatsVector(n,s){n.startVector(4,s,4)}static addInts(n,s){n.addFieldOffset(9,s,0)}static createIntsVector(n,s){n.startVector(8,s.length,8);for(let p=s.length-1;p>=0;p--)n.addInt64(s[p]);return n.endVector()}static startIntsVector(n,s){n.startVector(8,s,8)}static addStrings(n,s){n.addFieldOffset(10,s,0)}static createStringsVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startStringsVector(n,s){n.startVector(4,s,4)}static addTensors(n,s){n.addFieldOffset(11,s,0)}static createTensorsVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startTensorsVector(n,s){n.startVector(4,s,4)}static addGraphs(n,s){n.addFieldOffset(12,s,0)}static createGraphsVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startGraphsVector(n,s){n.startVector(4,s,4)}static endAttribute(n){return n.endObject()}static createAttribute(n,s,p,c,t,l,a,d,h,f,g,y,w,m){return o.startAttribute(n),o.addName(n,s),o.addDocString(n,p),o.addType(n,c),o.addF(n,t),o.addI(n,l),o.addS(n,a),o.addT(n,d),o.addG(n,h),o.addFloats(n,f),o.addInts(n,g),o.addStrings(n,y),o.addTensors(n,w),o.addGraphs(n,m),o.endAttribute(n)}}i.Attribute=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsGraph(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsGraph(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}initializers(n,s){let p=this.bb.__offset(this.bb_pos,4);return p?(s||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+p)+n*4),this.bb):null}initializersLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeArgs(n,s){let p=this.bb.__offset(this.bb_pos,6);return p?(s||new e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+p)+n*4),this.bb):null}nodeArgsLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}nodes(n,s){let p=this.bb.__offset(this.bb_pos,8);return p?(s||new e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+p)+n*4),this.bb):null}nodesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}maxNodeIndex(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readUint32(this.bb_pos+n):0}nodeEdges(n,s){let p=this.bb.__offset(this.bb_pos,12);return p?(s||new e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+p)+n*4),this.bb):null}nodeEdgesLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}inputs(n,s){let p=this.bb.__offset(this.bb_pos,14);return p?this.bb.__string(this.bb.__vector(this.bb_pos+p)+n*4,s):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,s){let p=this.bb.__offset(this.bb_pos,16);return p?this.bb.__string(this.bb.__vector(this.bb_pos+p)+n*4,s):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__vector_len(this.bb_pos+n):0}sparseInitializers(n,s){let p=this.bb.__offset(this.bb_pos,18);return p?(s||new e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+p)+n*4),this.bb):null}sparseInitializersLength(){let n=this.bb.__offset(this.bb_pos,18);return n?this.bb.__vector_len(this.bb_pos+n):0}static startGraph(n){n.startObject(8)}static addInitializers(n,s){n.addFieldOffset(0,s,0)}static createInitializersVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startInitializersVector(n,s){n.startVector(4,s,4)}static addNodeArgs(n,s){n.addFieldOffset(1,s,0)}static createNodeArgsVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startNodeArgsVector(n,s){n.startVector(4,s,4)}static addNodes(n,s){n.addFieldOffset(2,s,0)}static createNodesVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startNodesVector(n,s){n.startVector(4,s,4)}static addMaxNodeIndex(n,s){n.addFieldInt32(3,s,0)}static addNodeEdges(n,s){n.addFieldOffset(4,s,0)}static createNodeEdgesVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startNodeEdgesVector(n,s){n.startVector(4,s,4)}static addInputs(n,s){n.addFieldOffset(5,s,0)}static createInputsVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startInputsVector(n,s){n.startVector(4,s,4)}static addOutputs(n,s){n.addFieldOffset(6,s,0)}static createOutputsVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startOutputsVector(n,s){n.startVector(4,s,4)}static addSparseInitializers(n,s){n.addFieldOffset(7,s,0)}static createSparseInitializersVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startSparseInitializersVector(n,s){n.startVector(4,s,4)}static endGraph(n){return n.endObject()}static createGraph(n,s,p,c,t,l,a,d,h){return o.startGraph(n),o.addInitializers(n,s),o.addNodeArgs(n,p),o.addNodes(n,c),o.addMaxNodeIndex(n,t),o.addNodeEdges(n,l),o.addInputs(n,a),o.addOutputs(n,d),o.addSparseInitializers(n,h),o.endGraph(n)}}i.Graph=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsModel(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsModel(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}irVersion(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}opsetImport(n,s){let p=this.bb.__offset(this.bb_pos,6);return p?(s||new e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+p)+n*4),this.bb):null}opsetImportLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}producerName(n){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__string(this.bb_pos+s,n):null}producerVersion(n){let s=this.bb.__offset(this.bb_pos,10);return s?this.bb.__string(this.bb_pos+s,n):null}domain(n){let s=this.bb.__offset(this.bb_pos,12);return s?this.bb.__string(this.bb_pos+s,n):null}modelVersion(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}docString(n){let s=this.bb.__offset(this.bb_pos,16);return s?this.bb.__string(this.bb_pos+s,n):null}graph(n){let s=this.bb.__offset(this.bb_pos,18);return s?(n||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}graphDocString(n){let s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__string(this.bb_pos+s,n):null}static startModel(n){n.startObject(9)}static addIrVersion(n,s){n.addFieldInt64(0,s,n.createLong(0,0))}static addOpsetImport(n,s){n.addFieldOffset(1,s,0)}static createOpsetImportVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startOpsetImportVector(n,s){n.startVector(4,s,4)}static addProducerName(n,s){n.addFieldOffset(2,s,0)}static addProducerVersion(n,s){n.addFieldOffset(3,s,0)}static addDomain(n,s){n.addFieldOffset(4,s,0)}static addModelVersion(n,s){n.addFieldInt64(5,s,n.createLong(0,0))}static addDocString(n,s){n.addFieldOffset(6,s,0)}static addGraph(n,s){n.addFieldOffset(7,s,0)}static addGraphDocString(n,s){n.addFieldOffset(8,s,0)}static endModel(n){return n.endObject()}static createModel(n,s,p,c,t,l,a,d,h,f){return o.startModel(n),o.addIrVersion(n,s),o.addOpsetImport(n,p),o.addProducerName(n,c),o.addProducerVersion(n,t),o.addDomain(n,l),o.addModelVersion(n,a),o.addDocString(n,d),o.addGraph(n,h),o.addGraphDocString(n,f),o.endModel(n)}}i.Model=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsKernelCreateInfos(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsKernelCreateInfos(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}nodeIndices(n){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+n*4):0}nodeIndicesLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeIndicesArray(){let n=this.bb.__offset(this.bb_pos,4);return n?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}kernelDefHashes(n){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readUint64(this.bb.__vector(this.bb_pos+s)+n*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startKernelCreateInfos(n){n.startObject(2)}static addNodeIndices(n,s){n.addFieldOffset(0,s,0)}static createNodeIndicesVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addInt32(s[p]);return n.endVector()}static startNodeIndicesVector(n,s){n.startVector(4,s,4)}static addKernelDefHashes(n,s){n.addFieldOffset(1,s,0)}static createKernelDefHashesVector(n,s){n.startVector(8,s.length,8);for(let p=s.length-1;p>=0;p--)n.addInt64(s[p]);return n.endVector()}static startKernelDefHashesVector(n,s){n.startVector(8,s,8)}static endKernelCreateInfos(n){return n.endObject()}static createKernelCreateInfos(n,s,p){return o.startKernelCreateInfos(n),o.addNodeIndices(n,s),o.addKernelDefHashes(n,p),o.endKernelCreateInfos(n)}}i.KernelCreateInfos=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsSubGraphSessionState(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSubGraphSessionState(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}graphId(n){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,n):null}sessionState(n){let s=this.bb.__offset(this.bb_pos,6);return s?(n||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startSubGraphSessionState(n){n.startObject(2)}static addGraphId(n,s){n.addFieldOffset(0,s,0)}static addSessionState(n,s){n.addFieldOffset(1,s,0)}static endSubGraphSessionState(n){let s=n.endObject();return n.requiredField(s,4),s}static createSubGraphSessionState(n,s,p){return o.startSubGraphSessionState(n),o.addGraphId(n,s),o.addSessionState(n,p),o.endSubGraphSessionState(n)}}i.SubGraphSessionState=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsSessionState(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSessionState(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}kernels(n){let s=this.bb.__offset(this.bb_pos,4);return s?(n||new e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}subGraphSessionStates(n,s){let p=this.bb.__offset(this.bb_pos,6);return p?(s||new e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+p)+n*4),this.bb):null}subGraphSessionStatesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSessionState(n){n.startObject(2)}static addKernels(n,s){n.addFieldOffset(0,s,0)}static addSubGraphSessionStates(n,s){n.addFieldOffset(1,s,0)}static createSubGraphSessionStatesVector(n,s){n.startVector(4,s.length,4);for(let p=s.length-1;p>=0;p--)n.addOffset(s[p]);return n.endVector()}static startSubGraphSessionStatesVector(n,s){n.startVector(4,s,4)}static endSessionState(n){return n.endObject()}static createSessionState(n,s,p){return o.startSessionState(n),o.addKernels(n,s),o.addSubGraphSessionStates(n,p),o.endSessionState(n)}}i.SessionState=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={})),(e=>{(r=>{(i=>{class o{constructor(){this.bb=null,this.bb_pos=0}__init(n,s){return this.bb_pos=n,this.bb=s,this}static getRootAsInferenceSession(n,s){return(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsInferenceSession(n,s){return n.setPosition(n.position()+b.SIZE_PREFIX_LENGTH),(s||new o).__init(n.readInt32(n.position())+n.position(),n)}static bufferHasIdentifier(n){return n.__has_identifier("ORTM")}ortVersion(n){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,n):null}model(n){let s=this.bb.__offset(this.bb_pos,6);return s?(n||new e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}sessionState(n){let s=this.bb.__offset(this.bb_pos,8);return s?(n||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startInferenceSession(n){n.startObject(3)}static addOrtVersion(n,s){n.addFieldOffset(0,s,0)}static addModel(n,s){n.addFieldOffset(1,s,0)}static addSessionState(n,s){n.addFieldOffset(2,s,0)}static endInferenceSession(n){return n.endObject()}static finishInferenceSessionBuffer(n,s){n.finish(s,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(n,s){n.finish(s,"ORTM",!0)}static createInferenceSession(n,s,p,c){return o.startInferenceSession(n),o.addOrtVersion(n,s),o.addModel(n,p),o.addSessionState(n,c),o.endInferenceSession(n)}}i.InferenceSession=o})(r.fbs||(r.fbs={}))})(e.experimental||(e.experimental={}))})(P||(P={}))}),Zi=tt((e,r)=>{r.exports=i;function i(o,u){for(var n=new Array(arguments.length-1),s=0,p=2,c=!0;p<arguments.length;)n[s++]=arguments[p++];return new Promise(function(t,l){n[s]=function(a){if(c)if(c=!1,a)l(a);else{for(var d=new Array(arguments.length-1),h=0;h<d.length;)d[h++]=arguments[h];t.apply(null,d)}};try{o.apply(u||null,n)}catch(a){c&&(c=!1,l(a))}})}}),ea=tt(e=>{var r=e;r.length=function(s){var p=s.length;if(!p)return 0;for(var c=0;--p%4>1&&s.charAt(p)==="=";)++c;return Math.ceil(s.length*3)/4-c};var i=new Array(64),o=new Array(123);for(u=0;u<64;)o[i[u]=u<26?u+65:u<52?u+71:u<62?u-4:u-59|43]=u++;var u;r.encode=function(s,p,c){for(var t=null,l=[],a=0,d=0,h;p<c;){var f=s[p++];switch(d){case 0:l[a++]=i[f>>2],h=(f&3)<<4,d=1;break;case 1:l[a++]=i[h|f>>4],h=(f&15)<<2,d=2;break;case 2:l[a++]=i[h|f>>6],l[a++]=i[f&63],d=0;break}a>8191&&((t||(t=[])).push(String.fromCharCode.apply(String,l)),a=0)}return d&&(l[a++]=i[h],l[a++]=61,d===1&&(l[a++]=61)),t?(a&&t.push(String.fromCharCode.apply(String,l.slice(0,a))),t.join("")):String.fromCharCode.apply(String,l.slice(0,a))};var n="invalid encoding";r.decode=function(s,p,c){for(var t=c,l=0,a,d=0;d<s.length;){var h=s.charCodeAt(d++);if(h===61&&l>1)break;if((h=o[h])===void 0)throw Error(n);switch(l){case 0:a=h,l=1;break;case 1:p[c++]=a<<2|(h&48)>>4,a=h,l=2;break;case 2:p[c++]=(a&15)<<4|(h&60)>>2,a=h,l=3;break;case 3:p[c++]=(a&3)<<6|h,l=0;break}}if(l===1)throw Error(n);return c-t},r.test=function(s){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(s)}}),na=tt((e,r)=>{r.exports=i;function i(){this._listeners={}}i.prototype.on=function(o,u,n){return(this._listeners[o]||(this._listeners[o]=[])).push({fn:u,ctx:n||this}),this},i.prototype.off=function(o,u){if(o===void 0)this._listeners={};else if(u===void 0)this._listeners[o]=[];else for(var n=this._listeners[o],s=0;s<n.length;)n[s].fn===u?n.splice(s,1):++s;return this},i.prototype.emit=function(o){var u=this._listeners[o];if(u){for(var n=[],s=1;s<arguments.length;)n.push(arguments[s++]);for(s=0;s<u.length;)u[s].fn.apply(u[s++].ctx,n)}return this}}),fa=tt((e,r)=>{r.exports=i(i);function i(p){return typeof Float32Array<"u"?function(){var c=new Float32Array([-0]),t=new Uint8Array(c.buffer),l=t[3]===128;function a(g,y,w){c[0]=g,y[w]=t[0],y[w+1]=t[1],y[w+2]=t[2],y[w+3]=t[3]}function d(g,y,w){c[0]=g,y[w]=t[3],y[w+1]=t[2],y[w+2]=t[1],y[w+3]=t[0]}p.writeFloatLE=l?a:d,p.writeFloatBE=l?d:a;function h(g,y){return t[0]=g[y],t[1]=g[y+1],t[2]=g[y+2],t[3]=g[y+3],c[0]}function f(g,y){return t[3]=g[y],t[2]=g[y+1],t[1]=g[y+2],t[0]=g[y+3],c[0]}p.readFloatLE=l?h:f,p.readFloatBE=l?f:h}():function(){function c(l,a,d,h){var f=a<0?1:0;if(f&&(a=-a),a===0)l(1/a>0?0:2147483648,d,h);else if(isNaN(a))l(2143289344,d,h);else if(a>34028234663852886e22)l((f<<31|2139095040)>>>0,d,h);else if(a<11754943508222875e-54)l((f<<31|Math.round(a/1401298464324817e-60))>>>0,d,h);else{var g=Math.floor(Math.log(a)/Math.LN2),y=Math.round(a*Math.pow(2,-g)*8388608)&8388607;l((f<<31|g+127<<23|y)>>>0,d,h)}}p.writeFloatLE=c.bind(null,o),p.writeFloatBE=c.bind(null,u);function t(l,a,d){var h=l(a,d),f=(h>>31)*2+1,g=h>>>23&255,y=h&8388607;return g===255?y?NaN:f*(1/0):g===0?f*1401298464324817e-60*y:f*Math.pow(2,g-150)*(y+8388608)}p.readFloatLE=t.bind(null,n),p.readFloatBE=t.bind(null,s)}(),typeof Float64Array<"u"?function(){var c=new Float64Array([-0]),t=new Uint8Array(c.buffer),l=t[7]===128;function a(g,y,w){c[0]=g,y[w]=t[0],y[w+1]=t[1],y[w+2]=t[2],y[w+3]=t[3],y[w+4]=t[4],y[w+5]=t[5],y[w+6]=t[6],y[w+7]=t[7]}function d(g,y,w){c[0]=g,y[w]=t[7],y[w+1]=t[6],y[w+2]=t[5],y[w+3]=t[4],y[w+4]=t[3],y[w+5]=t[2],y[w+6]=t[1],y[w+7]=t[0]}p.writeDoubleLE=l?a:d,p.writeDoubleBE=l?d:a;function h(g,y){return t[0]=g[y],t[1]=g[y+1],t[2]=g[y+2],t[3]=g[y+3],t[4]=g[y+4],t[5]=g[y+5],t[6]=g[y+6],t[7]=g[y+7],c[0]}function f(g,y){return t[7]=g[y],t[6]=g[y+1],t[5]=g[y+2],t[4]=g[y+3],t[3]=g[y+4],t[2]=g[y+5],t[1]=g[y+6],t[0]=g[y+7],c[0]}p.readDoubleLE=l?h:f,p.readDoubleBE=l?f:h}():function(){function c(l,a,d,h,f,g){var y=h<0?1:0;if(y&&(h=-h),h===0)l(0,f,g+a),l(1/h>0?0:2147483648,f,g+d);else if(isNaN(h))l(0,f,g+a),l(2146959360,f,g+d);else if(h>17976931348623157e292)l(0,f,g+a),l((y<<31|2146435072)>>>0,f,g+d);else{var w;if(h<22250738585072014e-324)w=h/5e-324,l(w>>>0,f,g+a),l((y<<31|w/4294967296)>>>0,f,g+d);else{var m=Math.floor(Math.log(h)/Math.LN2);m===1024&&(m=1023),w=h*Math.pow(2,-m),l(w*4503599627370496>>>0,f,g+a),l((y<<31|m+1023<<20|w*1048576&1048575)>>>0,f,g+d)}}}p.writeDoubleLE=c.bind(null,o,0,4),p.writeDoubleBE=c.bind(null,u,4,0);function t(l,a,d,h,f){var g=l(h,f+a),y=l(h,f+d),w=(y>>31)*2+1,m=y>>>20&2047,v=4294967296*(y&1048575)+g;return m===2047?v?NaN:w*(1/0):m===0?w*5e-324*v:w*Math.pow(2,m-1075)*(v+4503599627370496)}p.readDoubleLE=t.bind(null,n,0,4),p.readDoubleBE=t.bind(null,s,4,0)}(),p}function o(p,c,t){c[t]=p&255,c[t+1]=p>>>8&255,c[t+2]=p>>>16&255,c[t+3]=p>>>24}function u(p,c,t){c[t]=p>>>24,c[t+1]=p>>>16&255,c[t+2]=p>>>8&255,c[t+3]=p&255}function n(p,c){return(p[c]|p[c+1]<<8|p[c+2]<<16|p[c+3]<<24)>>>0}function s(p,c){return(p[c]<<24|p[c+1]<<16|p[c+2]<<8|p[c+3])>>>0}}),ca=tt((exports,module)=>{module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}}),da=tt(e=>{var r=e;r.length=function(i){for(var o=0,u=0,n=0;n<i.length;++n)u=i.charCodeAt(n),u<128?o+=1:u<2048?o+=2:(u&64512)===55296&&(i.charCodeAt(n+1)&64512)===56320?(++n,o+=4):o+=3;return o},r.read=function(i,o,u){var n=u-o;if(n<1)return"";for(var s=null,p=[],c=0,t;o<u;)t=i[o++],t<128?p[c++]=t:t>191&&t<224?p[c++]=(t&31)<<6|i[o++]&63:t>239&&t<365?(t=((t&7)<<18|(i[o++]&63)<<12|(i[o++]&63)<<6|i[o++]&63)-65536,p[c++]=55296+(t>>10),p[c++]=56320+(t&1023)):p[c++]=(t&15)<<12|(i[o++]&63)<<6|i[o++]&63,c>8191&&((s||(s=[])).push(String.fromCharCode.apply(String,p)),c=0);return s?(c&&s.push(String.fromCharCode.apply(String,p.slice(0,c))),s.join("")):String.fromCharCode.apply(String,p.slice(0,c))},r.write=function(i,o,u){for(var n=u,s,p,c=0;c<i.length;++c)s=i.charCodeAt(c),s<128?o[u++]=s:s<2048?(o[u++]=s>>6|192,o[u++]=s&63|128):(s&64512)===55296&&((p=i.charCodeAt(c+1))&64512)===56320?(s=65536+((s&1023)<<10)+(p&1023),++c,o[u++]=s>>18|240,o[u++]=s>>12&63|128,o[u++]=s>>6&63|128,o[u++]=s&63|128):(o[u++]=s>>12|224,o[u++]=s>>6&63|128,o[u++]=s&63|128);return u-n}}),ma=tt((e,r)=>{r.exports=i;function i(o,u,n){var s=n||8192,p=s>>>1,c=null,t=s;return function(l){if(l<1||l>p)return o(l);t+l>s&&(c=o(s),t=0);var a=u.call(c,t,t+=l);return t&7&&(t=(t|7)+1),a}}}),ga=tt((e,r)=>{r.exports=o;var i=Qt();function o(p,c){this.lo=p>>>0,this.hi=c>>>0}var u=o.zero=new o(0,0);u.toNumber=function(){return 0},u.zzEncode=u.zzDecode=function(){return this},u.length=function(){return 1};var n=o.zeroHash="\0\0\0\0\0\0\0\0";o.fromNumber=function(p){if(p===0)return u;var c=p<0;c&&(p=-p);var t=p>>>0,l=(p-t)/4294967296>>>0;return c&&(l=~l>>>0,t=~t>>>0,++t>4294967295&&(t=0,++l>4294967295&&(l=0))),new o(t,l)},o.from=function(p){if(typeof p=="number")return o.fromNumber(p);if(i.isString(p))if(i.Long)p=i.Long.fromString(p);else return o.fromNumber(parseInt(p,10));return p.low||p.high?new o(p.low>>>0,p.high>>>0):u},o.prototype.toNumber=function(p){if(!p&&this.hi>>>31){var c=~this.lo+1>>>0,t=~this.hi>>>0;return c||(t=t+1>>>0),-(c+t*4294967296)}return this.lo+this.hi*4294967296},o.prototype.toLong=function(p){return i.Long?new i.Long(this.lo|0,this.hi|0,!!p):{low:this.lo|0,high:this.hi|0,unsigned:!!p}};var s=String.prototype.charCodeAt;o.fromHash=function(p){return p===n?u:new o((s.call(p,0)|s.call(p,1)<<8|s.call(p,2)<<16|s.call(p,3)<<24)>>>0,(s.call(p,4)|s.call(p,5)<<8|s.call(p,6)<<16|s.call(p,7)<<24)>>>0)},o.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},o.prototype.zzEncode=function(){var p=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^p)>>>0,this.lo=(this.lo<<1^p)>>>0,this},o.prototype.zzDecode=function(){var p=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^p)>>>0,this.hi=(this.hi>>>1^p)>>>0,this},o.prototype.length=function(){var p=this.lo,c=(this.lo>>>28|this.hi<<4)>>>0,t=this.hi>>>24;return t===0?c===0?p<16384?p<128?1:2:p<2097152?3:4:c<16384?c<128?5:6:c<2097152?7:8:t<128?9:10}}),Qt=tt(e=>{var r=e;r.asPromise=Zi(),r.base64=ea(),r.EventEmitter=na(),r.float=fa(),r.inquire=ca(),r.utf8=da(),r.pool=ma(),r.LongBits=ga(),r.isNode=!!(typeof commonjsGlobal<"u"&&commonjsGlobal&&commonjsGlobal.process&&commonjsGlobal.process.versions&&commonjsGlobal.process.versions.node),r.global=r.isNode&&commonjsGlobal||typeof window<"u"&&window||typeof self<"u"&&self||e,r.emptyArray=Object.freeze?Object.freeze([]):[],r.emptyObject=Object.freeze?Object.freeze({}):{},r.isInteger=Number.isInteger||function(u){return typeof u=="number"&&isFinite(u)&&Math.floor(u)===u},r.isString=function(u){return typeof u=="string"||u instanceof String},r.isObject=function(u){return u&&typeof u=="object"},r.isset=r.isSet=function(u,n){var s=u[n];return s!=null&&u.hasOwnProperty(n)?typeof s!="object"||(Array.isArray(s)?s.length:Object.keys(s).length)>0:!1},r.Buffer=function(){try{var u=r.inquire("buffer").Buffer;return u.prototype.utf8Write?u:null}catch{return null}}(),r._Buffer_from=null,r._Buffer_allocUnsafe=null,r.newBuffer=function(u){return typeof u=="number"?r.Buffer?r._Buffer_allocUnsafe(u):new r.Array(u):r.Buffer?r._Buffer_from(u):typeof Uint8Array>"u"?u:new Uint8Array(u)},r.Array=typeof Uint8Array<"u"?Uint8Array:Array,r.Long=r.global.dcodeIO&&r.global.dcodeIO.Long||r.global.Long||r.inquire("long"),r.key2Re=/^true|false|0|1$/,r.key32Re=/^-?(?:0|[1-9][0-9]*)$/,r.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,r.longToHash=function(u){return u?r.LongBits.from(u).toHash():r.LongBits.zeroHash},r.longFromHash=function(u,n){var s=r.LongBits.fromHash(u);return r.Long?r.Long.fromBits(s.lo,s.hi,n):s.toNumber(!!n)};function i(u,n,s){for(var p=Object.keys(n),c=0;c<p.length;++c)(u[p[c]]===void 0||!s)&&(u[p[c]]=n[p[c]]);return u}r.merge=i,r.lcFirst=function(u){return u.charAt(0).toLowerCase()+u.substring(1)};function o(u){function n(s,p){if(!(this instanceof n))return new n(s,p);Object.defineProperty(this,"message",{get:function(){return s}}),Error.captureStackTrace?Error.captureStackTrace(this,n):Object.defineProperty(this,"stack",{value:new Error().stack||""}),p&&i(this,p)}return n.prototype=Object.create(Error.prototype,{constructor:{value:n,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return u},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),n}r.newError=o,r.ProtocolError=o("ProtocolError"),r.oneOfGetter=function(u){for(var n={},s=0;s<u.length;++s)n[u[s]]=1;return function(){for(var p=Object.keys(this),c=p.length-1;c>-1;--c)if(n[p[c]]===1&&this[p[c]]!==void 0&&this[p[c]]!==null)return p[c]}},r.oneOfSetter=function(u){return function(n){for(var s=0;s<u.length;++s)u[s]!==n&&delete this[u[s]]}},r.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},r._configure=function(){var u=r.Buffer;if(!u){r._Buffer_from=r._Buffer_allocUnsafe=null;return}r._Buffer_from=u.from!==Uint8Array.from&&u.from||function(n,s){return new u(n,s)},r._Buffer_allocUnsafe=u.allocUnsafe||function(n){return new u(n)}}}),Kn=tt((e,r)=>{r.exports=l;var i=Qt(),o,u=i.LongBits,n=i.base64,s=i.utf8;function p(m,v,T){this.fn=m,this.len=v,this.next=void 0,this.val=T}function c(){}function t(m){this.head=m.head,this.tail=m.tail,this.len=m.len,this.next=m.states}function l(){this.len=0,this.head=new p(c,0,0),this.tail=this.head,this.states=null}var a=function(){return i.Buffer?function(){return(l.create=function(){return new o})()}:function(){return new l}};l.create=a(),l.alloc=function(m){return new i.Array(m)},i.Array!==Array&&(l.alloc=i.pool(l.alloc,i.Array.prototype.subarray)),l.prototype._push=function(m,v,T){return this.tail=this.tail.next=new p(m,v,T),this.len+=v,this};function d(m,v,T){v[T]=m&255}function h(m,v,T){for(;m>127;)v[T++]=m&127|128,m>>>=7;v[T]=m}function f(m,v){this.len=m,this.next=void 0,this.val=v}f.prototype=Object.create(p.prototype),f.prototype.fn=h,l.prototype.uint32=function(m){return this.len+=(this.tail=this.tail.next=new f((m=m>>>0)<128?1:m<16384?2:m<2097152?3:m<268435456?4:5,m)).len,this},l.prototype.int32=function(m){return m<0?this._push(g,10,u.fromNumber(m)):this.uint32(m)},l.prototype.sint32=function(m){return this.uint32((m<<1^m>>31)>>>0)};function g(m,v,T){for(;m.hi;)v[T++]=m.lo&127|128,m.lo=(m.lo>>>7|m.hi<<25)>>>0,m.hi>>>=7;for(;m.lo>127;)v[T++]=m.lo&127|128,m.lo=m.lo>>>7;v[T++]=m.lo}l.prototype.uint64=function(m){var v=u.from(m);return this._push(g,v.length(),v)},l.prototype.int64=l.prototype.uint64,l.prototype.sint64=function(m){var v=u.from(m).zzEncode();return this._push(g,v.length(),v)},l.prototype.bool=function(m){return this._push(d,1,m?1:0)};function y(m,v,T){v[T]=m&255,v[T+1]=m>>>8&255,v[T+2]=m>>>16&255,v[T+3]=m>>>24}l.prototype.fixed32=function(m){return this._push(y,4,m>>>0)},l.prototype.sfixed32=l.prototype.fixed32,l.prototype.fixed64=function(m){var v=u.from(m);return this._push(y,4,v.lo)._push(y,4,v.hi)},l.prototype.sfixed64=l.prototype.fixed64,l.prototype.float=function(m){return this._push(i.float.writeFloatLE,4,m)},l.prototype.double=function(m){return this._push(i.float.writeDoubleLE,8,m)};var w=i.Array.prototype.set?function(m,v,T){v.set(m,T)}:function(m,v,T){for(var _=0;_<m.length;++_)v[T+_]=m[_]};l.prototype.bytes=function(m){var v=m.length>>>0;if(!v)return this._push(d,1,0);if(i.isString(m)){var T=l.alloc(v=n.length(m));n.decode(m,T,0),m=T}return this.uint32(v)._push(w,v,m)},l.prototype.string=function(m){var v=s.length(m);return v?this.uint32(v)._push(s.write,v,m):this._push(d,1,0)},l.prototype.fork=function(){return this.states=new t(this),this.head=this.tail=new p(c,0,0),this.len=0,this},l.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new p(c,0,0),this.len=0),this},l.prototype.ldelim=function(){var m=this.head,v=this.tail,T=this.len;return this.reset().uint32(T),T&&(this.tail.next=m.next,this.tail=v,this.len+=T),this},l.prototype.finish=function(){for(var m=this.head.next,v=this.constructor.alloc(this.len),T=0;m;)m.fn(m.val,v,T),T+=m.len,m=m.next;return v},l._configure=function(m){o=m,l.create=a(),o._configure()}}),Oa=tt((e,r)=>{r.exports=u;var i=Kn();(u.prototype=Object.create(i.prototype)).constructor=u;var o=Qt();function u(){i.call(this)}u._configure=function(){u.alloc=o._Buffer_allocUnsafe,u.writeBytesBuffer=o.Buffer&&o.Buffer.prototype instanceof Uint8Array&&o.Buffer.prototype.set.name==="set"?function(s,p,c){p.set(s,c)}:function(s,p,c){if(s.copy)s.copy(p,c,0,s.length);else for(var t=0;t<s.length;)p[c++]=s[t++]}},u.prototype.bytes=function(s){o.isString(s)&&(s=o._Buffer_from(s,"base64"));var p=s.length>>>0;return this.uint32(p),p&&this._push(u.writeBytesBuffer,p,s),this};function n(s,p,c){s.length<40?o.utf8.write(s,p,c):p.utf8Write?p.utf8Write(s,c):p.write(s,c)}u.prototype.string=function(s){var p=o.Buffer.byteLength(s);return this.uint32(p),p&&this._push(n,p,s),this},u._configure()}),Yn=tt((e,r)=>{r.exports=p;var i=Qt(),o,u=i.LongBits,n=i.utf8;function s(h,f){return RangeError("index out of range: "+h.pos+" + "+(f||1)+" > "+h.len)}function p(h){this.buf=h,this.pos=0,this.len=h.length}var c=typeof Uint8Array<"u"?function(h){if(h instanceof Uint8Array||Array.isArray(h))return new p(h);throw Error("illegal buffer")}:function(h){if(Array.isArray(h))return new p(h);throw Error("illegal buffer")},t=function(){return i.Buffer?function(h){return(p.create=function(f){return i.Buffer.isBuffer(f)?new o(f):c(f)})(h)}:c};p.create=t(),p.prototype._slice=i.Array.prototype.subarray||i.Array.prototype.slice,p.prototype.uint32=function(){var h=4294967295;return function(){if(h=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(h=(h|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(h=(h|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(h=(h|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(h=(h|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return h;if((this.pos+=5)>this.len)throw this.pos=this.len,s(this,10);return h}}(),p.prototype.int32=function(){return this.uint32()|0},p.prototype.sint32=function(){var h=this.uint32();return h>>>1^-(h&1)|0};function l(){var h=new u(0,0),f=0;if(this.len-this.pos>4){for(;f<4;++f)if(h.lo=(h.lo|(this.buf[this.pos]&127)<<f*7)>>>0,this.buf[this.pos++]<128)return h;if(h.lo=(h.lo|(this.buf[this.pos]&127)<<28)>>>0,h.hi=(h.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return h;f=0}else{for(;f<3;++f){if(this.pos>=this.len)throw s(this);if(h.lo=(h.lo|(this.buf[this.pos]&127)<<f*7)>>>0,this.buf[this.pos++]<128)return h}return h.lo=(h.lo|(this.buf[this.pos++]&127)<<f*7)>>>0,h}if(this.len-this.pos>4){for(;f<5;++f)if(h.hi=(h.hi|(this.buf[this.pos]&127)<<f*7+3)>>>0,this.buf[this.pos++]<128)return h}else for(;f<5;++f){if(this.pos>=this.len)throw s(this);if(h.hi=(h.hi|(this.buf[this.pos]&127)<<f*7+3)>>>0,this.buf[this.pos++]<128)return h}throw Error("invalid varint encoding")}p.prototype.bool=function(){return this.uint32()!==0};function a(h,f){return(h[f-4]|h[f-3]<<8|h[f-2]<<16|h[f-1]<<24)>>>0}p.prototype.fixed32=function(){if(this.pos+4>this.len)throw s(this,4);return a(this.buf,this.pos+=4)},p.prototype.sfixed32=function(){if(this.pos+4>this.len)throw s(this,4);return a(this.buf,this.pos+=4)|0};function d(){if(this.pos+8>this.len)throw s(this,8);return new u(a(this.buf,this.pos+=4),a(this.buf,this.pos+=4))}p.prototype.float=function(){if(this.pos+4>this.len)throw s(this,4);var h=i.float.readFloatLE(this.buf,this.pos);return this.pos+=4,h},p.prototype.double=function(){if(this.pos+8>this.len)throw s(this,4);var h=i.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,h},p.prototype.bytes=function(){var h=this.uint32(),f=this.pos,g=this.pos+h;if(g>this.len)throw s(this,h);if(this.pos+=h,Array.isArray(this.buf))return this.buf.slice(f,g);if(f===g){var y=i.Buffer;return y?y.alloc(0):new this.buf.constructor(0)}return this._slice.call(this.buf,f,g)},p.prototype.string=function(){var h=this.bytes();return n.read(h,0,h.length)},p.prototype.skip=function(h){if(typeof h=="number"){if(this.pos+h>this.len)throw s(this,h);this.pos+=h}else do if(this.pos>=this.len)throw s(this);while(this.buf[this.pos++]&128);return this},p.prototype.skipType=function(h){switch(h){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(h=this.uint32()&7)!==4;)this.skipType(h);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+h+" at offset "+this.pos)}return this},p._configure=function(h){o=h,p.create=t(),o._configure();var f=i.Long?"toLong":"toNumber";i.merge(p.prototype,{int64:function(){return l.call(this)[f](!1)},uint64:function(){return l.call(this)[f](!0)},sint64:function(){return l.call(this).zzDecode()[f](!1)},fixed64:function(){return d.call(this)[f](!0)},sfixed64:function(){return d.call(this)[f](!1)}})}}),Fa=tt((e,r)=>{r.exports=u;var i=Yn();(u.prototype=Object.create(i.prototype)).constructor=u;var o=Qt();function u(n){i.call(this,n)}u._configure=function(){o.Buffer&&(u.prototype._slice=o.Buffer.prototype.slice)},u.prototype.string=function(){var n=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+n,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+n,this.len))},u._configure()}),Ca=tt((e,r)=>{r.exports=o;var i=Qt();(o.prototype=Object.create(i.EventEmitter.prototype)).constructor=o;function o(u,n,s){if(typeof u!="function")throw TypeError("rpcImpl must be a function");i.EventEmitter.call(this),this.rpcImpl=u,this.requestDelimited=!!n,this.responseDelimited=!!s}o.prototype.rpcCall=function u(n,s,p,c,t){if(!c)throw TypeError("request must be specified");var l=this;if(!t)return i.asPromise(u,l,n,s,p,c);if(!l.rpcImpl){setTimeout(function(){t(Error("already ended"))},0);return}try{return l.rpcImpl(n,s[l.requestDelimited?"encodeDelimited":"encode"](c).finish(),function(a,d){if(a)return l.emit("error",a,n),t(a);if(d===null){l.end(!0);return}if(!(d instanceof p))try{d=p[l.responseDelimited?"decodeDelimited":"decode"](d)}catch(h){return l.emit("error",h,n),t(h)}return l.emit("data",d,n),t(null,d)})}catch(a){l.emit("error",a,n),setTimeout(function(){t(a)},0);return}},o.prototype.end=function(u){return this.rpcImpl&&(u||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}}),Ga=tt(e=>{var r=e;r.Service=Ca()}),Va=tt((e,r)=>{r.exports={}}),Wa=tt(e=>{var r=e;r.build="minimal",r.Writer=Kn(),r.BufferWriter=Oa(),r.Reader=Yn(),r.BufferReader=Fa(),r.util=Qt(),r.rpc=Ga(),r.roots=Va(),r.configure=i;function i(){r.util._configure(),r.Writer._configure(r.BufferWriter),r.Reader._configure(r.BufferReader)}i()}),qa=tt((e,r)=>{r.exports=Wa()}),Ae=tt((e,r)=>{var i=qa(),o=i.Reader,u=i.Writer,n=i.util,s=i.roots.default||(i.roots.default={});s.onnx=function(){var p={};return p.Version=function(){var c={},t=Object.create(c);return t[c[0]="_START_VERSION"]=0,t[c[1]="IR_VERSION_2017_10_10"]=1,t[c[2]="IR_VERSION_2017_10_30"]=2,t[c[3]="IR_VERSION_2017_11_3"]=3,t[c[4]="IR_VERSION_2019_1_22"]=4,t[c[5]="IR_VERSION_2019_3_18"]=5,t[c[6]="IR_VERSION_2019_9_19"]=6,t[c[7]="IR_VERSION_2020_5_8"]=7,t[c[8]="IR_VERSION_2021_7_30"]=8,t[c[9]="IR_VERSION"]=9,t}(),p.AttributeProto=function(){function c(t){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],t)for(var l=Object.keys(t),a=0;a<l.length;++a)t[l[a]]!=null&&(this[l[a]]=t[l[a]])}return c.prototype.name="",c.prototype.refAttrName="",c.prototype.docString="",c.prototype.type=0,c.prototype.f=0,c.prototype.i=n.Long?n.Long.fromBits(0,0,!1):0,c.prototype.s=n.newBuffer([]),c.prototype.t=null,c.prototype.g=null,c.prototype.sparseTensor=null,c.prototype.tp=null,c.prototype.floats=n.emptyArray,c.prototype.ints=n.emptyArray,c.prototype.strings=n.emptyArray,c.prototype.tensors=n.emptyArray,c.prototype.graphs=n.emptyArray,c.prototype.sparseTensors=n.emptyArray,c.prototype.typeProtos=n.emptyArray,c.create=function(t){return new c(t)},c.encode=function(t,l){if(l||(l=u.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&l.uint32(10).string(t.name),t.f!=null&&Object.hasOwnProperty.call(t,"f")&&l.uint32(21).float(t.f),t.i!=null&&Object.hasOwnProperty.call(t,"i")&&l.uint32(24).int64(t.i),t.s!=null&&Object.hasOwnProperty.call(t,"s")&&l.uint32(34).bytes(t.s),t.t!=null&&Object.hasOwnProperty.call(t,"t")&&s.onnx.TensorProto.encode(t.t,l.uint32(42).fork()).ldelim(),t.g!=null&&Object.hasOwnProperty.call(t,"g")&&s.onnx.GraphProto.encode(t.g,l.uint32(50).fork()).ldelim(),t.floats!=null&&t.floats.length){l.uint32(58).fork();for(var a=0;a<t.floats.length;++a)l.float(t.floats[a]);l.ldelim()}if(t.ints!=null&&t.ints.length){l.uint32(66).fork();for(var a=0;a<t.ints.length;++a)l.int64(t.ints[a]);l.ldelim()}if(t.strings!=null&&t.strings.length)for(var a=0;a<t.strings.length;++a)l.uint32(74).bytes(t.strings[a]);if(t.tensors!=null&&t.tensors.length)for(var a=0;a<t.tensors.length;++a)s.onnx.TensorProto.encode(t.tensors[a],l.uint32(82).fork()).ldelim();if(t.graphs!=null&&t.graphs.length)for(var a=0;a<t.graphs.length;++a)s.onnx.GraphProto.encode(t.graphs[a],l.uint32(90).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&l.uint32(106).string(t.docString),t.tp!=null&&Object.hasOwnProperty.call(t,"tp")&&s.onnx.TypeProto.encode(t.tp,l.uint32(114).fork()).ldelim(),t.typeProtos!=null&&t.typeProtos.length)for(var a=0;a<t.typeProtos.length;++a)s.onnx.TypeProto.encode(t.typeProtos[a],l.uint32(122).fork()).ldelim();if(t.type!=null&&Object.hasOwnProperty.call(t,"type")&&l.uint32(160).int32(t.type),t.refAttrName!=null&&Object.hasOwnProperty.call(t,"refAttrName")&&l.uint32(170).string(t.refAttrName),t.sparseTensor!=null&&Object.hasOwnProperty.call(t,"sparseTensor")&&s.onnx.SparseTensorProto.encode(t.sparseTensor,l.uint32(178).fork()).ldelim(),t.sparseTensors!=null&&t.sparseTensors.length)for(var a=0;a<t.sparseTensors.length;++a)s.onnx.SparseTensorProto.encode(t.sparseTensors[a],l.uint32(186).fork()).ldelim();return l},c.encodeDelimited=function(t,l){return this.encode(t,l).ldelim()},c.decode=function(t,l){t instanceof o||(t=o.create(t));for(var a=l===void 0?t.len:t.pos+l,d=new s.onnx.AttributeProto;t.pos<a;){var h=t.uint32();switch(h>>>3){case 1:{d.name=t.string();break}case 21:{d.refAttrName=t.string();break}case 13:{d.docString=t.string();break}case 20:{d.type=t.int32();break}case 2:{d.f=t.float();break}case 3:{d.i=t.int64();break}case 4:{d.s=t.bytes();break}case 5:{d.t=s.onnx.TensorProto.decode(t,t.uint32());break}case 6:{d.g=s.onnx.GraphProto.decode(t,t.uint32());break}case 22:{d.sparseTensor=s.onnx.SparseTensorProto.decode(t,t.uint32());break}case 14:{d.tp=s.onnx.TypeProto.decode(t,t.uint32());break}case 7:{if(d.floats&&d.floats.length||(d.floats=[]),(h&7)===2)for(var f=t.uint32()+t.pos;t.pos<f;)d.floats.push(t.float());else d.floats.push(t.float());break}case 8:{if(d.ints&&d.ints.length||(d.ints=[]),(h&7)===2)for(var f=t.uint32()+t.pos;t.pos<f;)d.ints.push(t.int64());else d.ints.push(t.int64());break}case 9:{d.strings&&d.strings.length||(d.strings=[]),d.strings.push(t.bytes());break}case 10:{d.tensors&&d.tensors.length||(d.tensors=[]),d.tensors.push(s.onnx.TensorProto.decode(t,t.uint32()));break}case 11:{d.graphs&&d.graphs.length||(d.graphs=[]),d.graphs.push(s.onnx.GraphProto.decode(t,t.uint32()));break}case 23:{d.sparseTensors&&d.sparseTensors.length||(d.sparseTensors=[]),d.sparseTensors.push(s.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 15:{d.typeProtos&&d.typeProtos.length||(d.typeProtos=[]),d.typeProtos.push(s.onnx.TypeProto.decode(t,t.uint32()));break}default:t.skipType(h&7);break}}return d},c.decodeDelimited=function(t){return t instanceof o||(t=new o(t)),this.decode(t,t.uint32())},c.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!n.isString(t.name))return"name: string expected";if(t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&!n.isString(t.refAttrName))return"refAttrName: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!n.isString(t.docString))return"docString: string expected";if(t.type!=null&&t.hasOwnProperty("type"))switch(t.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(t.f!=null&&t.hasOwnProperty("f")&&typeof t.f!="number")return"f: number expected";if(t.i!=null&&t.hasOwnProperty("i")&&!n.isInteger(t.i)&&!(t.i&&n.isInteger(t.i.low)&&n.isInteger(t.i.high)))return"i: integer|Long expected";if(t.s!=null&&t.hasOwnProperty("s")&&!(t.s&&typeof t.s.length=="number"||n.isString(t.s)))return"s: buffer expected";if(t.t!=null&&t.hasOwnProperty("t")){var l=s.onnx.TensorProto.verify(t.t);if(l)return"t."+l}if(t.g!=null&&t.hasOwnProperty("g")){var l=s.onnx.GraphProto.verify(t.g);if(l)return"g."+l}if(t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")){var l=s.onnx.SparseTensorProto.verify(t.sparseTensor);if(l)return"sparseTensor."+l}if(t.tp!=null&&t.hasOwnProperty("tp")){var l=s.onnx.TypeProto.verify(t.tp);if(l)return"tp."+l}if(t.floats!=null&&t.hasOwnProperty("floats")){if(!Array.isArray(t.floats))return"floats: array expected";for(var a=0;a<t.floats.length;++a)if(typeof t.floats[a]!="number")return"floats: number[] expected"}if(t.ints!=null&&t.hasOwnProperty("ints")){if(!Array.isArray(t.ints))return"ints: array expected";for(var a=0;a<t.ints.length;++a)if(!n.isInteger(t.ints[a])&&!(t.ints[a]&&n.isInteger(t.ints[a].low)&&n.isInteger(t.ints[a].high)))return"ints: integer|Long[] expected"}if(t.strings!=null&&t.hasOwnProperty("strings")){if(!Array.isArray(t.strings))return"strings: array expected";for(var a=0;a<t.strings.length;++a)if(!(t.strings[a]&&typeof t.strings[a].length=="number"||n.isString(t.strings[a])))return"strings: buffer[] expected"}if(t.tensors!=null&&t.hasOwnProperty("tensors")){if(!Array.isArray(t.tensors))return"tensors: array expected";for(var a=0;a<t.tensors.length;++a){var l=s.onnx.TensorProto.verify(t.tensors[a]);if(l)return"tensors."+l}}if(t.graphs!=null&&t.hasOwnProperty("graphs")){if(!Array.isArray(t.graphs))return"graphs: array expected";for(var a=0;a<t.graphs.length;++a){var l=s.onnx.GraphProto.verify(t.graphs[a]);if(l)return"graphs."+l}}if(t.sparseTensors!=null&&t.hasOwnProperty("sparseTensors")){if(!Array.isArray(t.sparseTensors))return"sparseTensors: array expected";for(var a=0;a<t.sparseTensors.length;++a){var l=s.onnx.SparseTensorProto.verify(t.sparseTensors[a]);if(l)return"sparseTensors."+l}}if(t.typeProtos!=null&&t.hasOwnProperty("typeProtos")){if(!Array.isArray(t.typeProtos))return"typeProtos: array expected";for(var a=0;a<t.typeProtos.length;++a){var l=s.onnx.TypeProto.verify(t.typeProtos[a]);if(l)return"typeProtos."+l}}return null},c.fromObject=function(t){if(t instanceof s.onnx.AttributeProto)return t;var l=new s.onnx.AttributeProto;switch(t.name!=null&&(l.name=String(t.name)),t.refAttrName!=null&&(l.refAttrName=String(t.refAttrName)),t.docString!=null&&(l.docString=String(t.docString)),t.type){default:if(typeof t.type=="number"){l.type=t.type;break}break;case"UNDEFINED":case 0:l.type=0;break;case"FLOAT":case 1:l.type=1;break;case"INT":case 2:l.type=2;break;case"STRING":case 3:l.type=3;break;case"TENSOR":case 4:l.type=4;break;case"GRAPH":case 5:l.type=5;break;case"SPARSE_TENSOR":case 11:l.type=11;break;case"TYPE_PROTO":case 13:l.type=13;break;case"FLOATS":case 6:l.type=6;break;case"INTS":case 7:l.type=7;break;case"STRINGS":case 8:l.type=8;break;case"TENSORS":case 9:l.type=9;break;case"GRAPHS":case 10:l.type=10;break;case"SPARSE_TENSORS":case 12:l.type=12;break;case"TYPE_PROTOS":case 14:l.type=14;break}if(t.f!=null&&(l.f=Number(t.f)),t.i!=null&&(n.Long?(l.i=n.Long.fromValue(t.i)).unsigned=!1:typeof t.i=="string"?l.i=parseInt(t.i,10):typeof t.i=="number"?l.i=t.i:typeof t.i=="object"&&(l.i=new n.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber())),t.s!=null&&(typeof t.s=="string"?n.base64.decode(t.s,l.s=n.newBuffer(n.base64.length(t.s)),0):t.s.length>=0&&(l.s=t.s)),t.t!=null){if(typeof t.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");l.t=s.onnx.TensorProto.fromObject(t.t)}if(t.g!=null){if(typeof t.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");l.g=s.onnx.GraphProto.fromObject(t.g)}if(t.sparseTensor!=null){if(typeof t.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");l.sparseTensor=s.onnx.SparseTensorProto.fromObject(t.sparseTensor)}if(t.tp!=null){if(typeof t.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");l.tp=s.onnx.TypeProto.fromObject(t.tp)}if(t.floats){if(!Array.isArray(t.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");l.floats=[];for(var a=0;a<t.floats.length;++a)l.floats[a]=Number(t.floats[a])}if(t.ints){if(!Array.isArray(t.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");l.ints=[];for(var a=0;a<t.ints.length;++a)n.Long?(l.ints[a]=n.Long.fromValue(t.ints[a])).unsigned=!1:typeof t.ints[a]=="string"?l.ints[a]=parseInt(t.ints[a],10):typeof t.ints[a]=="number"?l.ints[a]=t.ints[a]:typeof t.ints[a]=="object"&&(l.ints[a]=new n.LongBits(t.ints[a].low>>>0,t.ints[a].high>>>0).toNumber())}if(t.strings){if(!Array.isArray(t.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");l.strings=[];for(var a=0;a<t.strings.length;++a)typeof t.strings[a]=="string"?n.base64.decode(t.strings[a],l.strings[a]=n.newBuffer(n.base64.length(t.strings[a])),0):t.strings[a].length>=0&&(l.strings[a]=t.strings[a])}if(t.tensors){if(!Array.isArray(t.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");l.tensors=[];for(var a=0;a<t.tensors.length;++a){if(typeof t.tensors[a]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");l.tensors[a]=s.onnx.TensorProto.fromObject(t.tensors[a])}}if(t.graphs){if(!Array.isArray(t.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");l.graphs=[];for(var a=0;a<t.graphs.length;++a){if(typeof t.graphs[a]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");l.graphs[a]=s.onnx.GraphProto.fromObject(t.graphs[a])}}if(t.sparseTensors){if(!Array.isArray(t.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");l.sparseTensors=[];for(var a=0;a<t.sparseTensors.length;++a){if(typeof t.sparseTensors[a]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");l.sparseTensors[a]=s.onnx.SparseTensorProto.fromObject(t.sparseTensors[a])}}if(t.typeProtos){if(!Array.isArray(t.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");l.typeProtos=[];for(var a=0;a<t.typeProtos.length;++a){if(typeof t.typeProtos[a]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");l.typeProtos[a]=s.onnx.TypeProto.fromObject(t.typeProtos[a])}}return l},c.toObject=function(t,l){l||(l={});var a={};if((l.arrays||l.defaults)&&(a.floats=[],a.ints=[],a.strings=[],a.tensors=[],a.graphs=[],a.typeProtos=[],a.sparseTensors=[]),l.defaults){if(a.name="",a.f=0,n.Long){var d=new n.Long(0,0,!1);a.i=l.longs===String?d.toString():l.longs===Number?d.toNumber():d}else a.i=l.longs===String?"0":0;l.bytes===String?a.s="":(a.s=[],l.bytes!==Array&&(a.s=n.newBuffer(a.s))),a.t=null,a.g=null,a.docString="",a.tp=null,a.type=l.enums===String?"UNDEFINED":0,a.refAttrName="",a.sparseTensor=null}if(t.name!=null&&t.hasOwnProperty("name")&&(a.name=t.name),t.f!=null&&t.hasOwnProperty("f")&&(a.f=l.json&&!isFinite(t.f)?String(t.f):t.f),t.i!=null&&t.hasOwnProperty("i")&&(typeof t.i=="number"?a.i=l.longs===String?String(t.i):t.i:a.i=l.longs===String?n.Long.prototype.toString.call(t.i):l.longs===Number?new n.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber():t.i),t.s!=null&&t.hasOwnProperty("s")&&(a.s=l.bytes===String?n.base64.encode(t.s,0,t.s.length):l.bytes===Array?Array.prototype.slice.call(t.s):t.s),t.t!=null&&t.hasOwnProperty("t")&&(a.t=s.onnx.TensorProto.toObject(t.t,l)),t.g!=null&&t.hasOwnProperty("g")&&(a.g=s.onnx.GraphProto.toObject(t.g,l)),t.floats&&t.floats.length){a.floats=[];for(var h=0;h<t.floats.length;++h)a.floats[h]=l.json&&!isFinite(t.floats[h])?String(t.floats[h]):t.floats[h]}if(t.ints&&t.ints.length){a.ints=[];for(var h=0;h<t.ints.length;++h)typeof t.ints[h]=="number"?a.ints[h]=l.longs===String?String(t.ints[h]):t.ints[h]:a.ints[h]=l.longs===String?n.Long.prototype.toString.call(t.ints[h]):l.longs===Number?new n.LongBits(t.ints[h].low>>>0,t.ints[h].high>>>0).toNumber():t.ints[h]}if(t.strings&&t.strings.length){a.strings=[];for(var h=0;h<t.strings.length;++h)a.strings[h]=l.bytes===String?n.base64.encode(t.strings[h],0,t.strings[h].length):l.bytes===Array?Array.prototype.slice.call(t.strings[h]):t.strings[h]}if(t.tensors&&t.tensors.length){a.tensors=[];for(var h=0;h<t.tensors.length;++h)a.tensors[h]=s.onnx.TensorProto.toObject(t.tensors[h],l)}if(t.graphs&&t.graphs.length){a.graphs=[];for(var h=0;h<t.graphs.length;++h)a.graphs[h]=s.onnx.GraphProto.toObject(t.graphs[h],l)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(a.docString=t.docString),t.tp!=null&&t.hasOwnProperty("tp")&&(a.tp=s.onnx.TypeProto.toObject(t.tp,l)),t.typeProtos&&t.typeProtos.length){a.typeProtos=[];for(var h=0;h<t.typeProtos.length;++h)a.typeProtos[h]=s.onnx.TypeProto.toObject(t.typeProtos[h],l)}if(t.type!=null&&t.hasOwnProperty("type")&&(a.type=l.enums===String?s.onnx.AttributeProto.AttributeType[t.type]===void 0?t.type:s.onnx.AttributeProto.AttributeType[t.type]:t.type),t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&(a.refAttrName=t.refAttrName),t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")&&(a.sparseTensor=s.onnx.SparseTensorProto.toObject(t.sparseTensor,l)),t.sparseTensors&&t.sparseTensors.length){a.sparseTensors=[];for(var h=0;h<t.sparseTensors.length;++h)a.sparseTensors[h]=s.onnx.SparseTensorProto.toObject(t.sparseTensors[h],l)}return a},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.AttributeProto"},c.AttributeType=function(){var t={},l=Object.create(t);return l[t[0]="UNDEFINED"]=0,l[t[1]="FLOAT"]=1,l[t[2]="INT"]=2,l[t[3]="STRING"]=3,l[t[4]="TENSOR"]=4,l[t[5]="GRAPH"]=5,l[t[11]="SPARSE_TENSOR"]=11,l[t[13]="TYPE_PROTO"]=13,l[t[6]="FLOATS"]=6,l[t[7]="INTS"]=7,l[t[8]="STRINGS"]=8,l[t[9]="TENSORS"]=9,l[t[10]="GRAPHS"]=10,l[t[12]="SPARSE_TENSORS"]=12,l[t[14]="TYPE_PROTOS"]=14,l}(),c}(),p.ValueInfoProto=function(){function c(t){if(t)for(var l=Object.keys(t),a=0;a<l.length;++a)t[l[a]]!=null&&(this[l[a]]=t[l[a]])}return c.prototype.name="",c.prototype.type=null,c.prototype.docString="",c.create=function(t){return new c(t)},c.encode=function(t,l){return l||(l=u.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&l.uint32(10).string(t.name),t.type!=null&&Object.hasOwnProperty.call(t,"type")&&s.onnx.TypeProto.encode(t.type,l.uint32(18).fork()).ldelim(),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&l.uint32(26).string(t.docString),l},c.encodeDelimited=function(t,l){return this.encode(t,l).ldelim()},c.decode=function(t,l){t instanceof o||(t=o.create(t));for(var a=l===void 0?t.len:t.pos+l,d=new s.onnx.ValueInfoProto;t.pos<a;){var h=t.uint32();switch(h>>>3){case 1:{d.name=t.string();break}case 2:{d.type=s.onnx.TypeProto.decode(t,t.uint32());break}case 3:{d.docString=t.string();break}default:t.skipType(h&7);break}}return d},c.decodeDelimited=function(t){return t instanceof o||(t=new o(t)),this.decode(t,t.uint32())},c.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!n.isString(t.name))return"name: string expected";if(t.type!=null&&t.hasOwnProperty("type")){var l=s.onnx.TypeProto.verify(t.type);if(l)return"type."+l}return t.docString!=null&&t.hasOwnProperty("docString")&&!n.isString(t.docString)?"docString: string expected":null},c.fromObject=function(t){if(t instanceof s.onnx.ValueInfoProto)return t;var l=new s.onnx.ValueInfoProto;if(t.name!=null&&(l.name=String(t.name)),t.type!=null){if(typeof t.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");l.type=s.onnx.TypeProto.fromObject(t.type)}return t.docString!=null&&(l.docString=String(t.docString)),l},c.toObject=function(t,l){l||(l={});var a={};return l.defaults&&(a.name="",a.type=null,a.docString=""),t.name!=null&&t.hasOwnProperty("name")&&(a.name=t.name),t.type!=null&&t.hasOwnProperty("type")&&(a.type=s.onnx.TypeProto.toObject(t.type,l)),t.docString!=null&&t.hasOwnProperty("docString")&&(a.docString=t.docString),a},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ValueInfoProto"},c}(),p.NodeProto=function(){function c(t){if(this.input=[],this.output=[],this.attribute=[],t)for(var l=Object.keys(t),a=0;a<l.length;++a)t[l[a]]!=null&&(this[l[a]]=t[l[a]])}return c.prototype.input=n.emptyArray,c.prototype.output=n.emptyArray,c.prototype.name="",c.prototype.opType="",c.prototype.domain="",c.prototype.attribute=n.emptyArray,c.prototype.docString="",c.create=function(t){return new c(t)},c.encode=function(t,l){if(l||(l=u.create()),t.input!=null&&t.input.length)for(var a=0;a<t.input.length;++a)l.uint32(10).string(t.input[a]);if(t.output!=null&&t.output.length)for(var a=0;a<t.output.length;++a)l.uint32(18).string(t.output[a]);if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&l.uint32(26).string(t.name),t.opType!=null&&Object.hasOwnProperty.call(t,"opType")&&l.uint32(34).string(t.opType),t.attribute!=null&&t.attribute.length)for(var a=0;a<t.attribute.length;++a)s.onnx.AttributeProto.encode(t.attribute[a],l.uint32(42).fork()).ldelim();return t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&l.uint32(50).string(t.docString),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&l.uint32(58).string(t.domain),l},c.encodeDelimited=function(t,l){return this.encode(t,l).ldelim()},c.decode=function(t,l){t instanceof o||(t=o.create(t));for(var a=l===void 0?t.len:t.pos+l,d=new s.onnx.NodeProto;t.pos<a;){var h=t.uint32();switch(h>>>3){case 1:{d.input&&d.input.length||(d.input=[]),d.input.push(t.string());break}case 2:{d.output&&d.output.length||(d.output=[]),d.output.push(t.string());break}case 3:{d.name=t.string();break}case 4:{d.opType=t.string();break}case 7:{d.domain=t.string();break}case 5:{d.attribute&&d.attribute.length||(d.attribute=[]),d.attribute.push(s.onnx.AttributeProto.decode(t,t.uint32()));break}case 6:{d.docString=t.string();break}default:t.skipType(h&7);break}}return d},c.decodeDelimited=function(t){return t instanceof o||(t=new o(t)),this.decode(t,t.uint32())},c.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var l=0;l<t.input.length;++l)if(!n.isString(t.input[l]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var l=0;l<t.output.length;++l)if(!n.isString(t.output[l]))return"output: string[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!n.isString(t.name))return"name: string expected";if(t.opType!=null&&t.hasOwnProperty("opType")&&!n.isString(t.opType))return"opType: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!n.isString(t.domain))return"domain: string expected";if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var l=0;l<t.attribute.length;++l){var a=s.onnx.AttributeProto.verify(t.attribute[l]);if(a)return"attribute."+a}}return t.docString!=null&&t.hasOwnProperty("docString")&&!n.isString(t.docString)?"docString: string expected":null},c.fromObject=function(t){if(t instanceof s.onnx.NodeProto)return t;var l=new s.onnx.NodeProto;if(t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.NodeProto.input: array expected");l.input=[];for(var a=0;a<t.input.length;++a)l.input[a]=String(t.input[a])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.NodeProto.output: array expected");l.output=[];for(var a=0;a<t.output.length;++a)l.output[a]=String(t.output[a])}if(t.name!=null&&(l.name=String(t.name)),t.opType!=null&&(l.opType=String(t.opType)),t.domain!=null&&(l.domain=String(t.domain)),t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");l.attribute=[];for(var a=0;a<t.attribute.length;++a){if(typeof t.attribute[a]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");l.attribute[a]=s.onnx.AttributeProto.fromObject(t.attribute[a])}}return t.docString!=null&&(l.docString=String(t.docString)),l},c.toObject=function(t,l){l||(l={});var a={};if((l.arrays||l.defaults)&&(a.input=[],a.output=[],a.attribute=[]),l.defaults&&(a.name="",a.opType="",a.docString="",a.domain=""),t.input&&t.input.length){a.input=[];for(var d=0;d<t.input.length;++d)a.input[d]=t.input[d]}if(t.output&&t.output.length){a.output=[];for(var d=0;d<t.output.length;++d)a.output[d]=t.output[d]}if(t.name!=null&&t.hasOwnProperty("name")&&(a.name=t.name),t.opType!=null&&t.hasOwnProperty("opType")&&(a.opType=t.opType),t.attribute&&t.attribute.length){a.attribute=[];for(var d=0;d<t.attribute.length;++d)a.attribute[d]=s.onnx.AttributeProto.toObject(t.attribute[d],l)}return t.docString!=null&&t.hasOwnProperty("docString")&&(a.docString=t.docString),t.domain!=null&&t.hasOwnProperty("domain")&&(a.domain=t.domain),a},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.NodeProto"},c}(),p.TrainingInfoProto=function(){function c(t){if(this.initializationBinding=[],this.updateBinding=[],t)for(var l=Object.keys(t),a=0;a<l.length;++a)t[l[a]]!=null&&(this[l[a]]=t[l[a]])}return c.prototype.initialization=null,c.prototype.algorithm=null,c.prototype.initializationBinding=n.emptyArray,c.prototype.updateBinding=n.emptyArray,c.create=function(t){return new c(t)},c.encode=function(t,l){if(l||(l=u.create()),t.initialization!=null&&Object.hasOwnProperty.call(t,"initialization")&&s.onnx.GraphProto.encode(t.initialization,l.uint32(10).fork()).ldelim(),t.algorithm!=null&&Object.hasOwnProperty.call(t,"algorithm")&&s.onnx.GraphProto.encode(t.algorithm,l.uint32(18).fork()).ldelim(),t.initializationBinding!=null&&t.initializationBinding.length)for(var a=0;a<t.initializationBinding.length;++a)s.onnx.StringStringEntryProto.encode(t.initializationBinding[a],l.uint32(26).fork()).ldelim();if(t.updateBinding!=null&&t.updateBinding.length)for(var a=0;a<t.updateBinding.length;++a)s.onnx.StringStringEntryProto.encode(t.updateBinding[a],l.uint32(34).fork()).ldelim();return l},c.encodeDelimited=function(t,l){return this.encode(t,l).ldelim()},c.decode=function(t,l){t instanceof o||(t=o.create(t));for(var a=l===void 0?t.len:t.pos+l,d=new s.onnx.TrainingInfoProto;t.pos<a;){var h=t.uint32();switch(h>>>3){case 1:{d.initialization=s.onnx.GraphProto.decode(t,t.uint32());break}case 2:{d.algorithm=s.onnx.GraphProto.decode(t,t.uint32());break}case 3:{d.initializationBinding&&d.initializationBinding.length||(d.initializationBinding=[]),d.initializationBinding.push(s.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 4:{d.updateBinding&&d.updateBinding.length||(d.updateBinding=[]),d.updateBinding.push(s.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(h&7);break}}return d},c.decodeDelimited=function(t){return t instanceof o||(t=new o(t)),this.decode(t,t.uint32())},c.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.initialization!=null&&t.hasOwnProperty("initialization")){var l=s.onnx.GraphProto.verify(t.initialization);if(l)return"initialization."+l}if(t.algorithm!=null&&t.hasOwnProperty("algorithm")){var l=s.onnx.GraphProto.verify(t.algorithm);if(l)return"algorithm."+l}if(t.initializationBinding!=null&&t.hasOwnProperty("initializationBinding")){if(!Array.isArray(t.initializationBinding))return"initializationBinding: array expected";for(var a=0;a<t.initializationBinding.length;++a){var l=s.onnx.StringStringEntryProto.verify(t.initializationBinding[a]);if(l)return"initializationBinding."+l}}if(t.updateBinding!=null&&t.hasOwnProperty("updateBinding")){if(!Array.isArray(t.updateBinding))return"updateBinding: array expected";for(var a=0;a<t.updateBinding.length;++a){var l=s.onnx.StringStringEntryProto.verify(t.updateBinding[a]);if(l)return"updateBinding."+l}}return null},c.fromObject=function(t){if(t instanceof s.onnx.TrainingInfoProto)return t;var l=new s.onnx.TrainingInfoProto;if(t.initialization!=null){if(typeof t.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");l.initialization=s.onnx.GraphProto.fromObject(t.initialization)}if(t.algorithm!=null){if(typeof t.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");l.algorithm=s.onnx.GraphProto.fromObject(t.algorithm)}if(t.initializationBinding){if(!Array.isArray(t.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");l.initializationBinding=[];for(var a=0;a<t.initializationBinding.length;++a){if(typeof t.initializationBinding[a]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");l.initializationBinding[a]=s.onnx.StringStringEntryProto.fromObject(t.initializationBinding[a])}}if(t.updateBinding){if(!Array.isArray(t.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");l.updateBinding=[];for(var a=0;a<t.updateBinding.length;++a){if(typeof t.updateBinding[a]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");l.updateBinding[a]=s.onnx.StringStringEntryProto.fromObject(t.updateBinding[a])}}return l},c.toObject=function(t,l){l||(l={});var a={};if((l.arrays||l.defaults)&&(a.initializationBinding=[],a.updateBinding=[]),l.defaults&&(a.initialization=null,a.algorithm=null),t.initialization!=null&&t.hasOwnProperty("initialization")&&(a.initialization=s.onnx.GraphProto.toObject(t.initialization,l)),t.algorithm!=null&&t.hasOwnProperty("algorithm")&&(a.algorithm=s.onnx.GraphProto.toObject(t.algorithm,l)),t.initializationBinding&&t.initializationBinding.length){a.initializationBinding=[];for(var d=0;d<t.initializationBinding.length;++d)a.initializationBinding[d]=s.onnx.StringStringEntryProto.toObject(t.initializationBinding[d],l)}if(t.updateBinding&&t.updateBinding.length){a.updateBinding=[];for(var d=0;d<t.updateBinding.length;++d)a.updateBinding[d]=s.onnx.StringStringEntryProto.toObject(t.updateBinding[d],l)}return a},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TrainingInfoProto"},c}(),p.ModelProto=function(){function c(t){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],t)for(var l=Object.keys(t),a=0;a<l.length;++a)t[l[a]]!=null&&(this[l[a]]=t[l[a]])}return c.prototype.irVersion=n.Long?n.Long.fromBits(0,0,!1):0,c.prototype.opsetImport=n.emptyArray,c.prototype.producerName="",c.prototype.producerVersion="",c.prototype.domain="",c.prototype.modelVersion=n.Long?n.Long.fromBits(0,0,!1):0,c.prototype.docString="",c.prototype.graph=null,c.prototype.metadataProps=n.emptyArray,c.prototype.trainingInfo=n.emptyArray,c.prototype.functions=n.emptyArray,c.create=function(t){return new c(t)},c.encode=function(t,l){if(l||(l=u.create()),t.irVersion!=null&&Object.hasOwnProperty.call(t,"irVersion")&&l.uint32(8).int64(t.irVersion),t.producerName!=null&&Object.hasOwnProperty.call(t,"producerName")&&l.uint32(18).string(t.producerName),t.producerVersion!=null&&Object.hasOwnProperty.call(t,"producerVersion")&&l.uint32(26).string(t.producerVersion),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&l.uint32(34).string(t.domain),t.modelVersion!=null&&Object.hasOwnProperty.call(t,"modelVersion")&&l.uint32(40).int64(t.modelVersion),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&l.uint32(50).string(t.docString),t.graph!=null&&Object.hasOwnProperty.call(t,"graph")&&s.onnx.GraphProto.encode(t.graph,l.uint32(58).fork()).ldelim(),t.opsetImport!=null&&t.opsetImport.length)for(var a=0;a<t.opsetImport.length;++a)s.onnx.OperatorSetIdProto.encode(t.opsetImport[a],l.uint32(66).fork()).ldelim();if(t.metadataProps!=null&&t.metadataProps.length)for(var a=0;a<t.metadataProps.length;++a)s.onnx.StringStringEntryProto.encode(t.metadataProps[a],l.uint32(114).fork()).ldelim();if(t.trainingInfo!=null&&t.trainingInfo.length)for(var a=0;a<t.trainingInfo.length;++a)s.onnx.TrainingInfoProto.encode(t.trainingInfo[a],l.uint32(162).fork()).ldelim();if(t.functions!=null&&t.functions.length)for(var a=0;a<t.functions.length;++a)s.onnx.FunctionProto.encode(t.functions[a],l.uint32(202).fork()).ldelim();return l},c.encodeDelimited=function(t,l){return this.encode(t,l).ldelim()},c.decode=function(t,l){t instanceof o||(t=o.create(t));for(var a=l===void 0?t.len:t.pos+l,d=new s.onnx.ModelProto;t.pos<a;){var h=t.uint32();switch(h>>>3){case 1:{d.irVersion=t.int64();break}case 8:{d.opsetImport&&d.opsetImport.length||(d.opsetImport=[]),d.opsetImport.push(s.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 2:{d.producerName=t.string();break}case 3:{d.producerVersion=t.string();break}case 4:{d.domain=t.string();break}case 5:{d.modelVersion=t.int64();break}case 6:{d.docString=t.string();break}case 7:{d.graph=s.onnx.GraphProto.decode(t,t.uint32());break}case 14:{d.metadataProps&&d.metadataProps.length||(d.metadataProps=[]),d.metadataProps.push(s.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 20:{d.trainingInfo&&d.trainingInfo.length||(d.trainingInfo=[]),d.trainingInfo.push(s.onnx.TrainingInfoProto.decode(t,t.uint32()));break}case 25:{d.functions&&d.functions.length||(d.functions=[]),d.functions.push(s.onnx.FunctionProto.decode(t,t.uint32()));break}default:t.skipType(h&7);break}}return d},c.decodeDelimited=function(t){return t instanceof o||(t=new o(t)),this.decode(t,t.uint32())},c.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&!n.isInteger(t.irVersion)&&!(t.irVersion&&n.isInteger(t.irVersion.low)&&n.isInteger(t.irVersion.high)))return"irVersion: integer|Long expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var l=0;l<t.opsetImport.length;++l){var a=s.onnx.OperatorSetIdProto.verify(t.opsetImport[l]);if(a)return"opsetImport."+a}}if(t.producerName!=null&&t.hasOwnProperty("producerName")&&!n.isString(t.producerName))return"producerName: string expected";if(t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&!n.isString(t.producerVersion))return"producerVersion: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!n.isString(t.domain))return"domain: string expected";if(t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&!n.isInteger(t.modelVersion)&&!(t.modelVersion&&n.isInteger(t.modelVersion.low)&&n.isInteger(t.modelVersion.high)))return"modelVersion: integer|Long expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!n.isString(t.docString))return"docString: string expected";if(t.graph!=null&&t.hasOwnProperty("graph")){var a=s.onnx.GraphProto.verify(t.graph);if(a)return"graph."+a}if(t.metadataProps!=null&&t.hasOwnProperty("metadataProps")){if(!Array.isArray(t.metadataProps))return"metadataProps: array expected";for(var l=0;l<t.metadataProps.length;++l){var a=s.onnx.StringStringEntryProto.verify(t.metadataProps[l]);if(a)return"metadataProps."+a}}if(t.trainingInfo!=null&&t.hasOwnProperty("trainingInfo")){if(!Array.isArray(t.trainingInfo))return"trainingInfo: array expected";for(var l=0;l<t.trainingInfo.length;++l){var a=s.onnx.TrainingInfoProto.verify(t.trainingInfo[l]);if(a)return"trainingInfo."+a}}if(t.functions!=null&&t.hasOwnProperty("functions")){if(!Array.isArray(t.functions))return"functions: array expected";for(var l=0;l<t.functions.length;++l){var a=s.onnx.FunctionProto.verify(t.functions[l]);if(a)return"functions."+a}}return null},c.fromObject=function(t){if(t instanceof s.onnx.ModelProto)return t;var l=new s.onnx.ModelProto;if(t.irVersion!=null&&(n.Long?(l.irVersion=n.Long.fromValue(t.irVersion)).unsigned=!1:typeof t.irVersion=="string"?l.irVersion=parseInt(t.irVersion,10):typeof t.irVersion=="number"?l.irVersion=t.irVersion:typeof t.irVersion=="object"&&(l.irVersion=new n.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber())),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");l.opsetImport=[];for(var a=0;a<t.opsetImport.length;++a){if(typeof t.opsetImport[a]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");l.opsetImport[a]=s.onnx.OperatorSetIdProto.fromObject(t.opsetImport[a])}}if(t.producerName!=null&&(l.producerName=String(t.producerName)),t.producerVersion!=null&&(l.producerVersion=String(t.producerVersion)),t.domain!=null&&(l.domain=String(t.domain)),t.modelVersion!=null&&(n.Long?(l.modelVersion=n.Long.fromValue(t.modelVersion)).unsigned=!1:typeof t.modelVersion=="string"?l.modelVersion=parseInt(t.modelVersion,10):typeof t.modelVersion=="number"?l.modelVersion=t.modelVersion:typeof t.modelVersion=="object"&&(l.modelVersion=new n.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber())),t.docString!=null&&(l.docString=String(t.docString)),t.graph!=null){if(typeof t.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");l.graph=s.onnx.GraphProto.fromObject(t.graph)}if(t.metadataProps){if(!Array.isArray(t.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");l.metadataProps=[];for(var a=0;a<t.metadataProps.length;++a){if(typeof t.metadataProps[a]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");l.metadataProps[a]=s.onnx.StringStringEntryProto.fromObject(t.metadataProps[a])}}if(t.trainingInfo){if(!Array.isArray(t.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");l.trainingInfo=[];for(var a=0;a<t.trainingInfo.length;++a){if(typeof t.trainingInfo[a]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");l.trainingInfo[a]=s.onnx.TrainingInfoProto.fromObject(t.trainingInfo[a])}}if(t.functions){if(!Array.isArray(t.functions))throw TypeError(".onnx.ModelProto.functions: array expected");l.functions=[];for(var a=0;a<t.functions.length;++a){if(typeof t.functions[a]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");l.functions[a]=s.onnx.FunctionProto.fromObject(t.functions[a])}}return l},c.toObject=function(t,l){l||(l={});var a={};if((l.arrays||l.defaults)&&(a.opsetImport=[],a.metadataProps=[],a.trainingInfo=[],a.functions=[]),l.defaults){if(n.Long){var d=new n.Long(0,0,!1);a.irVersion=l.longs===String?d.toString():l.longs===Number?d.toNumber():d}else a.irVersion=l.longs===String?"0":0;if(a.producerName="",a.producerVersion="",a.domain="",n.Long){var d=new n.Long(0,0,!1);a.modelVersion=l.longs===String?d.toString():l.longs===Number?d.toNumber():d}else a.modelVersion=l.longs===String?"0":0;a.docString="",a.graph=null}if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&(typeof t.irVersion=="number"?a.irVersion=l.longs===String?String(t.irVersion):t.irVersion:a.irVersion=l.longs===String?n.Long.prototype.toString.call(t.irVersion):l.longs===Number?new n.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber():t.irVersion),t.producerName!=null&&t.hasOwnProperty("producerName")&&(a.producerName=t.producerName),t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&(a.producerVersion=t.producerVersion),t.domain!=null&&t.hasOwnProperty("domain")&&(a.domain=t.domain),t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&(typeof t.modelVersion=="number"?a.modelVersion=l.longs===String?String(t.modelVersion):t.modelVersion:a.modelVersion=l.longs===String?n.Long.prototype.toString.call(t.modelVersion):l.longs===Number?new n.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber():t.modelVersion),t.docString!=null&&t.hasOwnProperty("docString")&&(a.docString=t.docString),t.graph!=null&&t.hasOwnProperty("graph")&&(a.graph=s.onnx.GraphProto.toObject(t.graph,l)),t.opsetImport&&t.opsetImport.length){a.opsetImport=[];for(var h=0;h<t.opsetImport.length;++h)a.opsetImport[h]=s.onnx.OperatorSetIdProto.toObject(t.opsetImport[h],l)}if(t.metadataProps&&t.metadataProps.length){a.metadataProps=[];for(var h=0;h<t.metadataProps.length;++h)a.metadataProps[h]=s.onnx.StringStringEntryProto.toObject(t.metadataProps[h],l)}if(t.trainingInfo&&t.trainingInfo.length){a.trainingInfo=[];for(var h=0;h<t.trainingInfo.length;++h)a.trainingInfo[h]=s.onnx.TrainingInfoProto.toObject(t.trainingInfo[h],l)}if(t.functions&&t.functions.length){a.functions=[];for(var h=0;h<t.functions.length;++h)a.functions[h]=s.onnx.FunctionProto.toObject(t.functions[h],l)}return a},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ModelProto"},c}(),p.StringStringEntryProto=function(){function c(t){if(t)for(var l=Object.keys(t),a=0;a<l.length;++a)t[l[a]]!=null&&(this[l[a]]=t[l[a]])}return c.prototype.key="",c.prototype.value="",c.create=function(t){return new c(t)},c.encode=function(t,l){return l||(l=u.create()),t.key!=null&&Object.hasOwnProperty.call(t,"key")&&l.uint32(10).string(t.key),t.value!=null&&Object.hasOwnProperty.call(t,"value")&&l.uint32(18).string(t.value),l},c.encodeDelimited=function(t,l){return this.encode(t,l).ldelim()},c.decode=function(t,l){t instanceof o||(t=o.create(t));for(var a=l===void 0?t.len:t.pos+l,d=new s.onnx.StringStringEntryProto;t.pos<a;){var h=t.uint32();switch(h>>>3){case 1:{d.key=t.string();break}case 2:{d.value=t.string();break}default:t.skipType(h&7);break}}return d},c.decodeDelimited=function(t){return t instanceof o||(t=new o(t)),this.decode(t,t.uint32())},c.verify=function(t){return typeof t!="object"||t===null?"object expected":t.key!=null&&t.hasOwnProperty("key")&&!n.isString(t.key)?"key: string expected":t.value!=null&&t.hasOwnProperty("value")&&!n.isString(t.value)?"value: string expected":null},c.fromObject=function(t){if(t instanceof s.onnx.StringStringEntryProto)return t;var l=new s.onnx.StringStringEntryProto;return t.key!=null&&(l.key=String(t.key)),t.value!=null&&(l.value=String(t.value)),l},c.toObject=function(t,l){l||(l={});var a={};return l.defaults&&(a.key="",a.value=""),t.key!=null&&t.hasOwnProperty("key")&&(a.key=t.key),t.value!=null&&t.hasOwnProperty("value")&&(a.value=t.value),a},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.StringStringEntryProto"},c}(),p.TensorAnnotation=function(){function c(t){if(this.quantParameterTensorNames=[],t)for(var l=Object.keys(t),a=0;a<l.length;++a)t[l[a]]!=null&&(this[l[a]]=t[l[a]])}return c.prototype.tensorName="",c.prototype.quantParameterTensorNames=n.emptyArray,c.create=function(t){return new c(t)},c.encode=function(t,l){if(l||(l=u.create()),t.tensorName!=null&&Object.hasOwnProperty.call(t,"tensorName")&&l.uint32(10).string(t.tensorName),t.quantParameterTensorNames!=null&&t.quantParameterTensorNames.length)for(var a=0;a<t.quantParameterTensorNames.length;++a)s.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[a],l.uint32(18).fork()).ldelim();return l},c.encodeDelimited=function(t,l){return this.encode(t,l).ldelim()},c.decode=function(t,l){t instanceof o||(t=o.create(t));for(var a=l===void 0?t.len:t.pos+l,d=new s.onnx.TensorAnnotation;t.pos<a;){var h=t.uint32();switch(h>>>3){case 1:{d.tensorName=t.string();break}case 2:{d.quantParameterTensorNames&&d.quantParameterTensorNames.length||(d.quantParameterTensorNames=[]),d.quantParameterTensorNames.push(s.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(h&7);break}}return d},c.decodeDelimited=function(t){return t instanceof o||(t=new o(t)),this.decode(t,t.uint32())},c.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.tensorName!=null&&t.hasOwnProperty("tensorName")&&!n.isString(t.tensorName))return"tensorName: string expected";if(t.quantParameterTensorNames!=null&&t.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(t.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var l=0;l<t.quantParameterTensorNames.length;++l){var a=s.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[l]);if(a)return"quantParameterTensorNames."+a}}return null},c.fromObject=function(t){if(t instanceof s.onnx.TensorAnnotation)return t;var l=new s.onnx.TensorAnnotation;if(t.tensorName!=null&&(l.tensorName=String(t.tensorName)),t.quantParameterTensorNames){if(!Array.isArray(t.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");l.quantParameterTensorNames=[];for(var a=0;a<t.quantParameterTensorNames.length;++a){if(typeof t.quantParameterTensorNames[a]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");l.quantParameterTensorNames[a]=s.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[a])}}return l},c.toObject=function(t,l){l||(l={});var a={};if((l.arrays||l.defaults)&&(a.quantParameterTensorNames=[]),l.defaults&&(a.tensorName=""),t.tensorName!=null&&t.hasOwnProperty("tensorName")&&(a.tensorName=t.tensorName),t.quantParameterTensorNames&&t.quantParameterTensorNames.length){a.quantParameterTensorNames=[];for(var d=0;d<t.quantParameterTensorNames.length;++d)a.quantParameterTensorNames[d]=s.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[d],l)}return a},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorAnnotation"},c}(),p.GraphProto=function(){function c(t){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],t)for(var l=Object.keys(t),a=0;a<l.length;++a)t[l[a]]!=null&&(this[l[a]]=t[l[a]])}return c.prototype.node=n.emptyArray,c.prototype.name="",c.prototype.initializer=n.emptyArray,c.prototype.sparseInitializer=n.emptyArray,c.prototype.docString="",c.prototype.input=n.emptyArray,c.prototype.output=n.emptyArray,c.prototype.valueInfo=n.emptyArray,c.prototype.quantizationAnnotation=n.emptyArray,c.create=function(t){return new c(t)},c.encode=function(t,l){if(l||(l=u.create()),t.node!=null&&t.node.length)for(var a=0;a<t.node.length;++a)s.onnx.NodeProto.encode(t.node[a],l.uint32(10).fork()).ldelim();if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&l.uint32(18).string(t.name),t.initializer!=null&&t.initializer.length)for(var a=0;a<t.initializer.length;++a)s.onnx.TensorProto.encode(t.initializer[a],l.uint32(42).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&l.uint32(82).string(t.docString),t.input!=null&&t.input.length)for(var a=0;a<t.input.length;++a)s.onnx.ValueInfoProto.encode(t.input[a],l.uint32(90).fork()).ldelim();if(t.output!=null&&t.output.length)for(var a=0;a<t.output.length;++a)s.onnx.ValueInfoProto.encode(t.output[a],l.uint32(98).fork()).ldelim();if(t.valueInfo!=null&&t.valueInfo.length)for(var a=0;a<t.valueInfo.length;++a)s.onnx.ValueInfoProto.encode(t.valueInfo[a],l.uint32(106).fork()).ldelim();if(t.quantizationAnnotation!=null&&t.quantizationAnnotation.length)for(var a=0;a<t.quantizationAnnotation.length;++a)s.onnx.TensorAnnotation.encode(t.quantizationAnnotation[a],l.uint32(114).fork()).ldelim();if(t.sparseInitializer!=null&&t.sparseInitializer.length)for(var a=0;a<t.sparseInitializer.length;++a)s.onnx.SparseTensorProto.encode(t.sparseInitializer[a],l.uint32(122).fork()).ldelim();return l},c.encodeDelimited=function(t,l){return this.encode(t,l).ldelim()},c.decode=function(t,l){t instanceof o||(t=o.create(t));for(var a=l===void 0?t.len:t.pos+l,d=new s.onnx.GraphProto;t.pos<a;){var h=t.uint32();switch(h>>>3){case 1:{d.node&&d.node.length||(d.node=[]),d.node.push(s.onnx.NodeProto.decode(t,t.uint32()));break}case 2:{d.name=t.string();break}case 5:{d.initializer&&d.initializer.length||(d.initializer=[]),d.initializer.push(s.onnx.TensorProto.decode(t,t.uint32()));break}case 15:{d.sparseInitializer&&d.sparseInitializer.length||(d.sparseInitializer=[]),d.sparseInitializer.push(s.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 10:{d.docString=t.string();break}case 11:{d.input&&d.input.length||(d.input=[]),d.input.push(s.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 12:{d.output&&d.output.length||(d.output=[]),d.output.push(s.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 13:{d.valueInfo&&d.valueInfo.length||(d.valueInfo=[]),d.valueInfo.push(s.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 14:{d.quantizationAnnotation&&d.quantizationAnnotation.length||(d.quantizationAnnotation=[]),d.quantizationAnnotation.push(s.onnx.TensorAnnotation.decode(t,t.uint32()));break}default:t.skipType(h&7);break}}return d},c.decodeDelimited=function(t){return t instanceof o||(t=new o(t)),this.decode(t,t.uint32())},c.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var l=0;l<t.node.length;++l){var a=s.onnx.NodeProto.verify(t.node[l]);if(a)return"node."+a}}if(t.name!=null&&t.hasOwnProperty("name")&&!n.isString(t.name))return"name: string expected";if(t.initializer!=null&&t.hasOwnProperty("initializer")){if(!Array.isArray(t.initializer))return"initializer: array expected";for(var l=0;l<t.initializer.length;++l){var a=s.onnx.TensorProto.verify(t.initializer[l]);if(a)return"initializer."+a}}if(t.sparseInitializer!=null&&t.hasOwnProperty("sparseInitializer")){if(!Array.isArray(t.sparseInitializer))return"sparseInitializer: array expected";for(var l=0;l<t.sparseInitializer.length;++l){var a=s.onnx.SparseTensorProto.verify(t.sparseInitializer[l]);if(a)return"sparseInitializer."+a}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!n.isString(t.docString))return"docString: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var l=0;l<t.input.length;++l){var a=s.onnx.ValueInfoProto.verify(t.input[l]);if(a)return"input."+a}}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var l=0;l<t.output.length;++l){var a=s.onnx.ValueInfoProto.verify(t.output[l]);if(a)return"output."+a}}if(t.valueInfo!=null&&t.hasOwnProperty("valueInfo")){if(!Array.isArray(t.valueInfo))return"valueInfo: array expected";for(var l=0;l<t.valueInfo.length;++l){var a=s.onnx.ValueInfoProto.verify(t.valueInfo[l]);if(a)return"valueInfo."+a}}if(t.quantizationAnnotation!=null&&t.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(t.quantizationAnnotation))return"quantizationAnnotation: array expected";for(var l=0;l<t.quantizationAnnotation.length;++l){var a=s.onnx.TensorAnnotation.verify(t.quantizationAnnotation[l]);if(a)return"quantizationAnnotation."+a}}return null},c.fromObject=function(t){if(t instanceof s.onnx.GraphProto)return t;var l=new s.onnx.GraphProto;if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.GraphProto.node: array expected");l.node=[];for(var a=0;a<t.node.length;++a){if(typeof t.node[a]!="object")throw TypeError(".onnx.GraphProto.node: object expected");l.node[a]=s.onnx.NodeProto.fromObject(t.node[a])}}if(t.name!=null&&(l.name=String(t.name)),t.initializer){if(!Array.isArray(t.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");l.initializer=[];for(var a=0;a<t.initializer.length;++a){if(typeof t.initializer[a]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");l.initializer[a]=s.onnx.TensorProto.fromObject(t.initializer[a])}}if(t.sparseInitializer){if(!Array.isArray(t.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");l.sparseInitializer=[];for(var a=0;a<t.sparseInitializer.length;++a){if(typeof t.sparseInitializer[a]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");l.sparseInitializer[a]=s.onnx.SparseTensorProto.fromObject(t.sparseInitializer[a])}}if(t.docString!=null&&(l.docString=String(t.docString)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.GraphProto.input: array expected");l.input=[];for(var a=0;a<t.input.length;++a){if(typeof t.input[a]!="object")throw TypeError(".onnx.GraphProto.input: object expected");l.input[a]=s.onnx.ValueInfoProto.fromObject(t.input[a])}}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.GraphProto.output: array expected");l.output=[];for(var a=0;a<t.output.length;++a){if(typeof t.output[a]!="object")throw TypeError(".onnx.GraphProto.output: object expected");l.output[a]=s.onnx.ValueInfoProto.fromObject(t.output[a])}}if(t.valueInfo){if(!Array.isArray(t.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");l.valueInfo=[];for(var a=0;a<t.valueInfo.length;++a){if(typeof t.valueInfo[a]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");l.valueInfo[a]=s.onnx.ValueInfoProto.fromObject(t.valueInfo[a])}}if(t.quantizationAnnotation){if(!Array.isArray(t.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");l.quantizationAnnotation=[];for(var a=0;a<t.quantizationAnnotation.length;++a){if(typeof t.quantizationAnnotation[a]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");l.quantizationAnnotation[a]=s.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[a])}}return l},c.toObject=function(t,l){l||(l={});var a={};if((l.arrays||l.defaults)&&(a.node=[],a.initializer=[],a.input=[],a.output=[],a.valueInfo=[],a.quantizationAnnotation=[],a.sparseInitializer=[]),l.defaults&&(a.name="",a.docString=""),t.node&&t.node.length){a.node=[];for(var d=0;d<t.node.length;++d)a.node[d]=s.onnx.NodeProto.toObject(t.node[d],l)}if(t.name!=null&&t.hasOwnProperty("name")&&(a.name=t.name),t.initializer&&t.initializer.length){a.initializer=[];for(var d=0;d<t.initializer.length;++d)a.initializer[d]=s.onnx.TensorProto.toObject(t.initializer[d],l)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(a.docString=t.docString),t.input&&t.input.length){a.input=[];for(var d=0;d<t.input.length;++d)a.input[d]=s.onnx.ValueInfoProto.toObject(t.input[d],l)}if(t.output&&t.output.length){a.output=[];for(var d=0;d<t.output.length;++d)a.output[d]=s.onnx.ValueInfoProto.toObject(t.output[d],l)}if(t.valueInfo&&t.valueInfo.length){a.valueInfo=[];for(var d=0;d<t.valueInfo.length;++d)a.valueInfo[d]=s.onnx.ValueInfoProto.toObject(t.valueInfo[d],l)}if(t.quantizationAnnotation&&t.quantizationAnnotation.length){a.quantizationAnnotation=[];for(var d=0;d<t.quantizationAnnotation.length;++d)a.quantizationAnnotation[d]=s.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[d],l)}if(t.sparseInitializer&&t.sparseInitializer.length){a.sparseInitializer=[];for(var d=0;d<t.sparseInitializer.length;++d)a.sparseInitializer[d]=s.onnx.SparseTensorProto.toObject(t.sparseInitializer[d],l)}return a},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.GraphProto"},c}(),p.TensorProto=function(){function c(t){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],t)for(var l=Object.keys(t),a=0;a<l.length;++a)t[l[a]]!=null&&(this[l[a]]=t[l[a]])}return c.prototype.dims=n.emptyArray,c.prototype.dataType=0,c.prototype.segment=null,c.prototype.floatData=n.emptyArray,c.prototype.int32Data=n.emptyArray,c.prototype.stringData=n.emptyArray,c.prototype.int64Data=n.emptyArray,c.prototype.name="",c.prototype.docString="",c.prototype.rawData=n.newBuffer([]),c.prototype.externalData=n.emptyArray,c.prototype.dataLocation=0,c.prototype.doubleData=n.emptyArray,c.prototype.uint64Data=n.emptyArray,c.create=function(t){return new c(t)},c.encode=function(t,l){if(l||(l=u.create()),t.dims!=null&&t.dims.length){l.uint32(10).fork();for(var a=0;a<t.dims.length;++a)l.int64(t.dims[a]);l.ldelim()}if(t.dataType!=null&&Object.hasOwnProperty.call(t,"dataType")&&l.uint32(16).int32(t.dataType),t.segment!=null&&Object.hasOwnProperty.call(t,"segment")&&s.onnx.TensorProto.Segment.encode(t.segment,l.uint32(26).fork()).ldelim(),t.floatData!=null&&t.floatData.length){l.uint32(34).fork();for(var a=0;a<t.floatData.length;++a)l.float(t.floatData[a]);l.ldelim()}if(t.int32Data!=null&&t.int32Data.length){l.uint32(42).fork();for(var a=0;a<t.int32Data.length;++a)l.int32(t.int32Data[a]);l.ldelim()}if(t.stringData!=null&&t.stringData.length)for(var a=0;a<t.stringData.length;++a)l.uint32(50).bytes(t.stringData[a]);if(t.int64Data!=null&&t.int64Data.length){l.uint32(58).fork();for(var a=0;a<t.int64Data.length;++a)l.int64(t.int64Data[a]);l.ldelim()}if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&l.uint32(66).string(t.name),t.rawData!=null&&Object.hasOwnProperty.call(t,"rawData")&&l.uint32(74).bytes(t.rawData),t.doubleData!=null&&t.doubleData.length){l.uint32(82).fork();for(var a=0;a<t.doubleData.length;++a)l.double(t.doubleData[a]);l.ldelim()}if(t.uint64Data!=null&&t.uint64Data.length){l.uint32(90).fork();for(var a=0;a<t.uint64Data.length;++a)l.uint64(t.uint64Data[a]);l.ldelim()}if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&l.uint32(98).string(t.docString),t.externalData!=null&&t.externalData.length)for(var a=0;a<t.externalData.length;++a)s.onnx.StringStringEntryProto.encode(t.externalData[a],l.uint32(106).fork()).ldelim();return t.dataLocation!=null&&Object.hasOwnProperty.call(t,"dataLocation")&&l.uint32(112).int32(t.dataLocation),l},c.encodeDelimited=function(t,l){return this.encode(t,l).ldelim()},c.decode=function(t,l){t instanceof o||(t=o.create(t));for(var a=l===void 0?t.len:t.pos+l,d=new s.onnx.TensorProto;t.pos<a;){var h=t.uint32();switch(h>>>3){case 1:{if(d.dims&&d.dims.length||(d.dims=[]),(h&7)===2)for(var f=t.uint32()+t.pos;t.pos<f;)d.dims.push(t.int64());else d.dims.push(t.int64());break}case 2:{d.dataType=t.int32();break}case 3:{d.segment=s.onnx.TensorProto.Segment.decode(t,t.uint32());break}case 4:{if(d.floatData&&d.floatData.length||(d.floatData=[]),(h&7)===2)for(var f=t.uint32()+t.pos;t.pos<f;)d.floatData.push(t.float());else d.floatData.push(t.float());break}case 5:{if(d.int32Data&&d.int32Data.length||(d.int32Data=[]),(h&7)===2)for(var f=t.uint32()+t.pos;t.pos<f;)d.int32Data.push(t.int32());else d.int32Data.push(t.int32());break}case 6:{d.stringData&&d.stringData.length||(d.stringData=[]),d.stringData.push(t.bytes());break}case 7:{if(d.int64Data&&d.int64Data.length||(d.int64Data=[]),(h&7)===2)for(var f=t.uint32()+t.pos;t.pos<f;)d.int64Data.push(t.int64());else d.int64Data.push(t.int64());break}case 8:{d.name=t.string();break}case 12:{d.docString=t.string();break}case 9:{d.rawData=t.bytes();break}case 13:{d.externalData&&d.externalData.length||(d.externalData=[]),d.externalData.push(s.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 14:{d.dataLocation=t.int32();break}case 10:{if(d.doubleData&&d.doubleData.length||(d.doubleData=[]),(h&7)===2)for(var f=t.uint32()+t.pos;t.pos<f;)d.doubleData.push(t.double());else d.doubleData.push(t.double());break}case 11:{if(d.uint64Data&&d.uint64Data.length||(d.uint64Data=[]),(h&7)===2)for(var f=t.uint32()+t.pos;t.pos<f;)d.uint64Data.push(t.uint64());else d.uint64Data.push(t.uint64());break}default:t.skipType(h&7);break}}return d},c.decodeDelimited=function(t){return t instanceof o||(t=new o(t)),this.decode(t,t.uint32())},c.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var l=0;l<t.dims.length;++l)if(!n.isInteger(t.dims[l])&&!(t.dims[l]&&n.isInteger(t.dims[l].low)&&n.isInteger(t.dims[l].high)))return"dims: integer|Long[] expected"}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&!n.isInteger(t.dataType))return"dataType: integer expected";if(t.segment!=null&&t.hasOwnProperty("segment")){var a=s.onnx.TensorProto.Segment.verify(t.segment);if(a)return"segment."+a}if(t.floatData!=null&&t.hasOwnProperty("floatData")){if(!Array.isArray(t.floatData))return"floatData: array expected";for(var l=0;l<t.floatData.length;++l)if(typeof t.floatData[l]!="number")return"floatData: number[] expected"}if(t.int32Data!=null&&t.hasOwnProperty("int32Data")){if(!Array.isArray(t.int32Data))return"int32Data: array expected";for(var l=0;l<t.int32Data.length;++l)if(!n.isInteger(t.int32Data[l]))return"int32Data: integer[] expected"}if(t.stringData!=null&&t.hasOwnProperty("stringData")){if(!Array.isArray(t.stringData))return"stringData: array expected";for(var l=0;l<t.stringData.length;++l)if(!(t.stringData[l]&&typeof t.stringData[l].length=="number"||n.isString(t.stringData[l])))return"stringData: buffer[] expected"}if(t.int64Data!=null&&t.hasOwnProperty("int64Data")){if(!Array.isArray(t.int64Data))return"int64Data: array expected";for(var l=0;l<t.int64Data.length;++l)if(!n.isInteger(t.int64Data[l])&&!(t.int64Data[l]&&n.isInteger(t.int64Data[l].low)&&n.isInteger(t.int64Data[l].high)))return"int64Data: integer|Long[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!n.isString(t.name))return"name: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!n.isString(t.docString))return"docString: string expected";if(t.rawData!=null&&t.hasOwnProperty("rawData")&&!(t.rawData&&typeof t.rawData.length=="number"||n.isString(t.rawData)))return"rawData: buffer expected";if(t.externalData!=null&&t.hasOwnProperty("externalData")){if(!Array.isArray(t.externalData))return"externalData: array expected";for(var l=0;l<t.externalData.length;++l){var a=s.onnx.StringStringEntryProto.verify(t.externalData[l]);if(a)return"externalData."+a}}if(t.dataLocation!=null&&t.hasOwnProperty("dataLocation"))switch(t.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:break}if(t.doubleData!=null&&t.hasOwnProperty("doubleData")){if(!Array.isArray(t.doubleData))return"doubleData: array expected";for(var l=0;l<t.doubleData.length;++l)if(typeof t.doubleData[l]!="number")return"doubleData: number[] expected"}if(t.uint64Data!=null&&t.hasOwnProperty("uint64Data")){if(!Array.isArray(t.uint64Data))return"uint64Data: array expected";for(var l=0;l<t.uint64Data.length;++l)if(!n.isInteger(t.uint64Data[l])&&!(t.uint64Data[l]&&n.isInteger(t.uint64Data[l].low)&&n.isInteger(t.uint64Data[l].high)))return"uint64Data: integer|Long[] expected"}return null},c.fromObject=function(t){if(t instanceof s.onnx.TensorProto)return t;var l=new s.onnx.TensorProto;if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.TensorProto.dims: array expected");l.dims=[];for(var a=0;a<t.dims.length;++a)n.Long?(l.dims[a]=n.Long.fromValue(t.dims[a])).unsigned=!1:typeof t.dims[a]=="string"?l.dims[a]=parseInt(t.dims[a],10):typeof t.dims[a]=="number"?l.dims[a]=t.dims[a]:typeof t.dims[a]=="object"&&(l.dims[a]=new n.LongBits(t.dims[a].low>>>0,t.dims[a].high>>>0).toNumber())}if(t.dataType!=null&&(l.dataType=t.dataType|0),t.segment!=null){if(typeof t.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");l.segment=s.onnx.TensorProto.Segment.fromObject(t.segment)}if(t.floatData){if(!Array.isArray(t.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");l.floatData=[];for(var a=0;a<t.floatData.length;++a)l.floatData[a]=Number(t.floatData[a])}if(t.int32Data){if(!Array.isArray(t.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");l.int32Data=[];for(var a=0;a<t.int32Data.length;++a)l.int32Data[a]=t.int32Data[a]|0}if(t.stringData){if(!Array.isArray(t.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");l.stringData=[];for(var a=0;a<t.stringData.length;++a)typeof t.stringData[a]=="string"?n.base64.decode(t.stringData[a],l.stringData[a]=n.newBuffer(n.base64.length(t.stringData[a])),0):t.stringData[a].length>=0&&(l.stringData[a]=t.stringData[a])}if(t.int64Data){if(!Array.isArray(t.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");l.int64Data=[];for(var a=0;a<t.int64Data.length;++a)n.Long?(l.int64Data[a]=n.Long.fromValue(t.int64Data[a])).unsigned=!1:typeof t.int64Data[a]=="string"?l.int64Data[a]=parseInt(t.int64Data[a],10):typeof t.int64Data[a]=="number"?l.int64Data[a]=t.int64Data[a]:typeof t.int64Data[a]=="object"&&(l.int64Data[a]=new n.LongBits(t.int64Data[a].low>>>0,t.int64Data[a].high>>>0).toNumber())}if(t.name!=null&&(l.name=String(t.name)),t.docString!=null&&(l.docString=String(t.docString)),t.rawData!=null&&(typeof t.rawData=="string"?n.base64.decode(t.rawData,l.rawData=n.newBuffer(n.base64.length(t.rawData)),0):t.rawData.length>=0&&(l.rawData=t.rawData)),t.externalData){if(!Array.isArray(t.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");l.externalData=[];for(var a=0;a<t.externalData.length;++a){if(typeof t.externalData[a]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");l.externalData[a]=s.onnx.StringStringEntryProto.fromObject(t.externalData[a])}}switch(t.dataLocation){default:if(typeof t.dataLocation=="number"){l.dataLocation=t.dataLocation;break}break;case"DEFAULT":case 0:l.dataLocation=0;break;case"EXTERNAL":case 1:l.dataLocation=1;break}if(t.doubleData){if(!Array.isArray(t.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");l.doubleData=[];for(var a=0;a<t.doubleData.length;++a)l.doubleData[a]=Number(t.doubleData[a])}if(t.uint64Data){if(!Array.isArray(t.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");l.uint64Data=[];for(var a=0;a<t.uint64Data.length;++a)n.Long?(l.uint64Data[a]=n.Long.fromValue(t.uint64Data[a])).unsigned=!0:typeof t.uint64Data[a]=="string"?l.uint64Data[a]=parseInt(t.uint64Data[a],10):typeof t.uint64Data[a]=="number"?l.uint64Data[a]=t.uint64Data[a]:typeof t.uint64Data[a]=="object"&&(l.uint64Data[a]=new n.LongBits(t.uint64Data[a].low>>>0,t.uint64Data[a].high>>>0).toNumber(!0))}return l},c.toObject=function(t,l){l||(l={});var a={};if((l.arrays||l.defaults)&&(a.dims=[],a.floatData=[],a.int32Data=[],a.stringData=[],a.int64Data=[],a.doubleData=[],a.uint64Data=[],a.externalData=[]),l.defaults&&(a.dataType=0,a.segment=null,a.name="",l.bytes===String?a.rawData="":(a.rawData=[],l.bytes!==Array&&(a.rawData=n.newBuffer(a.rawData))),a.docString="",a.dataLocation=l.enums===String?"DEFAULT":0),t.dims&&t.dims.length){a.dims=[];for(var d=0;d<t.dims.length;++d)typeof t.dims[d]=="number"?a.dims[d]=l.longs===String?String(t.dims[d]):t.dims[d]:a.dims[d]=l.longs===String?n.Long.prototype.toString.call(t.dims[d]):l.longs===Number?new n.LongBits(t.dims[d].low>>>0,t.dims[d].high>>>0).toNumber():t.dims[d]}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&(a.dataType=t.dataType),t.segment!=null&&t.hasOwnProperty("segment")&&(a.segment=s.onnx.TensorProto.Segment.toObject(t.segment,l)),t.floatData&&t.floatData.length){a.floatData=[];for(var d=0;d<t.floatData.length;++d)a.floatData[d]=l.json&&!isFinite(t.floatData[d])?String(t.floatData[d]):t.floatData[d]}if(t.int32Data&&t.int32Data.length){a.int32Data=[];for(var d=0;d<t.int32Data.length;++d)a.int32Data[d]=t.int32Data[d]}if(t.stringData&&t.stringData.length){a.stringData=[];for(var d=0;d<t.stringData.length;++d)a.stringData[d]=l.bytes===String?n.base64.encode(t.stringData[d],0,t.stringData[d].length):l.bytes===Array?Array.prototype.slice.call(t.stringData[d]):t.stringData[d]}if(t.int64Data&&t.int64Data.length){a.int64Data=[];for(var d=0;d<t.int64Data.length;++d)typeof t.int64Data[d]=="number"?a.int64Data[d]=l.longs===String?String(t.int64Data[d]):t.int64Data[d]:a.int64Data[d]=l.longs===String?n.Long.prototype.toString.call(t.int64Data[d]):l.longs===Number?new n.LongBits(t.int64Data[d].low>>>0,t.int64Data[d].high>>>0).toNumber():t.int64Data[d]}if(t.name!=null&&t.hasOwnProperty("name")&&(a.name=t.name),t.rawData!=null&&t.hasOwnProperty("rawData")&&(a.rawData=l.bytes===String?n.base64.encode(t.rawData,0,t.rawData.length):l.bytes===Array?Array.prototype.slice.call(t.rawData):t.rawData),t.doubleData&&t.doubleData.length){a.doubleData=[];for(var d=0;d<t.doubleData.length;++d)a.doubleData[d]=l.json&&!isFinite(t.doubleData[d])?String(t.doubleData[d]):t.doubleData[d]}if(t.uint64Data&&t.uint64Data.length){a.uint64Data=[];for(var d=0;d<t.uint64Data.length;++d)typeof t.uint64Data[d]=="number"?a.uint64Data[d]=l.longs===String?String(t.uint64Data[d]):t.uint64Data[d]:a.uint64Data[d]=l.longs===String?n.Long.prototype.toString.call(t.uint64Data[d]):l.longs===Number?new n.LongBits(t.uint64Data[d].low>>>0,t.uint64Data[d].high>>>0).toNumber(!0):t.uint64Data[d]}if(t.docString!=null&&t.hasOwnProperty("docString")&&(a.docString=t.docString),t.externalData&&t.externalData.length){a.externalData=[];for(var d=0;d<t.externalData.length;++d)a.externalData[d]=s.onnx.StringStringEntryProto.toObject(t.externalData[d],l)}return t.dataLocation!=null&&t.hasOwnProperty("dataLocation")&&(a.dataLocation=l.enums===String?s.onnx.TensorProto.DataLocation[t.dataLocation]===void 0?t.dataLocation:s.onnx.TensorProto.DataLocation[t.dataLocation]:t.dataLocation),a},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorProto"},c.DataType=function(){var t={},l=Object.create(t);return l[t[0]="UNDEFINED"]=0,l[t[1]="FLOAT"]=1,l[t[2]="UINT8"]=2,l[t[3]="INT8"]=3,l[t[4]="UINT16"]=4,l[t[5]="INT16"]=5,l[t[6]="INT32"]=6,l[t[7]="INT64"]=7,l[t[8]="STRING"]=8,l[t[9]="BOOL"]=9,l[t[10]="FLOAT16"]=10,l[t[11]="DOUBLE"]=11,l[t[12]="UINT32"]=12,l[t[13]="UINT64"]=13,l[t[14]="COMPLEX64"]=14,l[t[15]="COMPLEX128"]=15,l[t[16]="BFLOAT16"]=16,l[t[17]="FLOAT8E4M3FN"]=17,l[t[18]="FLOAT8E4M3FNUZ"]=18,l[t[19]="FLOAT8E5M2"]=19,l[t[20]="FLOAT8E5M2FNUZ"]=20,l}(),c.Segment=function(){function t(l){if(l)for(var a=Object.keys(l),d=0;d<a.length;++d)l[a[d]]!=null&&(this[a[d]]=l[a[d]])}return t.prototype.begin=n.Long?n.Long.fromBits(0,0,!1):0,t.prototype.end=n.Long?n.Long.fromBits(0,0,!1):0,t.create=function(l){return new t(l)},t.encode=function(l,a){return a||(a=u.create()),l.begin!=null&&Object.hasOwnProperty.call(l,"begin")&&a.uint32(8).int64(l.begin),l.end!=null&&Object.hasOwnProperty.call(l,"end")&&a.uint32(16).int64(l.end),a},t.encodeDelimited=function(l,a){return this.encode(l,a).ldelim()},t.decode=function(l,a){l instanceof o||(l=o.create(l));for(var d=a===void 0?l.len:l.pos+a,h=new s.onnx.TensorProto.Segment;l.pos<d;){var f=l.uint32();switch(f>>>3){case 1:{h.begin=l.int64();break}case 2:{h.end=l.int64();break}default:l.skipType(f&7);break}}return h},t.decodeDelimited=function(l){return l instanceof o||(l=new o(l)),this.decode(l,l.uint32())},t.verify=function(l){return typeof l!="object"||l===null?"object expected":l.begin!=null&&l.hasOwnProperty("begin")&&!n.isInteger(l.begin)&&!(l.begin&&n.isInteger(l.begin.low)&&n.isInteger(l.begin.high))?"begin: integer|Long expected":l.end!=null&&l.hasOwnProperty("end")&&!n.isInteger(l.end)&&!(l.end&&n.isInteger(l.end.low)&&n.isInteger(l.end.high))?"end: integer|Long expected":null},t.fromObject=function(l){if(l instanceof s.onnx.TensorProto.Segment)return l;var a=new s.onnx.TensorProto.Segment;return l.begin!=null&&(n.Long?(a.begin=n.Long.fromValue(l.begin)).unsigned=!1:typeof l.begin=="string"?a.begin=parseInt(l.begin,10):typeof l.begin=="number"?a.begin=l.begin:typeof l.begin=="object"&&(a.begin=new n.LongBits(l.begin.low>>>0,l.begin.high>>>0).toNumber())),l.end!=null&&(n.Long?(a.end=n.Long.fromValue(l.end)).unsigned=!1:typeof l.end=="string"?a.end=parseInt(l.end,10):typeof l.end=="number"?a.end=l.end:typeof l.end=="object"&&(a.end=new n.LongBits(l.end.low>>>0,l.end.high>>>0).toNumber())),a},t.toObject=function(l,a){a||(a={});var d={};if(a.defaults){if(n.Long){var h=new n.Long(0,0,!1);d.begin=a.longs===String?h.toString():a.longs===Number?h.toNumber():h}else d.begin=a.longs===String?"0":0;if(n.Long){var h=new n.Long(0,0,!1);d.end=a.longs===String?h.toString():a.longs===Number?h.toNumber():h}else d.end=a.longs===String?"0":0}return l.begin!=null&&l.hasOwnProperty("begin")&&(typeof l.begin=="number"?d.begin=a.longs===String?String(l.begin):l.begin:d.begin=a.longs===String?n.Long.prototype.toString.call(l.begin):a.longs===Number?new n.LongBits(l.begin.low>>>0,l.begin.high>>>0).toNumber():l.begin),l.end!=null&&l.hasOwnProperty("end")&&(typeof l.end=="number"?d.end=a.longs===String?String(l.end):l.end:d.end=a.longs===String?n.Long.prototype.toString.call(l.end):a.longs===Number?new n.LongBits(l.end.low>>>0,l.end.high>>>0).toNumber():l.end),d},t.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},t.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TensorProto.Segment"},t}(),c.DataLocation=function(){var t={},l=Object.create(t);return l[t[0]="DEFAULT"]=0,l[t[1]="EXTERNAL"]=1,l}(),c}(),p.SparseTensorProto=function(){function c(t){if(this.dims=[],t)for(var l=Object.keys(t),a=0;a<l.length;++a)t[l[a]]!=null&&(this[l[a]]=t[l[a]])}return c.prototype.values=null,c.prototype.indices=null,c.prototype.dims=n.emptyArray,c.create=function(t){return new c(t)},c.encode=function(t,l){if(l||(l=u.create()),t.values!=null&&Object.hasOwnProperty.call(t,"values")&&s.onnx.TensorProto.encode(t.values,l.uint32(10).fork()).ldelim(),t.indices!=null&&Object.hasOwnProperty.call(t,"indices")&&s.onnx.TensorProto.encode(t.indices,l.uint32(18).fork()).ldelim(),t.dims!=null&&t.dims.length){l.uint32(26).fork();for(var a=0;a<t.dims.length;++a)l.int64(t.dims[a]);l.ldelim()}return l},c.encodeDelimited=function(t,l){return this.encode(t,l).ldelim()},c.decode=function(t,l){t instanceof o||(t=o.create(t));for(var a=l===void 0?t.len:t.pos+l,d=new s.onnx.SparseTensorProto;t.pos<a;){var h=t.uint32();switch(h>>>3){case 1:{d.values=s.onnx.TensorProto.decode(t,t.uint32());break}case 2:{d.indices=s.onnx.TensorProto.decode(t,t.uint32());break}case 3:{if(d.dims&&d.dims.length||(d.dims=[]),(h&7)===2)for(var f=t.uint32()+t.pos;t.pos<f;)d.dims.push(t.int64());else d.dims.push(t.int64());break}default:t.skipType(h&7);break}}return d},c.decodeDelimited=function(t){return t instanceof o||(t=new o(t)),this.decode(t,t.uint32())},c.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.values!=null&&t.hasOwnProperty("values")){var l=s.onnx.TensorProto.verify(t.values);if(l)return"values."+l}if(t.indices!=null&&t.hasOwnProperty("indices")){var l=s.onnx.TensorProto.verify(t.indices);if(l)return"indices."+l}if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var a=0;a<t.dims.length;++a)if(!n.isInteger(t.dims[a])&&!(t.dims[a]&&n.isInteger(t.dims[a].low)&&n.isInteger(t.dims[a].high)))return"dims: integer|Long[] expected"}return null},c.fromObject=function(t){if(t instanceof s.onnx.SparseTensorProto)return t;var l=new s.onnx.SparseTensorProto;if(t.values!=null){if(typeof t.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");l.values=s.onnx.TensorProto.fromObject(t.values)}if(t.indices!=null){if(typeof t.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");l.indices=s.onnx.TensorProto.fromObject(t.indices)}if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");l.dims=[];for(var a=0;a<t.dims.length;++a)n.Long?(l.dims[a]=n.Long.fromValue(t.dims[a])).unsigned=!1:typeof t.dims[a]=="string"?l.dims[a]=parseInt(t.dims[a],10):typeof t.dims[a]=="number"?l.dims[a]=t.dims[a]:typeof t.dims[a]=="object"&&(l.dims[a]=new n.LongBits(t.dims[a].low>>>0,t.dims[a].high>>>0).toNumber())}return l},c.toObject=function(t,l){l||(l={});var a={};if((l.arrays||l.defaults)&&(a.dims=[]),l.defaults&&(a.values=null,a.indices=null),t.values!=null&&t.hasOwnProperty("values")&&(a.values=s.onnx.TensorProto.toObject(t.values,l)),t.indices!=null&&t.hasOwnProperty("indices")&&(a.indices=s.onnx.TensorProto.toObject(t.indices,l)),t.dims&&t.dims.length){a.dims=[];for(var d=0;d<t.dims.length;++d)typeof t.dims[d]=="number"?a.dims[d]=l.longs===String?String(t.dims[d]):t.dims[d]:a.dims[d]=l.longs===String?n.Long.prototype.toString.call(t.dims[d]):l.longs===Number?new n.LongBits(t.dims[d].low>>>0,t.dims[d].high>>>0).toNumber():t.dims[d]}return a},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.SparseTensorProto"},c}(),p.TensorShapeProto=function(){function c(t){if(this.dim=[],t)for(var l=Object.keys(t),a=0;a<l.length;++a)t[l[a]]!=null&&(this[l[a]]=t[l[a]])}return c.prototype.dim=n.emptyArray,c.create=function(t){return new c(t)},c.encode=function(t,l){if(l||(l=u.create()),t.dim!=null&&t.dim.length)for(var a=0;a<t.dim.length;++a)s.onnx.TensorShapeProto.Dimension.encode(t.dim[a],l.uint32(10).fork()).ldelim();return l},c.encodeDelimited=function(t,l){return this.encode(t,l).ldelim()},c.decode=function(t,l){t instanceof o||(t=o.create(t));for(var a=l===void 0?t.len:t.pos+l,d=new s.onnx.TensorShapeProto;t.pos<a;){var h=t.uint32();switch(h>>>3){case 1:{d.dim&&d.dim.length||(d.dim=[]),d.dim.push(s.onnx.TensorShapeProto.Dimension.decode(t,t.uint32()));break}default:t.skipType(h&7);break}}return d},c.decodeDelimited=function(t){return t instanceof o||(t=new o(t)),this.decode(t,t.uint32())},c.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dim!=null&&t.hasOwnProperty("dim")){if(!Array.isArray(t.dim))return"dim: array expected";for(var l=0;l<t.dim.length;++l){var a=s.onnx.TensorShapeProto.Dimension.verify(t.dim[l]);if(a)return"dim."+a}}return null},c.fromObject=function(t){if(t instanceof s.onnx.TensorShapeProto)return t;var l=new s.onnx.TensorShapeProto;if(t.dim){if(!Array.isArray(t.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");l.dim=[];for(var a=0;a<t.dim.length;++a){if(typeof t.dim[a]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");l.dim[a]=s.onnx.TensorShapeProto.Dimension.fromObject(t.dim[a])}}return l},c.toObject=function(t,l){l||(l={});var a={};if((l.arrays||l.defaults)&&(a.dim=[]),t.dim&&t.dim.length){a.dim=[];for(var d=0;d<t.dim.length;++d)a.dim[d]=s.onnx.TensorShapeProto.Dimension.toObject(t.dim[d],l)}return a},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorShapeProto"},c.Dimension=function(){function t(a){if(a)for(var d=Object.keys(a),h=0;h<d.length;++h)a[d[h]]!=null&&(this[d[h]]=a[d[h]])}t.prototype.dimValue=null,t.prototype.dimParam=null,t.prototype.denotation="";var l;return Object.defineProperty(t.prototype,"value",{get:n.oneOfGetter(l=["dimValue","dimParam"]),set:n.oneOfSetter(l)}),t.create=function(a){return new t(a)},t.encode=function(a,d){return d||(d=u.create()),a.dimValue!=null&&Object.hasOwnProperty.call(a,"dimValue")&&d.uint32(8).int64(a.dimValue),a.dimParam!=null&&Object.hasOwnProperty.call(a,"dimParam")&&d.uint32(18).string(a.dimParam),a.denotation!=null&&Object.hasOwnProperty.call(a,"denotation")&&d.uint32(26).string(a.denotation),d},t.encodeDelimited=function(a,d){return this.encode(a,d).ldelim()},t.decode=function(a,d){a instanceof o||(a=o.create(a));for(var h=d===void 0?a.len:a.pos+d,f=new s.onnx.TensorShapeProto.Dimension;a.pos<h;){var g=a.uint32();switch(g>>>3){case 1:{f.dimValue=a.int64();break}case 2:{f.dimParam=a.string();break}case 3:{f.denotation=a.string();break}default:a.skipType(g&7);break}}return f},t.decodeDelimited=function(a){return a instanceof o||(a=new o(a)),this.decode(a,a.uint32())},t.verify=function(a){if(typeof a!="object"||a===null)return"object expected";var d={};if(a.dimValue!=null&&a.hasOwnProperty("dimValue")&&(d.value=1,!n.isInteger(a.dimValue)&&!(a.dimValue&&n.isInteger(a.dimValue.low)&&n.isInteger(a.dimValue.high))))return"dimValue: integer|Long expected";if(a.dimParam!=null&&a.hasOwnProperty("dimParam")){if(d.value===1)return"value: multiple values";if(d.value=1,!n.isString(a.dimParam))return"dimParam: string expected"}return a.denotation!=null&&a.hasOwnProperty("denotation")&&!n.isString(a.denotation)?"denotation: string expected":null},t.fromObject=function(a){if(a instanceof s.onnx.TensorShapeProto.Dimension)return a;var d=new s.onnx.TensorShapeProto.Dimension;return a.dimValue!=null&&(n.Long?(d.dimValue=n.Long.fromValue(a.dimValue)).unsigned=!1:typeof a.dimValue=="string"?d.dimValue=parseInt(a.dimValue,10):typeof a.dimValue=="number"?d.dimValue=a.dimValue:typeof a.dimValue=="object"&&(d.dimValue=new n.LongBits(a.dimValue.low>>>0,a.dimValue.high>>>0).toNumber())),a.dimParam!=null&&(d.dimParam=String(a.dimParam)),a.denotation!=null&&(d.denotation=String(a.denotation)),d},t.toObject=function(a,d){d||(d={});var h={};return d.defaults&&(h.denotation=""),a.dimValue!=null&&a.hasOwnProperty("dimValue")&&(typeof a.dimValue=="number"?h.dimValue=d.longs===String?String(a.dimValue):a.dimValue:h.dimValue=d.longs===String?n.Long.prototype.toString.call(a.dimValue):d.longs===Number?new n.LongBits(a.dimValue.low>>>0,a.dimValue.high>>>0).toNumber():a.dimValue,d.oneofs&&(h.value="dimValue")),a.dimParam!=null&&a.hasOwnProperty("dimParam")&&(h.dimParam=a.dimParam,d.oneofs&&(h.value="dimParam")),a.denotation!=null&&a.hasOwnProperty("denotation")&&(h.denotation=a.denotation),h},t.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},t.getTypeUrl=function(a){return a===void 0&&(a="type.googleapis.com"),a+"/onnx.TensorShapeProto.Dimension"},t}(),c}(),p.TypeProto=function(){function c(l){if(l)for(var a=Object.keys(l),d=0;d<a.length;++d)l[a[d]]!=null&&(this[a[d]]=l[a[d]])}c.prototype.tensorType=null,c.prototype.sequenceType=null,c.prototype.mapType=null,c.prototype.optionalType=null,c.prototype.sparseTensorType=null,c.prototype.denotation="";var t;return Object.defineProperty(c.prototype,"value",{get:n.oneOfGetter(t=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:n.oneOfSetter(t)}),c.create=function(l){return new c(l)},c.encode=function(l,a){return a||(a=u.create()),l.tensorType!=null&&Object.hasOwnProperty.call(l,"tensorType")&&s.onnx.TypeProto.Tensor.encode(l.tensorType,a.uint32(10).fork()).ldelim(),l.sequenceType!=null&&Object.hasOwnProperty.call(l,"sequenceType")&&s.onnx.TypeProto.Sequence.encode(l.sequenceType,a.uint32(34).fork()).ldelim(),l.mapType!=null&&Object.hasOwnProperty.call(l,"mapType")&&s.onnx.TypeProto.Map.encode(l.mapType,a.uint32(42).fork()).ldelim(),l.denotation!=null&&Object.hasOwnProperty.call(l,"denotation")&&a.uint32(50).string(l.denotation),l.sparseTensorType!=null&&Object.hasOwnProperty.call(l,"sparseTensorType")&&s.onnx.TypeProto.SparseTensor.encode(l.sparseTensorType,a.uint32(66).fork()).ldelim(),l.optionalType!=null&&Object.hasOwnProperty.call(l,"optionalType")&&s.onnx.TypeProto.Optional.encode(l.optionalType,a.uint32(74).fork()).ldelim(),a},c.encodeDelimited=function(l,a){return this.encode(l,a).ldelim()},c.decode=function(l,a){l instanceof o||(l=o.create(l));for(var d=a===void 0?l.len:l.pos+a,h=new s.onnx.TypeProto;l.pos<d;){var f=l.uint32();switch(f>>>3){case 1:{h.tensorType=s.onnx.TypeProto.Tensor.decode(l,l.uint32());break}case 4:{h.sequenceType=s.onnx.TypeProto.Sequence.decode(l,l.uint32());break}case 5:{h.mapType=s.onnx.TypeProto.Map.decode(l,l.uint32());break}case 9:{h.optionalType=s.onnx.TypeProto.Optional.decode(l,l.uint32());break}case 8:{h.sparseTensorType=s.onnx.TypeProto.SparseTensor.decode(l,l.uint32());break}case 6:{h.denotation=l.string();break}default:l.skipType(f&7);break}}return h},c.decodeDelimited=function(l){return l instanceof o||(l=new o(l)),this.decode(l,l.uint32())},c.verify=function(l){if(typeof l!="object"||l===null)return"object expected";var a={};if(l.tensorType!=null&&l.hasOwnProperty("tensorType")){a.value=1;{var d=s.onnx.TypeProto.Tensor.verify(l.tensorType);if(d)return"tensorType."+d}}if(l.sequenceType!=null&&l.hasOwnProperty("sequenceType")){if(a.value===1)return"value: multiple values";a.value=1;{var d=s.onnx.TypeProto.Sequence.verify(l.sequenceType);if(d)return"sequenceType."+d}}if(l.mapType!=null&&l.hasOwnProperty("mapType")){if(a.value===1)return"value: multiple values";a.value=1;{var d=s.onnx.TypeProto.Map.verify(l.mapType);if(d)return"mapType."+d}}if(l.optionalType!=null&&l.hasOwnProperty("optionalType")){if(a.value===1)return"value: multiple values";a.value=1;{var d=s.onnx.TypeProto.Optional.verify(l.optionalType);if(d)return"optionalType."+d}}if(l.sparseTensorType!=null&&l.hasOwnProperty("sparseTensorType")){if(a.value===1)return"value: multiple values";a.value=1;{var d=s.onnx.TypeProto.SparseTensor.verify(l.sparseTensorType);if(d)return"sparseTensorType."+d}}return l.denotation!=null&&l.hasOwnProperty("denotation")&&!n.isString(l.denotation)?"denotation: string expected":null},c.fromObject=function(l){if(l instanceof s.onnx.TypeProto)return l;var a=new s.onnx.TypeProto;if(l.tensorType!=null){if(typeof l.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");a.tensorType=s.onnx.TypeProto.Tensor.fromObject(l.tensorType)}if(l.sequenceType!=null){if(typeof l.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");a.sequenceType=s.onnx.TypeProto.Sequence.fromObject(l.sequenceType)}if(l.mapType!=null){if(typeof l.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");a.mapType=s.onnx.TypeProto.Map.fromObject(l.mapType)}if(l.optionalType!=null){if(typeof l.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");a.optionalType=s.onnx.TypeProto.Optional.fromObject(l.optionalType)}if(l.sparseTensorType!=null){if(typeof l.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");a.sparseTensorType=s.onnx.TypeProto.SparseTensor.fromObject(l.sparseTensorType)}return l.denotation!=null&&(a.denotation=String(l.denotation)),a},c.toObject=function(l,a){a||(a={});var d={};return a.defaults&&(d.denotation=""),l.tensorType!=null&&l.hasOwnProperty("tensorType")&&(d.tensorType=s.onnx.TypeProto.Tensor.toObject(l.tensorType,a),a.oneofs&&(d.value="tensorType")),l.sequenceType!=null&&l.hasOwnProperty("sequenceType")&&(d.sequenceType=s.onnx.TypeProto.Sequence.toObject(l.sequenceType,a),a.oneofs&&(d.value="sequenceType")),l.mapType!=null&&l.hasOwnProperty("mapType")&&(d.mapType=s.onnx.TypeProto.Map.toObject(l.mapType,a),a.oneofs&&(d.value="mapType")),l.denotation!=null&&l.hasOwnProperty("denotation")&&(d.denotation=l.denotation),l.sparseTensorType!=null&&l.hasOwnProperty("sparseTensorType")&&(d.sparseTensorType=s.onnx.TypeProto.SparseTensor.toObject(l.sparseTensorType,a),a.oneofs&&(d.value="sparseTensorType")),l.optionalType!=null&&l.hasOwnProperty("optionalType")&&(d.optionalType=s.onnx.TypeProto.Optional.toObject(l.optionalType,a),a.oneofs&&(d.value="optionalType")),d},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TypeProto"},c.Tensor=function(){function l(a){if(a)for(var d=Object.keys(a),h=0;h<d.length;++h)a[d[h]]!=null&&(this[d[h]]=a[d[h]])}return l.prototype.elemType=0,l.prototype.shape=null,l.create=function(a){return new l(a)},l.encode=function(a,d){return d||(d=u.create()),a.elemType!=null&&Object.hasOwnProperty.call(a,"elemType")&&d.uint32(8).int32(a.elemType),a.shape!=null&&Object.hasOwnProperty.call(a,"shape")&&s.onnx.TensorShapeProto.encode(a.shape,d.uint32(18).fork()).ldelim(),d},l.encodeDelimited=function(a,d){return this.encode(a,d).ldelim()},l.decode=function(a,d){a instanceof o||(a=o.create(a));for(var h=d===void 0?a.len:a.pos+d,f=new s.onnx.TypeProto.Tensor;a.pos<h;){var g=a.uint32();switch(g>>>3){case 1:{f.elemType=a.int32();break}case 2:{f.shape=s.onnx.TensorShapeProto.decode(a,a.uint32());break}default:a.skipType(g&7);break}}return f},l.decodeDelimited=function(a){return a instanceof o||(a=new o(a)),this.decode(a,a.uint32())},l.verify=function(a){if(typeof a!="object"||a===null)return"object expected";if(a.elemType!=null&&a.hasOwnProperty("elemType")&&!n.isInteger(a.elemType))return"elemType: integer expected";if(a.shape!=null&&a.hasOwnProperty("shape")){var d=s.onnx.TensorShapeProto.verify(a.shape);if(d)return"shape."+d}return null},l.fromObject=function(a){if(a instanceof s.onnx.TypeProto.Tensor)return a;var d=new s.onnx.TypeProto.Tensor;if(a.elemType!=null&&(d.elemType=a.elemType|0),a.shape!=null){if(typeof a.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");d.shape=s.onnx.TensorShapeProto.fromObject(a.shape)}return d},l.toObject=function(a,d){d||(d={});var h={};return d.defaults&&(h.elemType=0,h.shape=null),a.elemType!=null&&a.hasOwnProperty("elemType")&&(h.elemType=a.elemType),a.shape!=null&&a.hasOwnProperty("shape")&&(h.shape=s.onnx.TensorShapeProto.toObject(a.shape,d)),h},l.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},l.getTypeUrl=function(a){return a===void 0&&(a="type.googleapis.com"),a+"/onnx.TypeProto.Tensor"},l}(),c.Sequence=function(){function l(a){if(a)for(var d=Object.keys(a),h=0;h<d.length;++h)a[d[h]]!=null&&(this[d[h]]=a[d[h]])}return l.prototype.elemType=null,l.create=function(a){return new l(a)},l.encode=function(a,d){return d||(d=u.create()),a.elemType!=null&&Object.hasOwnProperty.call(a,"elemType")&&s.onnx.TypeProto.encode(a.elemType,d.uint32(10).fork()).ldelim(),d},l.encodeDelimited=function(a,d){return this.encode(a,d).ldelim()},l.decode=function(a,d){a instanceof o||(a=o.create(a));for(var h=d===void 0?a.len:a.pos+d,f=new s.onnx.TypeProto.Sequence;a.pos<h;){var g=a.uint32();switch(g>>>3){case 1:{f.elemType=s.onnx.TypeProto.decode(a,a.uint32());break}default:a.skipType(g&7);break}}return f},l.decodeDelimited=function(a){return a instanceof o||(a=new o(a)),this.decode(a,a.uint32())},l.verify=function(a){if(typeof a!="object"||a===null)return"object expected";if(a.elemType!=null&&a.hasOwnProperty("elemType")){var d=s.onnx.TypeProto.verify(a.elemType);if(d)return"elemType."+d}return null},l.fromObject=function(a){if(a instanceof s.onnx.TypeProto.Sequence)return a;var d=new s.onnx.TypeProto.Sequence;if(a.elemType!=null){if(typeof a.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");d.elemType=s.onnx.TypeProto.fromObject(a.elemType)}return d},l.toObject=function(a,d){d||(d={});var h={};return d.defaults&&(h.elemType=null),a.elemType!=null&&a.hasOwnProperty("elemType")&&(h.elemType=s.onnx.TypeProto.toObject(a.elemType,d)),h},l.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},l.getTypeUrl=function(a){return a===void 0&&(a="type.googleapis.com"),a+"/onnx.TypeProto.Sequence"},l}(),c.Map=function(){function l(a){if(a)for(var d=Object.keys(a),h=0;h<d.length;++h)a[d[h]]!=null&&(this[d[h]]=a[d[h]])}return l.prototype.keyType=0,l.prototype.valueType=null,l.create=function(a){return new l(a)},l.encode=function(a,d){return d||(d=u.create()),a.keyType!=null&&Object.hasOwnProperty.call(a,"keyType")&&d.uint32(8).int32(a.keyType),a.valueType!=null&&Object.hasOwnProperty.call(a,"valueType")&&s.onnx.TypeProto.encode(a.valueType,d.uint32(18).fork()).ldelim(),d},l.encodeDelimited=function(a,d){return this.encode(a,d).ldelim()},l.decode=function(a,d){a instanceof o||(a=o.create(a));for(var h=d===void 0?a.len:a.pos+d,f=new s.onnx.TypeProto.Map;a.pos<h;){var g=a.uint32();switch(g>>>3){case 1:{f.keyType=a.int32();break}case 2:{f.valueType=s.onnx.TypeProto.decode(a,a.uint32());break}default:a.skipType(g&7);break}}return f},l.decodeDelimited=function(a){return a instanceof o||(a=new o(a)),this.decode(a,a.uint32())},l.verify=function(a){if(typeof a!="object"||a===null)return"object expected";if(a.keyType!=null&&a.hasOwnProperty("keyType")&&!n.isInteger(a.keyType))return"keyType: integer expected";if(a.valueType!=null&&a.hasOwnProperty("valueType")){var d=s.onnx.TypeProto.verify(a.valueType);if(d)return"valueType."+d}return null},l.fromObject=function(a){if(a instanceof s.onnx.TypeProto.Map)return a;var d=new s.onnx.TypeProto.Map;if(a.keyType!=null&&(d.keyType=a.keyType|0),a.valueType!=null){if(typeof a.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");d.valueType=s.onnx.TypeProto.fromObject(a.valueType)}return d},l.toObject=function(a,d){d||(d={});var h={};return d.defaults&&(h.keyType=0,h.valueType=null),a.keyType!=null&&a.hasOwnProperty("keyType")&&(h.keyType=a.keyType),a.valueType!=null&&a.hasOwnProperty("valueType")&&(h.valueType=s.onnx.TypeProto.toObject(a.valueType,d)),h},l.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},l.getTypeUrl=function(a){return a===void 0&&(a="type.googleapis.com"),a+"/onnx.TypeProto.Map"},l}(),c.Optional=function(){function l(a){if(a)for(var d=Object.keys(a),h=0;h<d.length;++h)a[d[h]]!=null&&(this[d[h]]=a[d[h]])}return l.prototype.elemType=null,l.create=function(a){return new l(a)},l.encode=function(a,d){return d||(d=u.create()),a.elemType!=null&&Object.hasOwnProperty.call(a,"elemType")&&s.onnx.TypeProto.encode(a.elemType,d.uint32(10).fork()).ldelim(),d},l.encodeDelimited=function(a,d){return this.encode(a,d).ldelim()},l.decode=function(a,d){a instanceof o||(a=o.create(a));for(var h=d===void 0?a.len:a.pos+d,f=new s.onnx.TypeProto.Optional;a.pos<h;){var g=a.uint32();switch(g>>>3){case 1:{f.elemType=s.onnx.TypeProto.decode(a,a.uint32());break}default:a.skipType(g&7);break}}return f},l.decodeDelimited=function(a){return a instanceof o||(a=new o(a)),this.decode(a,a.uint32())},l.verify=function(a){if(typeof a!="object"||a===null)return"object expected";if(a.elemType!=null&&a.hasOwnProperty("elemType")){var d=s.onnx.TypeProto.verify(a.elemType);if(d)return"elemType."+d}return null},l.fromObject=function(a){if(a instanceof s.onnx.TypeProto.Optional)return a;var d=new s.onnx.TypeProto.Optional;if(a.elemType!=null){if(typeof a.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");d.elemType=s.onnx.TypeProto.fromObject(a.elemType)}return d},l.toObject=function(a,d){d||(d={});var h={};return d.defaults&&(h.elemType=null),a.elemType!=null&&a.hasOwnProperty("elemType")&&(h.elemType=s.onnx.TypeProto.toObject(a.elemType,d)),h},l.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},l.getTypeUrl=function(a){return a===void 0&&(a="type.googleapis.com"),a+"/onnx.TypeProto.Optional"},l}(),c.SparseTensor=function(){function l(a){if(a)for(var d=Object.keys(a),h=0;h<d.length;++h)a[d[h]]!=null&&(this[d[h]]=a[d[h]])}return l.prototype.elemType=0,l.prototype.shape=null,l.create=function(a){return new l(a)},l.encode=function(a,d){return d||(d=u.create()),a.elemType!=null&&Object.hasOwnProperty.call(a,"elemType")&&d.uint32(8).int32(a.elemType),a.shape!=null&&Object.hasOwnProperty.call(a,"shape")&&s.onnx.TensorShapeProto.encode(a.shape,d.uint32(18).fork()).ldelim(),d},l.encodeDelimited=function(a,d){return this.encode(a,d).ldelim()},l.decode=function(a,d){a instanceof o||(a=o.create(a));for(var h=d===void 0?a.len:a.pos+d,f=new s.onnx.TypeProto.SparseTensor;a.pos<h;){var g=a.uint32();switch(g>>>3){case 1:{f.elemType=a.int32();break}case 2:{f.shape=s.onnx.TensorShapeProto.decode(a,a.uint32());break}default:a.skipType(g&7);break}}return f},l.decodeDelimited=function(a){return a instanceof o||(a=new o(a)),this.decode(a,a.uint32())},l.verify=function(a){if(typeof a!="object"||a===null)return"object expected";if(a.elemType!=null&&a.hasOwnProperty("elemType")&&!n.isInteger(a.elemType))return"elemType: integer expected";if(a.shape!=null&&a.hasOwnProperty("shape")){var d=s.onnx.TensorShapeProto.verify(a.shape);if(d)return"shape."+d}return null},l.fromObject=function(a){if(a instanceof s.onnx.TypeProto.SparseTensor)return a;var d=new s.onnx.TypeProto.SparseTensor;if(a.elemType!=null&&(d.elemType=a.elemType|0),a.shape!=null){if(typeof a.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");d.shape=s.onnx.TensorShapeProto.fromObject(a.shape)}return d},l.toObject=function(a,d){d||(d={});var h={};return d.defaults&&(h.elemType=0,h.shape=null),a.elemType!=null&&a.hasOwnProperty("elemType")&&(h.elemType=a.elemType),a.shape!=null&&a.hasOwnProperty("shape")&&(h.shape=s.onnx.TensorShapeProto.toObject(a.shape,d)),h},l.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},l.getTypeUrl=function(a){return a===void 0&&(a="type.googleapis.com"),a+"/onnx.TypeProto.SparseTensor"},l}(),c}(),p.OperatorSetIdProto=function(){function c(t){if(t)for(var l=Object.keys(t),a=0;a<l.length;++a)t[l[a]]!=null&&(this[l[a]]=t[l[a]])}return c.prototype.domain="",c.prototype.version=n.Long?n.Long.fromBits(0,0,!1):0,c.create=function(t){return new c(t)},c.encode=function(t,l){return l||(l=u.create()),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&l.uint32(10).string(t.domain),t.version!=null&&Object.hasOwnProperty.call(t,"version")&&l.uint32(16).int64(t.version),l},c.encodeDelimited=function(t,l){return this.encode(t,l).ldelim()},c.decode=function(t,l){t instanceof o||(t=o.create(t));for(var a=l===void 0?t.len:t.pos+l,d=new s.onnx.OperatorSetIdProto;t.pos<a;){var h=t.uint32();switch(h>>>3){case 1:{d.domain=t.string();break}case 2:{d.version=t.int64();break}default:t.skipType(h&7);break}}return d},c.decodeDelimited=function(t){return t instanceof o||(t=new o(t)),this.decode(t,t.uint32())},c.verify=function(t){return typeof t!="object"||t===null?"object expected":t.domain!=null&&t.hasOwnProperty("domain")&&!n.isString(t.domain)?"domain: string expected":t.version!=null&&t.hasOwnProperty("version")&&!n.isInteger(t.version)&&!(t.version&&n.isInteger(t.version.low)&&n.isInteger(t.version.high))?"version: integer|Long expected":null},c.fromObject=function(t){if(t instanceof s.onnx.OperatorSetIdProto)return t;var l=new s.onnx.OperatorSetIdProto;return t.domain!=null&&(l.domain=String(t.domain)),t.version!=null&&(n.Long?(l.version=n.Long.fromValue(t.version)).unsigned=!1:typeof t.version=="string"?l.version=parseInt(t.version,10):typeof t.version=="number"?l.version=t.version:typeof t.version=="object"&&(l.version=new n.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber())),l},c.toObject=function(t,l){l||(l={});var a={};if(l.defaults)if(a.domain="",n.Long){var d=new n.Long(0,0,!1);a.version=l.longs===String?d.toString():l.longs===Number?d.toNumber():d}else a.version=l.longs===String?"0":0;return t.domain!=null&&t.hasOwnProperty("domain")&&(a.domain=t.domain),t.version!=null&&t.hasOwnProperty("version")&&(typeof t.version=="number"?a.version=l.longs===String?String(t.version):t.version:a.version=l.longs===String?n.Long.prototype.toString.call(t.version):l.longs===Number?new n.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber():t.version),a},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.OperatorSetIdProto"},c}(),p.OperatorStatus=function(){var c={},t=Object.create(c);return t[c[0]="EXPERIMENTAL"]=0,t[c[1]="STABLE"]=1,t}(),p.FunctionProto=function(){function c(t){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],t)for(var l=Object.keys(t),a=0;a<l.length;++a)t[l[a]]!=null&&(this[l[a]]=t[l[a]])}return c.prototype.name="",c.prototype.input=n.emptyArray,c.prototype.output=n.emptyArray,c.prototype.attribute=n.emptyArray,c.prototype.attributeProto=n.emptyArray,c.prototype.node=n.emptyArray,c.prototype.docString="",c.prototype.opsetImport=n.emptyArray,c.prototype.domain="",c.create=function(t){return new c(t)},c.encode=function(t,l){if(l||(l=u.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&l.uint32(10).string(t.name),t.input!=null&&t.input.length)for(var a=0;a<t.input.length;++a)l.uint32(34).string(t.input[a]);if(t.output!=null&&t.output.length)for(var a=0;a<t.output.length;++a)l.uint32(42).string(t.output[a]);if(t.attribute!=null&&t.attribute.length)for(var a=0;a<t.attribute.length;++a)l.uint32(50).string(t.attribute[a]);if(t.node!=null&&t.node.length)for(var a=0;a<t.node.length;++a)s.onnx.NodeProto.encode(t.node[a],l.uint32(58).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&l.uint32(66).string(t.docString),t.opsetImport!=null&&t.opsetImport.length)for(var a=0;a<t.opsetImport.length;++a)s.onnx.OperatorSetIdProto.encode(t.opsetImport[a],l.uint32(74).fork()).ldelim();if(t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&l.uint32(82).string(t.domain),t.attributeProto!=null&&t.attributeProto.length)for(var a=0;a<t.attributeProto.length;++a)s.onnx.AttributeProto.encode(t.attributeProto[a],l.uint32(90).fork()).ldelim();return l},c.encodeDelimited=function(t,l){return this.encode(t,l).ldelim()},c.decode=function(t,l){t instanceof o||(t=o.create(t));for(var a=l===void 0?t.len:t.pos+l,d=new s.onnx.FunctionProto;t.pos<a;){var h=t.uint32();switch(h>>>3){case 1:{d.name=t.string();break}case 4:{d.input&&d.input.length||(d.input=[]),d.input.push(t.string());break}case 5:{d.output&&d.output.length||(d.output=[]),d.output.push(t.string());break}case 6:{d.attribute&&d.attribute.length||(d.attribute=[]),d.attribute.push(t.string());break}case 11:{d.attributeProto&&d.attributeProto.length||(d.attributeProto=[]),d.attributeProto.push(s.onnx.AttributeProto.decode(t,t.uint32()));break}case 7:{d.node&&d.node.length||(d.node=[]),d.node.push(s.onnx.NodeProto.decode(t,t.uint32()));break}case 8:{d.docString=t.string();break}case 9:{d.opsetImport&&d.opsetImport.length||(d.opsetImport=[]),d.opsetImport.push(s.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 10:{d.domain=t.string();break}default:t.skipType(h&7);break}}return d},c.decodeDelimited=function(t){return t instanceof o||(t=new o(t)),this.decode(t,t.uint32())},c.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!n.isString(t.name))return"name: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var l=0;l<t.input.length;++l)if(!n.isString(t.input[l]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var l=0;l<t.output.length;++l)if(!n.isString(t.output[l]))return"output: string[] expected"}if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var l=0;l<t.attribute.length;++l)if(!n.isString(t.attribute[l]))return"attribute: string[] expected"}if(t.attributeProto!=null&&t.hasOwnProperty("attributeProto")){if(!Array.isArray(t.attributeProto))return"attributeProto: array expected";for(var l=0;l<t.attributeProto.length;++l){var a=s.onnx.AttributeProto.verify(t.attributeProto[l]);if(a)return"attributeProto."+a}}if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var l=0;l<t.node.length;++l){var a=s.onnx.NodeProto.verify(t.node[l]);if(a)return"node."+a}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!n.isString(t.docString))return"docString: string expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var l=0;l<t.opsetImport.length;++l){var a=s.onnx.OperatorSetIdProto.verify(t.opsetImport[l]);if(a)return"opsetImport."+a}}return t.domain!=null&&t.hasOwnProperty("domain")&&!n.isString(t.domain)?"domain: string expected":null},c.fromObject=function(t){if(t instanceof s.onnx.FunctionProto)return t;var l=new s.onnx.FunctionProto;if(t.name!=null&&(l.name=String(t.name)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.FunctionProto.input: array expected");l.input=[];for(var a=0;a<t.input.length;++a)l.input[a]=String(t.input[a])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.FunctionProto.output: array expected");l.output=[];for(var a=0;a<t.output.length;++a)l.output[a]=String(t.output[a])}if(t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");l.attribute=[];for(var a=0;a<t.attribute.length;++a)l.attribute[a]=String(t.attribute[a])}if(t.attributeProto){if(!Array.isArray(t.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");l.attributeProto=[];for(var a=0;a<t.attributeProto.length;++a){if(typeof t.attributeProto[a]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");l.attributeProto[a]=s.onnx.AttributeProto.fromObject(t.attributeProto[a])}}if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.FunctionProto.node: array expected");l.node=[];for(var a=0;a<t.node.length;++a){if(typeof t.node[a]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");l.node[a]=s.onnx.NodeProto.fromObject(t.node[a])}}if(t.docString!=null&&(l.docString=String(t.docString)),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");l.opsetImport=[];for(var a=0;a<t.opsetImport.length;++a){if(typeof t.opsetImport[a]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");l.opsetImport[a]=s.onnx.OperatorSetIdProto.fromObject(t.opsetImport[a])}}return t.domain!=null&&(l.domain=String(t.domain)),l},c.toObject=function(t,l){l||(l={});var a={};if((l.arrays||l.defaults)&&(a.input=[],a.output=[],a.attribute=[],a.node=[],a.opsetImport=[],a.attributeProto=[]),l.defaults&&(a.name="",a.docString="",a.domain=""),t.name!=null&&t.hasOwnProperty("name")&&(a.name=t.name),t.input&&t.input.length){a.input=[];for(var d=0;d<t.input.length;++d)a.input[d]=t.input[d]}if(t.output&&t.output.length){a.output=[];for(var d=0;d<t.output.length;++d)a.output[d]=t.output[d]}if(t.attribute&&t.attribute.length){a.attribute=[];for(var d=0;d<t.attribute.length;++d)a.attribute[d]=t.attribute[d]}if(t.node&&t.node.length){a.node=[];for(var d=0;d<t.node.length;++d)a.node[d]=s.onnx.NodeProto.toObject(t.node[d],l)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(a.docString=t.docString),t.opsetImport&&t.opsetImport.length){a.opsetImport=[];for(var d=0;d<t.opsetImport.length;++d)a.opsetImport[d]=s.onnx.OperatorSetIdProto.toObject(t.opsetImport[d],l)}if(t.domain!=null&&t.hasOwnProperty("domain")&&(a.domain=t.domain),t.attributeProto&&t.attributeProto.length){a.attributeProto=[];for(var d=0;d<t.attributeProto.length;++d)a.attributeProto[d]=s.onnx.AttributeProto.toObject(t.attributeProto[d],l)}return a},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.FunctionProto"},c}(),p}(),r.exports=s});function Pe(e,r){if(!e)throw new Error(typeof r=="string"?r:r())}function Ze(e){return new TextDecoder().decode(e)}var j,fe,to,ct,kr,st,bt,A,Je,ce,pe,de,U=x(()=>{Pr(),Mn(),j=Ie(Ae()),he(),fe=class{static arraysEqual(e,r){if(e.length!==r.length)return!1;for(let i=0;i<e.length;i++)if(e[i]!==r[i])return!1;return!0}},to=class{static preprocessInputShapes(e,r){let i=e.length===1?[1,e[0]]:e,o=r.length===1?[r[0],1]:r;return[i,o]}static postprocessOutputShape(e,r,i){r===1&&e.splice(e.length-2,1),i===1&&e.pop()}static calcMatMulShape(e,r){return e[1]!==r[0]?void 0:[e[0],r[1]]}},ct=class ue{static calcShape(r,i,o=!1){let u=r.length,n=i.length;if(u===0)return i;if(n===0)return r;let s=Math.max(r.length,i.length),p=new Array(s);if(o){if(u<2||n<2)return;let c=to.calcMatMulShape([r[u-2],r[u-1]],[i[n-2],i[n-1]]);if(c===void 0)return;[p[s-2],p[s-1]]=c}for(let c=o?3:1;c<=s;c++){let t=u-c<0?1:r[u-c],l=n-c<0?1:i[n-c];if(t!==l&&t>1&&l>1)return;p[s-c]=Math.max(t,l)}return p}static index(r,i){let o=new Array(i.length);return ue.fillIndex(r,i,o),o}static fillIndex(r,i,o){let u=r.length-i.length;for(let n=0;n<i.length;n++)o[n]=r[u+n]%i[n]}static calc(r,i,o,u,n){let s=ue.calcShape(r.dims,i.dims);if(s){if(u&&!A.areEqual(s,r.dims))return;let p=A.size(s),c=u?r:new et(s,n||r.type);if(s.length===0)c.set([],o(r.get([]),i.get([])));else{let t=new Array(s.length),l=new Array(r.dims.length),a=new Array(i.dims.length),d=0,h=0,f=!1,g=!1;r.dims.length===0&&(d=r.get([]),f=!0),i.dims.length===0&&(h=i.get([]),g=!0);let y;for(let w=0;w<p;w++){y=w;for(let m=s.length-1;m>=0;m--)t[m]=y%s[m],y=Math.floor(y/s[m]);f||(ue.fillIndex(t,r.dims,l),d=r.get(l)),g||(ue.fillIndex(t,i.dims,a),h=i.get(a)),c.set(t,o(d,h))}}return c}}static isValidBroadcast(r,i){let o=r.length,u=i.length;if(o>u)return!1;for(let n=1;n<=o;n++)if(r[o-n]!==1&&r[o-n]!==i[u-n])return!1;return!0}static getBroadcastDims(r,i){let o=r.length,u=[];for(let n=0;n<o;n++){let s=o-1-n,p=r[s]||1;(i[i.length-1-n]||1)>1&&p===1&&u.unshift(s)}return u}},kr=class{static getShapeOfGemmResult(e,r,i,o,u){if(e.length!==2||i.length!==2)throw new Error("shape need to be of size 2");let n,s,p;r?(n=e[1],s=e[0]):(n=e[0],s=e[1]);let c=-1;if(o?(p=i[0],c=1):(p=i[1],c=0),i[c]!==s)throw new Error("dimension mismatch");if(n<=0||p<=0||s<=0)throw new Error("invalid shape specified");if(u&&!ct.isValidBroadcast(u,[n,p]))throw new Error("gemm: invalid bias shape for broadcast");return[n,p,s]}},st=class Ge{static tensorDataTypeFromProto(r){switch(r){case j.onnx.TensorProto.DataType.INT8:return"int8";case j.onnx.TensorProto.DataType.UINT8:return"uint8";case j.onnx.TensorProto.DataType.BOOL:return"bool";case j.onnx.TensorProto.DataType.INT16:return"int16";case j.onnx.TensorProto.DataType.UINT16:return"uint16";case j.onnx.TensorProto.DataType.INT32:return"int32";case j.onnx.TensorProto.DataType.UINT32:return"uint32";case j.onnx.TensorProto.DataType.FLOAT:return"float32";case j.onnx.TensorProto.DataType.DOUBLE:return"float64";case j.onnx.TensorProto.DataType.STRING:return"string";case j.onnx.TensorProto.DataType.INT64:return"int32";case j.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${j.onnx.TensorProto.DataType[r]}`)}}static tensorDataTypeStringToEnum(r){switch(r){case"int8":return j.onnx.TensorProto.DataType.INT8;case"uint8":return j.onnx.TensorProto.DataType.UINT8;case"bool":return j.onnx.TensorProto.DataType.BOOL;case"int16":return j.onnx.TensorProto.DataType.INT16;case"uint16":return j.onnx.TensorProto.DataType.UINT16;case"int32":return j.onnx.TensorProto.DataType.INT32;case"uint32":return j.onnx.TensorProto.DataType.UINT32;case"float32":return j.onnx.TensorProto.DataType.FLOAT;case"float64":return j.onnx.TensorProto.DataType.DOUBLE;case"string":return j.onnx.TensorProto.DataType.STRING;case"int64":return j.onnx.TensorProto.DataType.INT64;case"uint64":return j.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${r}`)}}static tensorDimsFromProto(r){return r.map(i=>jt.isLong(i)?i.toNumber():i)}static tensorValueTypeFromProto(r){return{tensorType:Ge.tensorDataTypeFromProto(r.elemType),shape:{dims:Ge.tensorDimsFromProto(r.shape.dim.map(i=>i.dimValue))}}}static tensorDimsFromORTFormat(r){let i=[];for(let o=0;o<r.dimsLength();o++)i.push(bt.longToNumber(r.dims(o)));return i}static tensorAttributesFromORTFormat(r){let i=[];for(let o=0;o<r.attributesLength();o++)i.push(r.attributes(o));return i}},bt=class{static longToNumber(e,r){return jt.isLong(e)?e.toNumber():e instanceof b.Long?jt.fromValue({low:e.low,high:e.high,unsigned:r??!1}).toNumber():e}static isLong(e){return jt.isLong(e)||e instanceof b.Long}},A=class q{static size(r){return q.getSizeFromDimensionRange(r,0,r.length)}static sizeFromDimension(r,i){if(i<0||i>r.length)throw new Error(`invalid dimension of ${i} for sizeFromDimension as Tensor has ${r.length} dimensions.`);return q.getSizeFromDimensionRange(r,i,r.length)}static sizeToDimension(r,i){if(i<0||i>r.length)throw new Error(`invalid dimension of ${i} for sizeToDimension as Tensor has ${r.length} dimensions.`);return q.getSizeFromDimensionRange(r,0,i)}static getSizeFromDimensionRange(r,i,o){let u=1;for(let n=i;n<o;n++){if(r[n]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");u*=r[n]}return u}static computeStrides(r){let i=r.length;if(i===0)return[];if(i===1)return[1];let o=new Array(i);o[i-1]=1,o[i-2]=r[i-1];for(let u=i-3;u>=0;--u)o[u]=o[u+1]*r[u+1];return o}static transpose(r){return r.slice().reverse()}static indicesToOffset(r,i,o){o===void 0&&(o=r.length);let u=0;for(let n=0;n<o;++n)u+=i[n]*r[n];return u}static offsetToIndices(r,i){let o=i.length;if(o===0)return[];if(o===1)return[r*i[0]];let u=new Array(i.length);for(let n=0;n<u.length-1;++n)u[n]=Math.floor(r/i[n]),r-=u[n]*i[n];return u[u.length-1]=r,u}static normalizeAxis(r,i){if(r<-i&&r>=i)throw new Error("unsupported axis for this operation.");return r<0?r+i:r}static normalizeAxes(r,i){return r.map(o=>this.normalizeAxis(o,i))}static incrementIndex(r,i,o){if(i.length===0||r.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(o===void 0)o=i.length;else if(o<=0||o>i.length)throw new Error("Incorrect axis to increment on");for(let u=o-1;u>=0&&(r[u]++,!(r[u]<i[u]));--u)r[u]=0}static calculateReshapedDims(r,i){if(i.length===0){if(r.length===0||q.size(r)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let o=i.length,u=new Array(o),n=-1,s=1;for(let c=0;c<o;c++){if(i[c]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(i[c]===-1){if(n!==-1)throw new Error("at most one dimension in shape hints can be -1");n=c}else{if(i[c]===0){if(c>=r.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");u[c]=r[c]}else u[c]=i[c];s*=u[c]}}let p=q.size(r);if(n!==-1){if(p%s!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${r}] Output shape: [${i}]`);u[n]=p/s}else if(s!==p)throw new Error("reshapedDims and originalDims don't have matching sizes");return u}static sortBasedOnPerm(r,i){return i?i.map(o=>r[o]):r.slice().reverse()}static padShape(r,i){let o=r.length;return r.map((u,n)=>u+i[n]+i[n+o])}static areEqual(r,i){return r.length!==i.length?!1:r.every((o,u)=>o===i[u])}static validateDimsAndCalcSize(r){if(r.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let i=1;for(let o of r){if(!Number.isInteger(o))throw new TypeError(`Invalid shape: ${o} is not an integer`);if(o<0||o>2147483647)throw new TypeError(`Invalid shape: length ${o} is not allowed`);i*=o}return i}static flattenShape(r,i){i<0&&(i+=r.length);let o=r.reduce((n,s)=>n*s,1),u=r.slice(i).reduce((n,s)=>n*s,1);return[o/u,u]}static squeezeShape(r,i){let o=new Array;i=q.normalizeAxes(i,r.length);for(let u=0;u<r.length;u++){let n=i.indexOf(u)>=0;if(n&&r[u]!==1)throw new Error("squeeze an axis of size different than 1");(i.length===0&&r[u]>1||i.length>0&&!n)&&o.push(r[u])}return o}static unsqueezeShape(r,i){let o=new Array(r.length+i.length);o.fill(0);for(let n=0;n<i.length;n++){let s=q.normalizeAxis(i[n],o.length);if(s>=o.length)throw new Error("'axes' has an out of range axis");if(o[s]!==0)throw new Error("'axes' has a duplicate axis");o[s]=1}let u=0;for(let n=0;n<o.length;n++)o[n]===0&&(o[n]=r[u++]);if(u!==r.length)throw new Error("the unsqueezed dimension could not be established");return o}},Je=class Tt{static splitShape(r,i,o,u){if(o.length===0){if(!u)throw new Error("need to know number of outputs when the 'split' attribute is not specified");Tt.determineSplit(r[i],u,o)}let n=[],s=[0];for(let p=0;p<o.length;++p){p!==0&&s.push(s[p-1]+o[p-1]);let c=r.slice();c[i]=o[p],n.push(c)}return[n,s]}static determineSplit(r,i,o){if(r%i!==0)throw new Error("cannot split tensor to equal sized parts");for(let u=0;u<i;++u)o.push(r/i)}},ce=class ve{static adjustPoolAttributes(r,i,o,u,n,s){if(!r&&o.length!==i.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(r)for(let p=0;p<i.length-2;p++)p>=o.length?o.push(i[p+2]):o[p]=i[p+2];for(let p=0;p<o.length;p++)if(p<u.length){if(u[p]<0)throw new Error("strides should be greater than or equal to 1")}else u.push(1);for(let p=0;p<o.length;p++)if(p<n.length){if(n[p]<0)throw new Error("dilations should be greater than or equal to 1")}else n.push(1);for(let p=0;p<o.length*2;p++)if(p<s.length){if(s[p]<0)throw new Error("pad should be greater than or equal to 1")}else s.push(0);for(let p=0;p<o.length;p++){if(o[p]<=0)throw new Error("kernel shapes need to be greater than 0");if(s[p]>=o[p]||s[p+o.length]>=o[p])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(r,i,o,u,n,s){if(s){if(n.length!==2*(r.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(i.length!==r.length-2)throw new Error("length of strides should be the length of data dimensions");if(u.length!==r.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let p=0;p<r.length-2;p++)ve.adjustPadAndReturnShape(r[p+2],i[p],o[p],u[p],n,p,p+r.length-2,s)}}static computePoolOutputShape(r,i,o,u,n,s,p){if(i.length<=0)throw new Error("input shape must be of size greater than 0");let c=[i[0],i[1]];return ve.computeShapeHelper(r,i,c,o,u,n,s,p),c}static computeConvOutputShape(r,i,o,u,n,s,p){if(r.length<=0||i.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let c=[r[0],i[0]];return ve.computeShapeHelper(!1,r,c,o,u,n,s,p),c}static computeShapeHelper(r,i,o,u,n,s,p,c){if(r)for(let t=0;t<i.length-2;t++)o.push(1);else for(let t=0;t<i.length-2;t++)o.push(ve.adjustPadAndReturnShape(i[t+2],u[t],n[t],s[t],p,t,t+i.length-2,c))}static adjustPadAndReturnShape(r,i,o,u,n,s,p,c){let t=o*(u-1)+1;if(c&&c!=="NOTSET")switch(c){case"VALID":return n[s]=0,n[p]=0,Math.floor((r-t)/i+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let l=((r+i-1)/i-1)*i+u-r;return n[s]=Math.floor(c==="SAME_LOWER"?(l+1)/2:l/2),n[p]=l-n[s],Math.floor((r+l-u)/i+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((r+n[s]+n[p]-t)/i+1)}},pe=-34028234663852886e22,de=34028234663852886e22});function Uc(e){switch(e){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${e}`)}}function Xa(e){switch(e){case N.onnx.TensorProto.DataType.UINT8:case N.onnx.TensorProto.DataType.INT8:case N.onnx.TensorProto.DataType.BOOL:return 1;case N.onnx.TensorProto.DataType.UINT16:case N.onnx.TensorProto.DataType.INT16:return 2;case N.onnx.TensorProto.DataType.FLOAT:case N.onnx.TensorProto.DataType.INT32:case N.onnx.TensorProto.DataType.UINT32:return 4;case N.onnx.TensorProto.DataType.INT64:case N.onnx.TensorProto.DataType.DOUBLE:case N.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${N.onnx.TensorProto.DataType[e]}`)}}function zc(e,r){return new(Za(r))(e)}function Za(e){switch(e){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function ro(e,r){if(r===N.onnx.TensorProto.DataType.INT64||r===eo.TensorDataType.INT64){if(e.greaterThanOrEqual(2147483648)||e.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else if(r===N.onnx.TensorProto.DataType.UINT32||r===eo.TensorDataType.UINT32||r===N.onnx.TensorProto.DataType.UINT64||r===eo.TensorDataType.UINT64){if(e.greaterThanOrEqual(4294967296)||e.lessThan(0))throw new TypeError("uint64 is not supported")}else throw new TypeError(`not a LONG type: ${N.onnx.TensorProto.DataType[r]}`);return e.toNumber()}function Ka(e,r,i){switch(r){case N.onnx.TensorProto.DataType.BOOL:case N.onnx.TensorProto.DataType.UINT8:return e.getUint8(i);case N.onnx.TensorProto.DataType.INT8:return e.getInt8(i);case N.onnx.TensorProto.DataType.UINT16:return e.getUint16(i,!0);case N.onnx.TensorProto.DataType.INT16:return e.getInt16(i,!0);case N.onnx.TensorProto.DataType.FLOAT:return e.getFloat32(i,!0);case N.onnx.TensorProto.DataType.INT32:return e.getInt32(i,!0);case N.onnx.TensorProto.DataType.UINT32:return e.getUint32(i,!0);case N.onnx.TensorProto.DataType.INT64:return ro(jt.fromBits(e.getUint32(i,!0),e.getUint32(i+4,!0),!1),r);case N.onnx.TensorProto.DataType.DOUBLE:return e.getFloat64(i,!0);case N.onnx.TensorProto.DataType.UINT64:return ro(jt.fromBits(e.getUint32(i,!0),e.getUint32(i+4,!0),!0),r);default:throw new Error(`cannot read from DataView for type ${N.onnx.TensorProto.DataType[r]}`)}}var Ja,N,eo,et,he=x(()=>{Ja=Ie(Gi()),Mn(),qe(),N=Ie(Ae()),U(),eo=P.experimental.fbs,et=class Ue{constructor(r,i,o,u,n,s=Ja.Guid.create()){this.dims=r,this.type=i,this.dataProvider=o,this.asyncDataProvider=u,this.cache=n,this.dataId=s,this.size=A.validateDimsAndCalcSize(r);let p=this.size,c=o===void 0&&u===void 0&&n===void 0;if(n!==void 0&&n.length!==p)throw new RangeError("Input dims doesn't match data length.");if(i==="string"){if(n!==void 0&&(!Array.isArray(n)||!n.every(t=>typeof t=="string")))throw new TypeError("cache should be a string array");c&&(this.cache=new Array(p))}else{if(n!==void 0){let t=Za(i);if(!(n instanceof t))throw new TypeError(`cache should be type ${t.name}`)}if(c){let t=new ArrayBuffer(p*Uc(i));this.cache=zc(t,i)}}}get data(){if(this.cache===void 0){let r=this.dataProvider(this.dataId);if(r.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=r}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(r){return this.data[A.indicesToOffset(r,this.strides)]}set(r,i){this.data[A.indicesToOffset(r,this.strides)]=i}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=A.computeStrides(this.dims)),this._strides}static fromProto(r){if(!r)throw new Error("cannot construct Value from an empty tensor");let i=st.tensorDataTypeFromProto(r.dataType),o=st.tensorDimsFromProto(r.dims),u=new Ue(o,i);if(i==="string")r.stringData.forEach((n,s)=>{u.data[s]=Ze(n)});else if(r.rawData&&typeof r.rawData.byteLength=="number"&&r.rawData.byteLength>0){let n=u.data,s=new DataView(r.rawData.buffer,r.rawData.byteOffset,r.rawData.byteLength),p=Xa(r.dataType),c=r.rawData.byteLength/p;if(r.rawData.byteLength%p!==0)throw new Error("invalid buffer length");if(n.length!==c)throw new Error("buffer length mismatch");for(let t=0;t<c;t++){let l=Ka(s,r.dataType,t*p);n[t]=l}}else{let n;switch(r.dataType){case N.onnx.TensorProto.DataType.FLOAT:n=r.floatData;break;case N.onnx.TensorProto.DataType.INT32:case N.onnx.TensorProto.DataType.INT16:case N.onnx.TensorProto.DataType.UINT16:case N.onnx.TensorProto.DataType.INT8:case N.onnx.TensorProto.DataType.UINT8:case N.onnx.TensorProto.DataType.BOOL:n=r.int32Data;break;case N.onnx.TensorProto.DataType.INT64:n=r.int64Data;break;case N.onnx.TensorProto.DataType.DOUBLE:n=r.doubleData;break;case N.onnx.TensorProto.DataType.UINT32:case N.onnx.TensorProto.DataType.UINT64:n=r.uint64Data;break;default:throw new Error("unspecific error")}if(n==null)throw new Error("failed to populate data from a tensorproto value");let s=u.data;if(s.length!==n.length)throw new Error("array length mismatch");for(let p=0;p<n.length;p++){let c=n[p];jt.isLong(c)?s[p]=ro(c,r.dataType):s[p]=c}}return u}static fromData(r,i,o){return new Ue(i,o,void 0,void 0,r)}static fromOrtTensor(r){if(!r)throw new Error("cannot construct Value from an empty tensor");let i=st.tensorDimsFromORTFormat(r),o=st.tensorDataTypeFromProto(r.dataType()),u=new Ue(i,o);if(o==="string")for(let n=0;n<r.stringDataLength();n++)u.data[n]=r.stringData(n);else if(r.rawDataArray()&&typeof r.rawDataLength()=="number"&&r.rawDataLength()>0){let n=u.data,s=new DataView(r.rawDataArray().buffer,r.rawDataArray().byteOffset,r.rawDataLength()),p=Xa(r.dataType()),c=r.rawDataLength()/p;if(r.rawDataLength()%p!==0)throw new Error("invalid buffer length");if(n.length!==c)throw new Error("buffer length mismatch");for(let t=0;t<c;t++){let l=Ka(s,r.dataType(),t*p);n[t]=l}}return u}}});function D(e){return e===1?Wc:Hc}function Ya(e){let r=D(e);return`${r.version}
      precision highp float;
      ${r.attribute} vec3 position;
      ${r.attribute} vec2 textureCoord;

      ${r.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`}function Qa(e){let r=D(e);return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFrag} vec2 TexCoords;
    ${r.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `}function ts(e,r){let i=D(e);return`
  void main() {
    int indices[${r}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${i.output} = result;
  }
  `}var Wc,Hc,X=x(()=>{Wc={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},Hc={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}}),R=x(()=>{});async function no(e,r=o=>0,i){return new Promise((o,u)=>{let n=0,s=()=>{if(e()){o();return}n++;let p=r(n);setTimeout(s,p)};s()})}function Br(e){return Pe(typeof e<"u"&&e.length!==0,()=>"empty string found for sampler name"),"get"+e.charAt(0).toUpperCase()+e.slice(1)}function es(e){return Pe(typeof e<"u"&&e.length!==0,()=>"empty string found for sampler name"),"get"+e.charAt(0).toUpperCase()+e.slice(1)+"AtOutCoords"}function Ee(e,r){let i=JSON.parse(JSON.stringify(e));return i=r,i}function De(e,r){return r.map(i=>e[i]).join(", ")}function pt(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Rt(e=6){return["x","y","z","w","u","v"].slice(0,e)}var Mt=x(()=>{U()});function qc(e,r){return Rt(r).map(i=>`${e}.${i}`)}function Le(e,r){return r===1?[e]:qc(e,r)}function Vt(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}var me=x(()=>{Mt()});function Xc(e,r,i){if(e===0)return"false";if(e===1)return`rc > ${r[0]}`;let o="";for(let u=e-2;u<e;u++)o+=`${i[u]} >= ${r[u-e+2]}`,u<e-1&&(o+="||");return o}function Kc(e,r){let i=e.length;if(i===0)return"getA(), 0, 0, 0";if(i===1)return`getA(rc),
            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),
            0, 0`;let o="r, c",u="r, cp1",n="rp1, c",s="rp1, cp1",p="";if(i>2)for(let c=0;c<i-2;++c)p=p+`${r[c]},`;return`getA(${p}${o}),
          rEdge ? 0. : getA(${p}${n}),
          cEdge ? 0. : getA(${p}${u}),
          rEdge || cEdge ? 0. : getA(${p}${s})`}function Jc(e,r,i,o){return e===0||e===1?"":`
    int r = ${r[e-2]};
    int c = ${r[e-1]};
    int rp1 = ${r[e-2]} + 1;
    int cp1 = ${r[e-1]} + 1;
    bool rEdge = rp1 >= ${o};
    bool cEdge = cp1 >= ${i};
    `}var rs,jc,ns,os=x(()=>{X(),R(),Mt(),me(),rs={name:"pack",inputNames:["A"],inputTypes:[1]},jc=(e,r)=>{let i=D(e.session.backend.glContext.version),o=r.dims,u=o.length,n=r.dims.length,s=pt(n),p=Le("rc",n),c=Jc(n,p,o[o.length-2],o[o.length-1]),t;u===0?t=[1,1]:u===1?t=[o[0],1]:t=[o[n-1],o[n-2]];let l=Xc(n,t,p),a=Kc(o,p),d=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${l}) {
            ${i.output} = vec4(0);
          } else {
            ${c}

            ${i.output} = vec4(${a});
          }
        }
      `;return{...rs,hasMain:!0,output:{dims:r.dims,type:r.type,textureType:2},shaderSource:d}},ns=(e,r)=>({...rs,get:()=>jc(e,r)})});function oo(e){if(e.length===0)return[1,1,1];let r=1;for(let i=0;i<e.length-2;++i)r*=e[i];return[r,e.length>1?e[e.length-2]:1,e[e.length-1]]}function as(e,r){let i=!1;return e.length===0||r.length===0?i=!0:e.length<2||r.length<2?i=e[e.length-1]===r[r.length-1]:i=e[e.length-1]===r[r.length-1]&&e[e.length-2]===r[r.length-2],i}function Qc(e){let r=A.computeStrides(e),i=["b","r","c"],o="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${r.map((u,n)=>{let s=`int ${i[n]} = ${o} / ${u}`,p=n===r.length-1?`int ${i[n+1]} = ${o} - ${i[n]} * ${u}`:`index -= ${i[n]} * ${u}`;return`${s}; ${p};`}).join("")}
      return ivec3(b, r, c);
    }
  `}function tp(e){let r=A.computeStrides(e);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${r[0]} + coords.z * ${r[1]} + coords.y;
  }
`}var Zc,Yc,is,ss=x(()=>{U(),X(),R(),me(),Zc=e=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${e}`}),Yc=(e,r,i,o)=>{let u=r.dims,n=o,s="";for(let t=0;t<4;t++){let l="";switch(t){case 0:l="outputCoords = rc;";break;case 1:l="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:l="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:l="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}s+=`
        ${l}
        ${t>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${t}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${t>0?"}":""}
      `}let p=D(e.session.backend.glContext.version),c=`
      ${Qc(u)}
      ${tp(n)}
      ${Vt()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${n[2]};
        int cols = ${n[1]};

        ${s}
        ${p.output} = result;
      }
    `;return{...i,output:{dims:n,type:r.type,textureType:2},shaderSource:c,hasMain:!0}},is=(e,r,i)=>{let o=Zc(i);return{...o,get:()=>Yc(e,r,o,i)}}}),io,us=x(()=>{X(),R(),io=(e,r)=>{let i=r.shape,o=D(e.session.backend.glContext.version),u=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${o.texture2D}(X,TexCoords).r;
      ${o.output} = encodeAsUint8(value);
    }`,n={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:i,type:r.tensor.type,textureType:3},shaderSource:u,hasMain:!0};return e.executeProgram(n,[r.tensor])}});function rp(e,r){if(e===1)return"rc";let i="";for(let o=0;o<e;o++)i+=r[o],o<e-1&&(i+=",");return i}var ls,ep,fs,cs=x(()=>{X(),R(),Mt(),me(),ls={name:"unpack",inputNames:["A"],inputTypes:[2]},ep=(e,r)=>{let i=r.dims.length,o=Le("rc",i),u=o.slice(-2),n=pt(i),s=Vt(),p=r.dims.length===0?"":rp(i,o),c=i<=1?"rc":`vec2(${u.join(",")})`,t=D(e.session.backend.glContext.version),l=`
    ${s}
    void main() {
      ${n} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${p});

       ${t.output} = vec4(getChannel(packedInput, ${c}), 0, 0, 0);
     }
   `;return{...ls,hasMain:!0,output:{dims:r.dims,type:r.type,textureType:0},shaderSource:l}},fs=(e,r)=>({...ls,get:()=>ep(e,r)})}),Fr,Ye,Nr,Qe=x(()=>{vt(),Fr=class{constructor(e,r=1){if(r===1)this.internalFormat=e.R32F,this.format=e.RED,this.textureType=e.FLOAT,this.channelSize=r;else if(r===4)this.internalFormat=e.RGBA32F,this.format=e.RGBA,this.textureType=e.FLOAT,this.channelSize=r;else throw new Error(`Invalid number of channels: ${r}`)}encode(e,r){let i,o;return e.constructor!==Float32Array&&(z.warning("Encoder","data was not of type Float32; creating new Float32Array"),o=new Float32Array(e)),r*this.channelSize>e.length?(z.warning("Encoder","Source data too small. Allocating larger array"),o=e,i=this.allocate(r*this.channelSize),o.forEach((u,n)=>i[n]=u)):(o=e,i=o),i}allocate(e){return new Float32Array(e*4)}decode(e,r){return this.channelSize===1?e.filter((i,o)=>o%4===0).subarray(0,r):e.subarray(0,r)}},Ye=class{constructor(e,r=1,i){if(r!==1&&r!==4)throw new Error(`Invalid number of channels: ${r}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.channelSize=r,this.textureType=i||e.FLOAT}encode(e,r){let i=e;return this.channelSize===1&&(z.verbose("Encoder","Exploding into a larger array"),i=this.allocate(r),e.forEach((o,u)=>i[u*4]=o)),i}allocate(e){return new Float32Array(e*4)}decode(e,r){return this.channelSize===1?e.filter((i,o)=>o%4===0).subarray(0,r):e.subarray(0,r)}},Nr=class{constructor(e,r=1){if(this.channelSize=4,r===1)this.internalFormat=e.ALPHA,this.format=e.ALPHA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=r;else if(r===4)this.internalFormat=e.RGBA,this.format=e.RGBA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=r;else throw new Error(`Invalid number of channels: ${r}`)}encode(e,r){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}allocate(e){return new Uint8Array(e*this.channelSize)}decode(e,r){if(e instanceof Uint8Array)return e.subarray(0,r);throw new Error(`Invalid array type: ${e.constructor}`)}}}),tr,ps,ao,ds=x(()=>{U(),R(),tr=(e,r,i)=>{let o=i===0||i===1?1:4,u=i===2,n=i===1||i===2,s=i===4?r.length-1:void 0,p=i===4?r.map((c,t)=>t===r.length-1?c*4:c):void 0;return ao(e,r,o,p,{isPacked:u,reverseWH:n,breakAxis:s})},ps=(e,r,i)=>{let o=tr(e,r,i);return[o.width,o.height]},ao=(e,r,i=1,o,u)=>{let n=!!(u&&u.isPacked),[s,p]=e.computeTextureWH(n&&o||r,u),c=r.length,t=r.slice(0);if(c===0&&(t=[1]),i===1)o=r;else if(n){if(i!==4)throw new Error("a packed texture must be 4-channel");o=r,c>0&&(t[c-1]=Math.ceil(t[c-1]/2)),c>1&&(t[c-2]=Math.ceil(t[c-2]/2))}else if(!o)throw new Error("Unpacked shape is needed when using channels > 1");return{width:s,height:p,channels:i,isPacked:n,shape:t,strides:A.computeStrides(t),unpackedShape:o,reversedWH:u&&u.reverseWH}}}),op,Cr,ms=x(()=>{vt(),he(),U(),os(),ss(),us(),cs(),Qe(),ds(),R(),op=(e,r)=>{let i=r.map(u=>`${u.unpackedShape.join(",")};${u.width}x${u.height}`).join("_"),o=e.name;return e.cacheHint&&(o+="["+e.cacheHint+"]"),o+=":"+i,o},Cr=class{constructor(e){this.session=e,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,r){return ps(this.session.layoutStrategy,e,r)}executeProgram(e,r){if(r.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");let i=[];for(let c=0;c<e.inputNames.length;++c)i[c]=this.getOrCreateTextureData(r[c],e.inputTypes[c]);let o=op(e,i),u=this.session.programManager.getArtifact(o),n=u?u.programInfo:typeof e.get=="function"?e.get():e,s=tr(this.session.layoutStrategy,n.output.dims,n.output.textureType),p=this.createTextureData(s,n.output.type);return u||(u=this.session.programManager.build(n,i,p),this.session.programManager.setArtifact(o,u)),this.runProgram(u,i,p),p}run(e,r){return this.executeProgram(e,r).tensor}runProgram(e,r,i){for(let o=0;o<r.length;++o)if(!!r[o].isPacked!=(e.programInfo.inputTypes[o]===2))throw new Error(`input[${o}] property packed inconsistent`);if(!!i.isPacked!=(e.programInfo.output.textureType===2))throw new Error("output property packed inconsistent");this.session.programManager.run(e,r,i)}getOrCreateTextureData(e,r){let i=this.getTextureData(e.dataId,r===2);if(!i&&(i=this.getTextureData(e.dataId,r!==2),i))return r===2?this.pack(i):this.unpack(i);if(!i){let o=tr(this.session.layoutStrategy,e.dims,r);if(r===4){let u=e.dims;if(u.length===4){let n=[u[0],Math.ceil(u[1]*u[2]*u[3]/4)],s=tr(this.session.layoutStrategy,n,r),p=e.numberData;if(u[1]*u[2]*u[3]%4!==0){let c=u[0],t=u[1]*u[2]*u[3],l=Math.ceil(t*1/4)*4,a=c*l;p=new Float32Array(a);for(let d=0;d<c;++d){let h=d*t,f=d*l+d%1*t;p.set(e.numberData.subarray(h,h+t),f)}}return this.createTextureData(s,e.type,p,e,1)}}if(r===2){let u=ao(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),n=this.createTextureData(u,e.type,e.numberData,e,1);i=this.pack(n)}else i=this.createTextureData(o,e.type,e.numberData,e,1)}return i}createTextureDataFromLayoutBindTensor(e,r,i,o){return this.createTextureData(e,r,i,o,1)}createTextureData(e,r,i,o,u){z.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);let n=this.session.textureManager.createTextureFromLayout(r,e,i,u);return this.createTextureDataFromTexture(e,r,n,o)}reshapeUnpacked(e,r){let i=this.getOrCreateTextureData(e,0),o={channels:i.channels,height:i.height,width:i.width,shape:r.length!==0?r:[1],strides:A.computeStrides(r),unpackedShape:r};return this.createTextureDataFromTexture(o,e.type,i.texture).tensor}reshapePacked(e,r){let i=this.getOrCreateTextureData(e,2);if(as(e.dims,r)){let p={channels:i.channels,height:i.height,width:i.width,shape:r.length!==0?r:[1],strides:A.computeStrides(r),unpackedShape:r,isPacked:!0};return this.createTextureDataFromTexture(p,e.type,i.texture).tensor}let o=oo(e.dims),u=oo(r),n=this.reshapePacked(e,o),s=this.run(is(this,n,u),[n]);return this.reshapePacked(s,r)}cast(e,r){let i=this.getOrCreateTextureData(e,0);return this.createTextureDataFromTexture(i,r,i.texture).tensor}createTextureDataFromTexture(e,r,i,o,u){let n={...e,tensor:o||new et(e.unpackedShape,r,s=>this.readTexture(n),async s=>this.readTextureAsync(n),void 0,u),texture:i};return this.setTextureData(n.tensor.dataId,n,e.isPacked),n}getTextureData(e,r=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,r):r?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,r,i=!1){this.session.isInitializer(e)?this.session.setTextureData(e,r,i):(i?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,r)}isTextureLayoutCached(e,r=!1){return!!this.getTextureData(e.dataId,r)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(io(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(io(this,e))}pack(e){return this.executeProgram(ns(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram(fs(this,e.tensor),[e.tensor])}}}),so,F,at=x(()=>{so=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},F=e=>new so(e)}),bs,gs,ys,ip,ap,xs=x(()=>{at(),X(),R(),bs={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},gs=(e,r,i)=>(ap(r),[e.run({...bs,cacheHint:i.cacheKey,get:()=>ip(e,r,i)},r)]),ys=e=>{let r=e.attributes.getFloat("epsilon",1e-5),i=e.attributes.getFloat("momentum",.9),o=e.attributes.getInt("spatial",1);return F({epsilon:r,momentum:i,spatial:o})},ip=(e,r,i)=>{let o=D(e.session.backend.glContext.version),u=r[0].dims.length,[n,s]=e.calculateTextureWidthAndHeight(r[1].dims,0),p=`
  float process(int[${u}] indices) {
    vec2 position = offsetToCoords(indices[1], ${n}, ${s});
    float scale = getColorAsFloat(${o.texture2D}(Scale, position));
    float mean = getColorAsFloat(${o.texture2D}(Mean, position));
    float variance = getColorAsFloat(${o.texture2D}(Variance, position));
    float b = getColorAsFloat(${o.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${i.epsilon})) ) + b;
  }`;return{...bs,output:{dims:r[0].dims,type:r[0].type,textureType:0},shaderSource:p}},ap=e=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let r=e[0],i=e[1],o=e[2],u=e[3],n=e[4];if(r.dims.length<3||i.dims.length!==1||o.dims.length!==1||u.dims.length!==1||n.dims.length!==1)throw new Error("invalid input shape.");if(i.dims[0]!==r.dims[1]||o.dims[0]!==r.dims[1]||u.dims[0]!==r.dims[1]||n.dims[0]!==r.dims[1])throw new Error("invalid input shape.");if(r.type!=="float32"&&r.type!=="float64"||i.type!=="float32"&&i.type!=="float64"||o.type!=="float32"&&o.type!=="float64"||u.type!=="float32"&&u.type!=="float64"||n.type!=="float32"&&n.type!=="float64")throw new Error("invalid input tensor types.")}}),Rr,Ot,O,er,Gr,Xt=x(()=>{Rr=class{constructor(e,r,i,o){this.glContext=e,this.programInfo=r,this.inputTextureLayouts=i,this.outputTextureLayout=o}},Ot=class{constructor(e){this.context=e}},O=class{constructor(e,r){this.routineBody=e,this.dependencies=r}},er=class{constructor(e,r,i){this.name=e,i?this.dependencies=i:this.dependencies=[],r&&(this.routineBody=r)}addDependency(e){e&&this.dependencies.push(e)}},Gr=class{static returnOrderedNodes(e){if(!e||e.length===0)return[];if(e.length===1)return e;let r=new Set,i=new Set,o=new Array;return this.createOrderedNodes(e,r,i,o),o}static createOrderedNodes(e,r,i,o){for(let u=0;u<e.length;++u)this.dfsTraverse(e[u],r,i,o)}static dfsTraverse(e,r,i,o){if(!e||i.has(e.name))return;if(r.has(e.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");r.add(e.name);let u=e.dependencies;if(u&&u.length>0)for(let n=0;n<u.length;++n)this.dfsTraverse(u[n],r,i,o);o.push(e),i.add(e.name),r.delete(e.name)}}});function up(){let e="add_";return{body:`
  float ${e}(float a, float b) {
    return a + b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:e,type:0}}function lp(){let e="div_";return{body:`
  float ${e}(float a, float b) {
    return a / b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:e,type:0}}function fp(){let e="mul_";return{body:`
  float ${e}(float a, float b) {
    return a * b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:e,type:0}}function cp(){let e="sub_";return{body:`
  float ${e}(float a, float b) {
    return a - b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:e,type:0}}function pp(){let e="equal_";return{body:`
  float ${e}(float a, float b) {
    return float(a == b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:e,type:0}}function dp(){let e="greater_";return{body:`
  float ${e}(float a, float b) {
    return float(a > b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:e,type:0}}function hp(){let e="less_";return{body:`
  float ${e}(float a, float b) {
    return float(a < b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:e,type:0}}function mp(){let e="and_";return{body:`
  float ${e}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:e,type:0}}function bp(){let e="or_";return{body:`
  float ${e}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:e,type:0}}function gp(){let e="xor_";return{body:`
  float ${e}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:e,type:0}}function yp(){return Tp("pow")}function xp(){let e="prelu_";return{body:`
  float ${e}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:e,type:0}}function Tp(e){let r=`${e}_`;return{body:`
  float ${r}(float a, float b) {
    return ${e}(a, b);
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return ${e}(v1, v2);
  }
  `,name:r,type:0}}var At,wp,Ts,ws,vs,Is,_s,Ss,Os,As,Ps,Es,Ds,Ls,$s=x(()=>{U(),Xt(),X(),R(),At=(e,r,i,o=r[0].type,u)=>{let n=e.session.pack?2:0;return{name:i.name,inputNames:["A","B"],inputTypes:[n,n],cacheHint:u,get:()=>wp(e,r,i,o)}},wp=(e,r,i,o=r[0].type)=>{let u=e.session.pack?2:0,n=!A.areEqual(r[0].dims,r[1].dims),s=r[0].dims,p=e.session.pack;if(n){let l=ct.calcShape(r[0].dims,r[1].dims,!1);if(!l)throw new Error("Can't perform binary op on the given tensors");s=l;let a=s.length,d=r[0].dims.length!==0?r[0].dims.length:1,h=r[1].dims.length!==0?r[1].dims.length:1,f=r[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",g=r[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",y=D(e.session.backend.glContext.version),w=p?`
      ${i.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${i.name}(a, b);
        ${y.output} = result;
      }`:`
      ${i.body}
      float process(int indices[${a}]) {
        int aindices[${d}];
        int bindices[${h}];
        ${f}
        ${g}
        return ${i.name}(_A(aindices), _B(bindices));
      }`;return{name:i.name,inputNames:["A","B"],inputTypes:[u,u],output:{dims:s,type:o,textureType:u},shaderSource:w,hasMain:p}}let c=D(e.session.backend.glContext.version),t=`
    ${i.body}
    void main() {
      vec4 v1 = ${c.texture2D}(A, TexCoords);
      vec4 v2 = ${c.texture2D}(B, TexCoords);
      vec4 result = ${i.name}(v1, v2);
      ${c.output} = result;
    }
    `;return{name:i.name,inputNames:["A","B"],inputTypes:[u,u],output:{dims:r[0].dims,type:o,textureType:u},shaderSource:t,hasMain:!0}},Ts=(e,r)=>[e.run(At(e,r,up()),r)],ws=(e,r)=>[e.run(At(e,r,mp(),"bool"),r)],vs=(e,r)=>[e.run(At(e,r,lp()),r)],Is=(e,r)=>[e.run(At(e,r,pp(),"bool"),r)],_s=(e,r)=>[e.run(At(e,r,dp(),"bool"),r)],Ss=(e,r)=>[e.run(At(e,r,hp(),"bool"),r)],Os=(e,r)=>[e.run(At(e,r,fp()),r)],As=(e,r)=>[e.run(At(e,r,bp(),"bool"),r)],Ps=(e,r)=>[e.run(At(e,r,yp()),r)],Es=(e,r)=>[e.run(At(e,r,xp()),r)],Ds=(e,r)=>[e.run(At(e,r,cp()),r)],Ls=(e,r)=>[e.run(At(e,r,gp(),"bool"),r)]}),ks,Bs,Ip,Fs=x(()=>{U(),ks=(e,r,i)=>(Ip(r),[e.cast(r[0],i)]),Bs=e=>st.tensorDataTypeFromProto(e.attributes.getInt("to")),Ip=e=>{if(!e||e.length!==1)throw new Error("Cast requires 1 input.");if(e[0].type==="string")throw new Error("Invalid input type.")}}),_p,Sp,Ns,Mr,Cs=x(()=>{X(),R(),Mt(),me(),_p=(e,r)=>({name:"Concat (packed)",inputNames:Array.from({length:e},(i,o)=>`X${o}`),inputTypes:Array(e).fill(2),cacheHint:r}),Sp=(e,r,i,o)=>{let u=i[0].dims.slice();if(o>=u.length||o<-1*u.length)throw new Error("axis specified for concat doesn't match input dimensionality");o<0&&(o=u.length+o);let n=u.slice(0);for(let _=1;_<i.length;_++){let B=i[_].dims.slice();for(let E=0;E<u.length;E++)if(E===o)n[o]+=B[E];else if(u[E]!==B[E])throw new Error("non concat dimensions must match")}let s=n.length,p=Le("coords",s),c=pt(s),t=Vt(),l=i.map(_=>_.dims),a=Rt(s),d=new Array(l.length-1);d[0]=l[0][o];for(let _=1;_<d.length;_++)d[_]=d[_-1]+l[_][o];let h=a[o],f=a.slice(-2),g=a.join(),y=`if (${h} < ${d[0]}) {
        return getChannel(
            getX0(${g}), vec2(${f.join()}));
        }`;for(let _=1;_<d.length;_++){let B=d[_-1];y+=`
            if (${h} < ${d[_]}  && ${h} >= ${d[_-1]}) {
              return getChannel(
                getX${_}(${Mr(a,h,B)}),
                vec2(${Mr(f,h,B)}));
            }`}let w=d.length,m=d[d.length-1];y+=`
            return getChannel(
              getX${w}(${Mr(a,h,m)}),
              vec2(${Mr(f,h,m)}));`;let v=D(e.session.backend.glContext.version),T=`
          ${t}
          float getValue(${a.map(_=>"int "+_)}) {
            ${y}
          }

          void main() {
            ${c} coords = getOutputCoords();
            int lastDim = coords.${a[s-1]};
            coords.${a[s-1]} = coords.${a[s-2]};
            coords.${a[s-2]} = lastDim;

            vec4 result = vec4(getValue(${p}), 0., 0., 0.);

            ${p[s-1]} = ${p[s-1]} + 1;
            if (${p[s-1]} < ${n[s-1]}) {
              result.g = getValue(${p});
            }

            ${p[s-2]} = ${p[s-2]} + 1;
            if (${p[s-2]} < ${n[s-2]}) {
              result.a = getValue(${p});
            }

            ${p[s-1]} = ${p[s-1]} - 1;
            if (${p[s-2]} < ${n[s-2]} &&
                ${p[s-1]} < ${n[s-1]}) {
              result.b = getValue(${p});
            }
            ${v.output} = result;
          }
        `;return{...r,output:{dims:n,type:i[0].type,textureType:2},shaderSource:T,hasMain:!0}},Ns=(e,r,i)=>{let o=_p(r.length,i.cacheKey);return{...o,get:()=>Sp(e,o,r,i.axis)}},Mr=(e,r,i)=>{let o=e.indexOf(r);return e.map((u,n)=>n===o?`${u} - ${i}`:u).join()}}),Rs,Op,Ap,Pp,Gs,Ep,Dp,Lp,Ms,$p,Vs=x(()=>{at(),R(),Cs(),Rs=(e,r,i)=>($p(r),e.session.pack&&r[0].dims.length>1?[e.run(Ns(e,r,i),r)]:[e.run(Pp(e,r,i),r)]),Op=(e,r)=>({name:"Concat",inputNames:Array.from({length:e},(i,o)=>`X${o}`),inputTypes:Array(e).fill(0),cacheHint:r}),Ap=(e,r,i,o)=>{let u=i[0].dims.slice();if(o>=u.length||o<-1*u.length)throw new Error("axis specified for concat doesn't match input dimensionality");o<0&&(o=u.length+o);let n=u.slice(0);for(let h=1;h<i.length;h++){let f=i[h].dims.slice();for(let g=0;g<u.length;g++)if(g===o)n[o]+=f[g];else if(u[g]!==f[g])throw new Error("non concat dimensions must match")}let s=n.length,p=new Array(i.length),c=0;for(let h=0;h<p.length;++h)c+=i[h].dims[o],p[h]=c;let t="";i.length<5?t=Gs(p):t=Ep(p);let l=Dp(i.length,s),a=Lp(p),d=`
        ${l}
        ${a}
        ${t}
        float process(int indices[${s}]) {
          int textureIndex = getTextureWhereDataResides (indices[${o}]);

          if(textureIndex != 0) {
            indices[${o}] = indices[${o}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return{...r,output:{dims:n,type:i[0].type,textureType:0},shaderSource:d}},Pp=(e,r,i)=>{let o=Op(r.length,i.cacheKey);return{...o,get:()=>Ap(e,o,r,i.axis)}},Gs=e=>`int getTextureWhereDataResides(int index) {
      ${e.map((r,i)=>`if(index<${r}) {return ${i};}
`).join("")}
    }`,Ep=e=>Gs(e),Dp=(e,r)=>{let i=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${r}]) {`];for(let o=0;o<e;++o)o===0?i.push(`	if (textureIndex == ${o}) { return _X${o}(indices); }`):o===e-1?i.push(`	else { return _X${o}(indices); }`):i.push(`	else if (textureIndex == ${o}) { return _X${o}(indices); }`);return i.push("	}"),i.join(`
`)},Lp=e=>{let r=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let i=0;i<e.length;++i)i===0?r.push(`	if (index == ${i}) { return ${e[i]}; }`):i===e.length-1?r.push(`	else { return ${e[i]}; }`):r.push(`	else if (index == ${i}) { return ${e[i]}; }`);return r.push("	}"),r.join(`
`)},Ms=e=>F({axis:e.attributes.getInt("axis")}),$p=e=>{if(!e||e.length<1)throw new Error("too few inputs");let r=e[0].type,i=e[0].dims.length;if(r==="string")throw new Error("string tensor is not supported yet");for(let o of e){if(o.type!==r)throw new Error("input tensors should be one type");if(o.dims.length!==i)throw new Error("input tensors should have the same shape")}}});function kp(){return Pt("abs")}function Bp(){return Pt("acos")}function Fp(){return Pt("asin")}function Np(){return Pt("atan")}function Cp(){return Pt("ceil")}function Rp(){return Pt("cos")}function Gp(e){let r="elu";return{body:`
  const float alpha = float(${e});

  float ${r}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${r}_(vec4 v) {
    return vec4(${r}_(v.x), ${r}_(v.y), ${r}_(v.z), ${r}_(v.w));
  }
  `,name:r,type:0}}function Mp(){return Pt("exp")}function Vp(){return Pt("floor")}function uo(e,r){let i="clip";return{body:`
  const float min = float(${e});
  const float max = float(${r});

  float ${i}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${i}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:i,type:0}}function Up(){let e="indentity";return{body:`
  float ${e}_(float a) {
    return a;
  }
  vec4 ${e}_(vec4 v) {
    return v;
  }
  `,name:e,type:0}}function zp(e){let r="leakyRelu";return{body:`
  const float alpha = float(${e});

  float ${r}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${r}_(vec4 v) {
    return vec4(${r}_(v.x), ${r}_(v.y), ${r}_(v.z), ${r}_(v.w));
  }
  `,name:r,type:0}}function Wp(){return Pt("log")}function Hp(){let e="neg";return{body:`
  float ${e}_(float a) {
    return -a;
  }
  vec4 ${e}_(vec4 v) {
    return -v;
  }
  `,name:e,type:0}}function qp(){let e="not";return{body:`
  float ${e}_(float a) {
    return float( ! bool(a) );
  }
  bool ${e}_(bool a) {
    return !a;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${e}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:e,type:0}}function jp(){return Pt("sin")}function lo(){let e="relu";return{body:`
  float ${e}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${e}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:e,type:0}}function fo(){let e="sigmoid";return{body:`
  float ${e}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${e}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:e,type:0}}function Xp(){return Pt("sqrt")}function Kp(){return Pt("tan")}function Jp(){let e="tanh";return{body:`
  float ${e}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${e}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:e,type:0}}function Pt(e){return{body:`
  float ${e}_(float a) {
    return ${e}(a);
  }
  vec4 ${e}_(vec4 v) {
    return ${e}(v);
  }
  `,name:e,type:0}}var Zp,Z,Us,zs,Ws,Hs,co,qs,js,Yp,Xs,Ks,Js,Zs,Ys,Qs,po,tu,eu,ru,nu,ou,iu,au,su,uu,lu,fu,ho=x(()=>{at(),U(),Xt(),X(),R(),Zp=(e,r,i,o)=>{let u=e.session.pack?2:0,n=D(e.session.backend.glContext.version);return{...r,output:{dims:i.dims,type:i.type,textureType:u},shaderSource:`
     ${o.body}
     void main() {
       vec4 v = ${n.texture2D}(A, TexCoords);
       v = ${o.name}_(v);
       ${n.output} = v;
     }
     `,hasMain:!0}},Z=(e,r,i,o)=>{let u=e.session.pack?2:0,n={name:i.name,inputTypes:[u],inputNames:["A"],cacheHint:o};return{...n,get:()=>Zp(e,n,r,i)}},Us=(e,r)=>[e.run(Z(e,r[0],kp()),r)],zs=(e,r)=>[e.run(Z(e,r[0],Bp()),r)],Ws=(e,r)=>[e.run(Z(e,r[0],Fp()),r)],Hs=(e,r)=>[e.run(Z(e,r[0],Np()),r)],co=(e,r,i)=>[e.run(Z(e,r[0],uo(i.min,i.max),i.cacheKey),r)],qs=e=>F({min:e.attributes.getFloat("min",pe),max:e.attributes.getFloat("max",de)}),js=(e,r)=>{let i=Yp(e,r);return co(e,[r[0]],i)},Yp=(e,r)=>{if(r.length>=3&&(!e.session.isInitializer(r[1].dataId)||!e.session.isInitializer(r[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let i=r.length>=3?r[1].numberData[0]:pe,o=r.length>=3?r[2].numberData[0]:de;return F({min:i,max:o})},Xs=(e,r)=>[e.run(Z(e,r[0],Cp()),r)],Ks=(e,r)=>[e.run(Z(e,r[0],Rp()),r)],Js=(e,r,i)=>[e.run(Z(e,r[0],Gp(i.alpha),i.cacheKey),r)],Zs=e=>F({alpha:e.attributes.getFloat("alpha",1)}),Ys=(e,r)=>[e.run(Z(e,r[0],Mp()),r)],Qs=(e,r)=>[e.run(Z(e,r[0],Vp()),r)],po=(e,r)=>[e.run(Z(e,r[0],Up()),r)],tu=(e,r,i)=>[e.run(Z(e,r[0],zp(i.alpha),i.cacheKey),r)],eu=e=>F({alpha:e.attributes.getFloat("alpha",.01)}),ru=(e,r)=>[e.run(Z(e,r[0],Wp()),r)],nu=(e,r)=>[e.run(Z(e,r[0],Hp()),r)],ou=(e,r)=>[e.run(Z(e,r[0],qp()),r)],iu=(e,r)=>[e.run(Z(e,r[0],lo()),r)],au=(e,r)=>[e.run(Z(e,r[0],fo()),r)],su=(e,r)=>[e.run(Z(e,r[0],jp()),r)],uu=(e,r)=>[e.run(Z(e,r[0],Xp()),r)],lu=(e,r)=>[e.run(Z(e,r[0],Kp()),r)],fu=(e,r)=>[e.run(Z(e,r[0],Jp()),r)]});function Ut(e){let r;switch(e.activation){case"Relu":r=lo();break;case"Sigmoid":r=fo();break;case"Clip":r=uo(e.clipMin,e.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let i=r.name,o=r.body,u=`value = ${i}_(value);`;return{activationFunction:o,applyActivation:u}}var $e,be=x(()=>{U(),ho(),$e=e=>{let r=e.getString("activation","");if(r==="Clip"){let[i,o]=e.getFloats("activation_params",[pe,de]);return{activation:r,clipMax:o,clipMin:i,activationCacheKey:`${r}:${i},${o}`}}return{activation:r,activationCacheKey:r}}}),td,ed,cu,pu=x(()=>{vt(),X(),R(),Vr(),be(),td=(e,r)=>({name:"GroupedConv",inputNames:e?["X","W","Bias"]:["X","W"],inputTypes:e?[0,0,0]:[0,0],cacheHint:r}),ed=(e,r,i,o)=>{let u=r.length>2?"value += getBias(output_channel);":"",n=r[0].dims.slice(),s=r[1].dims.slice(),p=s[0]/o.group;z.verbose("GroupedConv",`autpPad:${o.autoPad}, dilations:${o.dilations}, group:${o.group}, kernelShape:${o.kernelShape}, pads:${o.pads}, strides:${o.strides}`);let c=ke(n,s,o.dilations,o.pads,o.strides),t=D(e.session.backend.glContext.version),{activationFunction:l,applyActivation:a}=Ut(o),d=`
  const ivec2 strides = ivec2(${o.strides[0]}, ${o.strides[1]});
  const ivec2 pads = ivec2(${o.pads[0]}, ${o.pads[1]});
  ${l}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${p};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${s[1]}; wInChannel++) {
      int input_channel = group_id * ${s[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${s[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${o.dilations[0]};

        if (xHeight < 0 || xHeight >= ${n[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${s[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${o.dilations[1]};
          if (xWidth < 0 || xWidth >= ${n[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${u}
    ${a}
    ${t.output} = vec4(value, .0, .0, .0);
  }
`;return{...i,output:{dims:c,type:r[0].type,textureType:0},shaderSource:d,hasMain:!0}},cu=(e,r,i)=>{let o=td(r.length>2,i.cacheKey);return{...o,get:()=>ed(e,r,o,i)}}}),rd,nd,du,hu=x(()=>{X(),R(),me(),rd=e=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:e}),nd=(e,r,i,o,u,n)=>{let s=i.dims,p=o.dims,c=2,t=3,l=u.length,a=[p[1]*p[2]*p[3],u[2]*u[3]],d=p[2]*p[3],h=Vt(),f=D(e.session.backend.glContext.version),g="";for(let w=0;w<=1;w++)for(let m=0;m<=1;m++)g+=`
            blockIndex = rc.x + ${m};
            pos = rc.y + ${w};

            if(blockIndex < ${a[1]} && pos < ${a[0]}) {
              offsetY = int(blockIndex / (${u[l-1]})) * ${n.strides[0]} -
                ${n.pads[0]};
              d0 = offsetY + ${n.dilations[0]} * (imod(pos, ${d}) / ${p[2]});

              if(d0 < ${s[c]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${u[l-1]}) * ${n.strides[1]} -
                  ${n.pads[1]};
                d1 = offsetX + ${n.dilations[1]} * imod(imod(pos, ${d}), ${p[2]});

                if(d1 < ${s[t]} && d1 >= 0) {

                  ch = int(float(pos)/ ${d}.);
                    innerDims = vec2(d0, d1);
                    result[${w*2+m}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let y=`
      ${h}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${g}
          ${f.output} = result;
      }
            `;return{...r,output:{dims:a,type:i.type,textureType:2},shaderSource:y,hasMain:!0}},du=(e,r,i,o,u)=>{let n=rd(u.cacheKey);return{...n,get:()=>nd(e,n,r,i,o,u)}}});function id(e,r,i){let o=r[0].dims,u=r[1].dims,n=ct.calcShape(o,u,!0);if(!n)throw new Error("Can't use matmul on the given tensors");let s=pt(n.length),p=Rt(),{activationFunction:c,applyActivation:t}=Ut(i),l=r.length>2,a=l?"value += getBiasForMatmul();":"",d=l?`${bo(s,p,r[2].dims,n,!1)}`:"",h=n.length,f=o.length,g=u.length,y=o[o.length-1],w=`
    ${c}
    ${d}
    float process(int indices[${h}]) {
        int a[${f}];
        int b[${g}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${y}; ++k) {
            a[${f-1}] = k;
            b[${g-2}] = k;
            value += _A(a) * _B(b);
        }
        ${a}
        ${t}
        return value;
    }`;return{...e,output:{dims:n,type:r[0].type,textureType:0},shaderSource:w}}function mo(e,r){let i=od(e.length>2,r.activationCacheKey);return{...i,get:()=>id(i,e,r)}}function bo(e,r,i,o,u){let n="",s=i.length,p=o.length,c=p-s;p<2&&s>0?n="coords":n=i.map((d,h)=>`coords.${r[h+c]}`).join(", ");let t=ct.getBroadcastDims(i,o).map(d=>`coords.${r[d+c]} = 0;`).join(`
`),l=A.size(i)===1,a="vec4(outputValue.xx, outputValue.yy)";return l&&(a="vec4(outputValue.x)"),u?`
vec4 getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${t}
  vec4 outputValue = getBias(${n});
  return ${a};
}`:`
float getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${t}
  return getBias(coords.x);
}`}var mu,bu,od,ad,Ur=x(()=>{U(),R(),Mt(),be(),go(),mu=(e,r,i)=>(ad(r),e.session.pack?[e.run(zr(e,r,i),r)]:[e.run(mo(r,i),r)]),bu=e=>$e(e.attributes),od=(e,r)=>({name:"MatMul",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[0,0,0]:[0,0],cacheHint:r}),ad=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if(e[0].type!=="float32"&&e[0].type!=="float64"||e[1].type!=="float32"&&e[1].type!=="float64")throw new Error("inputs should be float type");if(e[0].type!==e[1].type)throw new Error("inputs types should match")}});function ld(e,r,i,o){let u=[],n=[],s=i[0].dims,p=i[1].dims,c=s.length,t=p.length,l=o.length,a=l-c,d=l-t;u=s.map((m,v)=>`coords.${r[v+a]}`),u[c-1]="i*2",u.join(", "),n=p.map((m,v)=>`coords.${r[v+d]}`),n[t-2]="i*2",n.join(", ");let h=ct.getBroadcastDims(s,o),f=ct.getBroadcastDims(p,o),g=h.map(m=>`coords.${r[m+a]} = 0;`).join(`
`),y=f.map(m=>`coords.${r[m+d]} = 0;`).join(`
`),w=`int lastDim = coords.${r[l-1]};
  coords.${r[l-1]} = coords.${r[l-2]};
  coords.${r[l-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${e} coords = getOutputCoords();
  ${w}
  ${g}
  vec4 outputValue = getA(${u});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${e} coords = getOutputCoords();
  ${w}
  ${y}
  vec4 outputValue = getB(${n});
  return outputValue;
}`}function fd(e,r){let i="";for(let o=0;o<r-2;o++)i+=`rc.${e[o]}, `;return i+=`rc.${e[r-2]}, i*2`,i}function cd(e,r){let i="";for(let o=0;o<r-2;o++)i+=`rc.${e[o]}, `;return i+=`i*2, rc.${e[r-1]}`,i}var sd,ud,zr,go=x(()=>{U(),X(),R(),Mt(),be(),Ur(),sd=(e,r)=>({name:"MatMul (packed)",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[2,2,2]:[2,2],cacheHint:r}),ud=(e,r,i,o)=>{let u=i.length>2,n=u?"value += getBiasForMatmul();":"",s=i[0].dims,p=i[1].dims,c=ct.calcShape(s,p,!0),t=!A.areEqual(i[0].dims,i[1].dims);if(!c)throw new Error("Can't use matmul on the given tensors");let l=s[s.length-1],a=Math.ceil(l/2),d=s.length,h=p.length,f=D(e.session.backend.glContext.version),g=pt(c.length),y=c.length,w=Rt(),{activationFunction:m,applyActivation:v}=Ut(o),T=u?`${bo(g,w,i[2].dims,c,!0)}`:"",_=t?`${ld(g,w,i,c)}`:"",B=t?"getAAtOutCoordsMatmul(i)":`getA(${fd(w,d)})`,E=t?"getBAtOutCoordsMatmul(i)":`getB(${cd(w,h)})`,K=t?"":`${g} rc =
          getOutputCoords(); int lastDim = rc.${w[y-1]}; rc.${w[y-1]} =
          rc.${w[y-2]}; rc.${w[y-2]} = lastDim;
      `,je=`
            ${_}
            ${T}
            ${m}
            void main() {
              ${K}

              vec4 value = vec4(0);
              for (int i = 0; i < ${a}; i++) {
                vec4 a = ${B};
                vec4 b = ${E};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${n}
              ${v}
              ${f.output} = value;
            }`;return{...r,output:{dims:c,type:i[0].type,textureType:2},shaderSource:je,hasMain:!0}},zr=(e,r,i)=>{let o=sd(r.length>2,i.activationCacheKey);return{...o,get:()=>ud(e,o,r,i)}}}),gu,yu=x(()=>{Vr(),hu(),go(),gu=(e,r,i)=>{let o=r[0].dims,u=r[1].dims,n=ke(o,u,i.dilations,i.pads,i.strides),s=e.run(du(e,r[0],r[1],n,i),[r[0]]),p=e.reshapePacked(r[1],[u[0],u[1]*u[2]*u[3]]),c=r.length===3?[p,s,r[2]]:[p,s],t=e.run(zr(e,c,i),c);return e.reshapePacked(t,n)}}),pd,dd,xu,yo,xo=x(()=>{R(),pd=e=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:e}),dd=(e,r,i,o,u,n)=>{let s=i.dims,p=o.dims,c=u.length,t=yo(s,p,u,4),l=`
        const int XC = ${s[1]};
        const int XH = ${s[2]};
        const int XW = ${s[3]};
        const int KH = ${n.kernelShape[0]};
        const int KW = ${n.kernelShape[1]};
        const int dilationH = ${n.dilations[0]};
        const int dilationW = ${n.dilations[1]};
        const int strideH = ${n.strides[0]};
        const int strideW = ${n.strides[1]};
        const int padH = ${n.pads[0]};
        const int padW = ${n.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${c}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${s.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return{...r,output:{dims:t,type:i.type,textureType:4},shaderSource:l}},xu=(e,r,i,o,u)=>{let n=pd(u.cacheKey);return{...n,get:()=>dd(e,n,r,i,o,u)}},yo=(e,r,i,o=4)=>[i[0],i[2],i[3],Math.ceil(e[1]*r[2]*r[3]/o)]}),hd,md,Tu,wu=x(()=>{U(),X(),R(),be(),xo(),hd=(e,r)=>({name:"ConvDotProduct",inputNames:e?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:e?[0,4,0]:[0,4],cacheKey:r.activationCacheKey}),md=(e,r,i,o,u)=>{let n=i[0].dims,s=i[1].dims,p=[s[0],Math.ceil(n[1]*s[2]*s[3]/4)],c=yo(n,s,o),[t,l]=e.calculateTextureWidthAndHeight(p,4),a=A.computeStrides(c),[d,h]=e.calculateTextureWidthAndHeight(c,4),f=o.length,g=i.length<3?"0.0":"_B(b)",y=Math.ceil(n[1]*s[2]*s[3]/4),{activationFunction:w,applyActivation:m}=Ut(u),v=D(e.session.backend.glContext.version),T=`
${w}
float process(int indices[${f}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${a[0]} + im2col[1] * ${a[1]} + im2col[2] * ${a[2]};
  int kernelOffset = indices[1] * ${p[1]};
  float value = ${g};
  for (int i = 0; i < ${y}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${d}, ${h});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${t}, ${l});
    value += dot(${v.texture2D}(Im2Col, im2colCoords), ${v.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${m}
  return value;
}`;return{...r,output:{dims:o,type:i[0].type,textureType:0},shaderSource:T}},Tu=(e,r,i,o)=>{let u=hd(r.length>2,o);return{...u,get:()=>md(e,u,r,i,o)}}}),ke,To,bd,gd,yd,xd,wo,Td,Vr=x(()=>{at(),U(),pu(),yu(),wu(),be(),xo(),Ur(),ke=(e,r,i,o,u)=>{let n=e[0],s=e.slice(2),p=s.length,c=r[0],t=r.slice(2).map((a,d)=>a+(a-1)*(i[d]-1)),l=s.map((a,d)=>a+o[d]+o[d+p]).map((a,d)=>Math.floor((a-t[d]+u[d])/u[d]));return[n,c].concat(...l)},To=(e,r,i)=>(Td(r,i),bd(e,r,i)),bd=(e,r,i)=>{let o=xd(i,r),u=e.session.pack,n=o.kernelShape[0]===1&&o.kernelShape[1]===1;return o.group>1?[e.run(cu(e,r,o),r)]:n&&u?[gd(e,r,o)]:u&&r[0].dims.length===4&&r[0].dims[0]===1&&!n?[gu(e,r,o)]:[yd(e,r,o)]},gd=(e,r,i)=>{let o=r[0].dims,u=r[1].dims,n=ke(o,u,i.dilations,i.pads,i.strides),s=e.reshapeUnpacked(r[0],[o[1],o[2]*o[3]]),p=e.reshapeUnpacked(r[1],[u[0],u[1]]),c=r.length>2?[p,s,r[2]]:[p,s],t=e.run(mo(c,i),c);return e.reshapeUnpacked(t,n)},yd=(e,r,i)=>{let o=r[0].dims,u=r[1].dims,n=ke(o,u,i.dilations,i.pads,i.strides),s=e.run(xu(e,r[0],r[1],n,i),[r[0]]),p=r.length===3?[s,r[1],r[2]]:[s,r[1]];return e.run(Tu(e,r,n,i),p)},xd=(e,r)=>{let i=e.kernelShape.slice();if(e.kernelShape.length===0)for(let n=2;n<r[1].dims.length;++n)i.push(r[1].dims[n]);let o=e.pads.slice();ce.adjustPadsBasedOnAutoPad(r[0].dims,e.strides,e.dilations,i,o,e.autoPad);let u=Object.assign({},e);return Object.assign(u,{kernelShape:i,pads:o,cacheKey:e.cacheKey}),u},wo=e=>{let r=e.attributes,i=$e(r),o=r.getString("auto_pad","NOTSET"),u=r.getInts("dilations",[1,1]),n=r.getInt("group",1),s=r.getInts("kernel_shape",[]),p=r.getInts("pads",[0,0,0,0]),c=r.getInts("strides",[1,1]);return F({autoPad:o,dilations:u,group:n,kernelShape:s,pads:p,strides:c,...i})},Td=(e,r)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4||e[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let i=e[0].dims[1],o=e[1].dims[1]*r.group;if(i!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let u=e[0].dims.length-2;if(r.dilations.length!==u)throw new Error(`dilations should be ${u}D`);if(r.strides.length!==u)throw new Error(`strides should be ${u}D`);if(r.pads.length!==u*2)throw new Error(`pads should be ${u*2}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(e[0].type!=="float32"||e[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(e.length===3&&e[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}}),wd,vd,Id,vu,_d,Sd,Od,Ad,Pd,Ed,Iu,Dd,_u=x(()=>{at(),X(),R(),be(),wd=(e,r,i,o,u,n)=>(e-1)*r+i+(o-1)*u+1-n,vd=(e,r,i,o,u)=>{let n=Math.floor(e/2);r==="SAME_UPPER"?(i[o]=n,i[u]=e-n):r==="SAME_LOWER"&&(i[o]=e-n,i[u]=n)},Id=(e,r,i,o,u,n,s,p)=>{let c=e.length-2,t=p.length===0;for(let l=0;l<c;++l){let a=t?e[l+2]*n[l]:p[l],d=wd(e[l+2],n[l],u[l],r[l],i[l],a);vd(d,o,u,l,l+c),t&&p.push(n[l]*(e[l+2]-1)+s[l]+(r[l]-1)*i[l]+1-u[l]-u[l+c])}},vu=(e,r,i)=>(Dd(r,i),_d(e,r,i)),_d=(e,r,i)=>{let o=Ed(i,r);return[Pd(e,r,o)]},Sd=(e,r)=>({name:"ConvTranspose",inputNames:e?["X","W","B"]:["X","W"],inputTypes:e?[0,0,0]:[0,0],cacheHint:r}),Od=(e,r,i,o)=>{let u=r.length>2?"getB(output_channel)":"0.0",n=r[0].dims,s=r[1].dims,p=s[1],c=s[0]/o.group,t=[r[0].dims[0],r[1].dims[1]*o.group,...o.outputShape],l=D(e.session.backend.glContext.version),{activationFunction:a,applyActivation:d}=Ut(o),h=`
  const ivec2 strides = ivec2(${o.strides[0]}, ${o.strides[1]});
  const ivec2 pads = ivec2(${o.pads[0]}, ${o.pads[1]});
  ${a}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${p};
    int wOutChannel = output_channel - group_id * ${p};

    float value = ${u};
    for (int inChannelOffset = 0; inChannelOffset < ${c}; inChannelOffset++) {
      int input_channel = group_id * ${c} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${s[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${s[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${o.dilations[0]}, wHOff * ${o.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${n[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${n[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${d}
    ${l.output} = vec4(value, .0, .0, .0);
  }
`;return{...i,output:{dims:t,type:r[0].type,textureType:0},shaderSource:h,hasMain:!0}},Ad=(e,r,i)=>{let o=Sd(r.length>2,i.cacheKey);return{...o,get:()=>Od(e,r,o,i)}},Pd=(e,r,i)=>e.run(Ad(e,r,i),r),Ed=(e,r)=>{let i=e.kernelShape.slice();if(e.kernelShape.length===0)for(let p=2;p<r[1].dims.length;++p)i.push(r[1].dims[p]);let o=e.pads.slice(),u=e.outputShape.slice(),n=r[0].dims;Id(n,i,e.dilations,e.autoPad,o,e.strides,e.outputPadding,u);let s=Object.assign({},e);return Object.assign(s,{kernelShape:i,pads:o,outputShape:u,cacheKey:e.cacheKey}),s},Iu=e=>{let r=e.attributes,i=$e(r),o=r.getString("auto_pad","NOTSET"),u=r.getInts("dilations",[1,1]),n=r.getInt("group",1),s=r.getInts("kernel_shape",[]),p=r.getInts("output_padding",[0,0]),c=r.getInts("output_shape",[]),t=r.getInts("pads",[0,0,0,0]),l=r.getInts("strides",[1,1]);return F({autoPad:o,dilations:u,group:n,kernelShape:s,outputPadding:p,outputShape:c,pads:t,strides:l,...i})},Dd=(e,r)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4||e[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let i=e[0].dims[1],o=e[1].dims[0];if(i!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let u=e[1].dims[1]*r.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==u))throw new Error("invalid bias");let n=e[0].dims.length-2;if(r.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(r.strides.length!==n)throw new Error(`strides should be ${n}D`);if(r.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(r.outputPadding.length!==n)throw new Error(`output_padding should be ${n}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape");if(e[0].type!=="float32"||e[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(e.length===3&&e[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}}),Su,ge,Ou,Ld,Au,$d,kd,Bd,Wr=x(()=>{at(),U(),R(),Su={name:"Transpose",inputNames:["A"],inputTypes:[0]},ge=(e,r,i)=>(Bd(r),[e.run({...Su,cacheHint:i.cacheKey,get:()=>Ld(e,r[0],i.perm)},r)]),Ou=e=>F({perm:e.attributes.getInts("perm",[])}),Ld=(e,r,i)=>{let o=r.dims;i=Au(o,i);let u=$d(o,i),n=o.length,s=`
      ${kd("perm",i,n)}
      float process(int indices[${n}]) {
        int a[${n}];
        perm(a, indices);
        return _A(a);
      }`;return{...Su,output:{dims:u,type:r.type,textureType:0},shaderSource:s}},Au=(e,r)=>(r&&r.length!==e.length&&(r=[...e.keys()].reverse()),r),$d=(e,r)=>(r=Au(e,r),A.sortBasedOnPerm(e,r)),kd=(e,r,i)=>{let o=[];o.push(`void ${e}(out int a[${i}], int src[${i}]) {`);for(let u=0;u<i;++u)o.push(`	a[${r[u]}]=src[${u}];`);return o.push("	}"),o.join(`
`)},Bd=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("input should be float tensor")}}),Pu,Eu,Fd,Du=x(()=>{Wr(),Pu=(e,r,i)=>{Fd(r);let o=i.blocksize,u=o*o,n=i.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],s=i.mode==="DCR"?[r[0].dims[0],o,o,r[0].dims[1]/u,r[0].dims[2],r[0].dims[3]]:[r[0].dims[0],r[0].dims[1]/u,o,o,r[0].dims[2],r[0].dims[3]],p=e.reshapeUnpacked(r[0],s),c={perm:n,cacheKey:`${n}`},[t]=ge(e,[p],c),l=[r[0].dims[0],r[0].dims[1]/u,r[0].dims[2]*o,r[0].dims[3]*o];return[e.reshapeUnpacked(t,l)]},Eu=e=>{let r=e.attributes.getInt("blocksize");if(r<1)throw new Error(`blocksize must be >= 1, but got : ${r} for DepthToSpace`);let i=e.attributes.getString("mode","DCR");if(i!=="DCR"&&i!=="CRD")throw new Error(`unrecognized mode: ${i} for DepthToSpace`);return{mode:i,blocksize:r}},Fd=e=>{if(e.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${e.length}`);if(e[0].type==="string"||e[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}}),Lu,$u,Nd,ku=x(()=>{U(),Lu=(e,r,i)=>{Nd(r,i);let o=A.flattenShape(r[0].dims,i);return[e.reshapeUnpacked(r[0],o)]},$u=e=>e.attributes.getInt("axis",1),Nd=(e,r)=>{if(!e||e.length!==1)throw new Error("Flatten requires 1 input.");let i=e[0].dims.length;if(i===0)throw new Error("scalar tensor is not supported.");if(r<-i||r>i)throw new Error("Invalid axis");if(e[0].type==="string")throw new Error("string tensor is not supported.")}}),ee,rr=x(()=>{ee=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]}),Bu,Fu,Cd,Rd,Gd,Md,Nu=x(()=>{at(),rr(),U(),R(),Bu=(e,r,i)=>(Md(r,i.axis),[e.run(Gd(e,r,i),r)]),Fu=e=>F({axis:e.attributes.getInt("axis",0)}),Cd={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},Rd=(e,r,i,o)=>{let u=i[0].dims.slice(),n=i[1].dims.slice(),s=new Array(u.length+n.length-1);o=A.normalizeAxis(o,u.length);let p=[];for(let d=0;d<s.length;d++)d<o?(s[d]=u[d],p.push(`inputIdx[${d}] = outputIdx[${d}];`)):d<o+n.length?(s[d]=n[d-o],p.push(`indexDataIdx[${d-o}] = outputIdx[${d}];`)):(s[d]=u[d-n.length+1],p.push(`inputIdx[${d-n.length+1}] = outputIdx[${d}];`));let c=s.length||1,t=u.length,l=n.length||1,a=`
      float process(int outputIdx[${c}]) {
        int inputIdx[${t}];
        int indexDataIdx[${l}];
        indexDataIdx[0] = 0;
        ${p.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${o}] = idx < 0 ? idx + ${u[o]} : idx;
        return _A(inputIdx);
      }`;return{...r,output:{dims:s,type:i[0].type,textureType:0},shaderSource:a}},Gd=(e,r,i)=>{let o={...Cd,cacheHint:i.cacheKey};return{...o,get:()=>Rd(e,o,r,i.axis)}},Md=(e,r)=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.");let i=e[0].dims.length;if(i<1)throw new Error("Invalid input shape.");if(r<-i||r>i-1)throw new Error("Invalid axis.");if(ee.indexOf(e[0].type)===-1)throw new Error("Invaid input type.");if(e[1].type!=="int32"&&e[1].type!=="int16")throw new Error("Invaid input type.")}}),vo,Cu,Ru,Gu,Vd,Ud,zd,Mu=x(()=>{at(),U(),R(),vo=(e,r,i)=>(zd(r,i),[e.run(Vd(r,i),r)]),Cu=(e,r)=>{let i=e.attributes.getInt("transA",0)!==0,o=e.attributes.getInt("transB",0)!==0,u=e.attributes.getFloat("alpha",1),n=e.attributes.getFloat("beta",1);return F({transA:i,transB:o,alpha:u,beta:n,isOptionalC:r})},Ru=e=>Cu(e,!1),Gu=e=>Cu(e,!0),Vd=(e,r)=>{let i={name:"Gemm",inputNames:e.length===3?["A","B","C"]:["A","B"],inputTypes:e.length===3?[0,0,0]:[0,0],key:r.cacheKey};return{...i,get:()=>Ud(i,e,r)}},Ud=(e,r,i)=>{let o=r[0].dims.slice(),u=r[1].dims.slice(),[n,s]=kr.getShapeOfGemmResult(o,i.transA,u,i.transB,r.length===3?r[2].dims:void 0),p=[n,s];if(!p)throw new Error("Can't use gemm on the given tensors");let c=o[o.length-1],t="";i.transA&&(c=o[0]),i.transA&&i.transB?t="value += _A_T(a) * _B_T(b);":i.transA&&!i.transB?t="value += _A_T(a) * _B(b);":!i.transA&&i.transB?t="value += _A(a) * _B_T(b);":!i.transA&&!i.transB&&(t="value += _A(a) * _B(b);");let l=p.length,a=r.length===3?`int c[${r[2].dims.length}];`:"",d=r.length===3?"bcastIndices_C(indices, c);":"",h=r.length===3?"value += beta * _C(c);":"",f=`
      float process(int indices[${l}]) {
          int a[${l}];
          int b[${l}];
          ${a}

          copyVec(indices, a);
          copyVec(indices, b);
          ${d}

          float value = 0.0;
          for (int k=0; k<${c}; ++k) {
              a[${l-1}] = k;
              b[${l-2}] = k;
              ${t}
          }

          value = value * alpha;
          ${h}
          return value;
      }`;return{...e,output:{dims:p,type:r[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:i.alpha},{name:"beta",type:"float",data:i.beta}],shaderSource:f}},zd=(e,r)=>{if(!e)throw new Error("Input is missing");if(r.isOptionalC&&(e.length<2||e.length>3))throw new Error("Invaid input shape.");if(!r.isOptionalC&&e.length!==3)throw new Error("Gemm requires 3 inputs");if(e.length===3&&e[2].dims.length!==1&&e[2].dims.length!==2)throw new Error("Invalid input shape of C");if(e[0].type!=="float32"&&e[0].type!=="float64"||e[1].type!=="float32"&&e[1].type!=="float64"||e.length===3&&e[2].type!=="float32"&&e[2].type!=="float64")throw new Error("Invalid input type.");if(e[0].type!==e[1].type||e.length===3&&e[0].type!==e[2].type)throw new Error("Input types are mismatched")}}),Vu,Uu,Wd,Hd,qd,jd,Xd,zu=x(()=>{at(),R(),Vu=(e,r,i)=>(Xd(r),[e.run(qd(e,r,i),r)]),Uu=e=>{let r=e.attributes.getFloat("scale"),i=e.attributes.getFloats("bias");return F({scale:r,bias:i})},Wd={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},Hd=(e,r,i,o)=>{let u=i[0].dims.slice(),n=u.length,s=`
      ${jd(o.bias.length)}
      float process(int indices[${n}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return{...r,output:{dims:u,type:i[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:o.bias.length,data:o.bias},{name:"scale",type:"float",data:o.scale}],shaderSource:s}},qd=(e,r,i)=>{let o={...Wd,cacheHint:i.cacheKey};return{...o,get:()=>Hd(e,o,r,i)}},jd=e=>{let r=[`float getBias(float bias[${e}], int channel) {`];for(let i=0;i<e;++i)i===0?r.push(`	if (channel == ${i}) { return bias[${i}]; }`):i===e-1?r.push(`	else { return bias[${i}]; }`):r.push(`	else if (channel == ${i}) { return bias[${i}]; }`);return r.push("	}"),r.join(`
`)},Xd=e=>{if(!e||e.length!==1)throw new Error("ImageScaler requires 1 input.");if(e[0].dims.length!==4)throw new Error("Invalid input shape.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.")}}),Hu,qu,Wu,Kd,Jd,Zd,Yd,Qd,th,ju=x(()=>{X(),R(),Hu=(e,r,i)=>{th(r);let o=e.run(Jd(r[0]),r);return[e.run(Qd(e,r[0],i,o.dims),[r[0],o,r[1],r[2]])]},qu=e=>e.attributes.getFloat("epsilon",1e-5),Wu={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},Kd=(e,r)=>{let i=r.dims.slice(),o=i[1],u=i[2]*i[3],n=[i[0],o],s=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${i[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${i[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${u});
        temp = 0.0;
        for(int a2=0; a2<${i[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${i[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${u});

        return v;
      }`;return{...e,output:{dims:n,type:r.type,textureType:4},shaderSource:s}},Jd=e=>({...Wu,get:()=>Kd(Wu,e)}),Zd={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},Yd=(e,r,i,o,u)=>{let n=D(e.session.backend.glContext.version),[s,p]=e.calculateTextureWidthAndHeight(u,4),[c,t]=[s/4,p],l=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${c}, ${t});
        return ${n.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return{...r,output:{dims:i.dims,type:i.type,textureType:0},variables:[{name:"epsilon",type:"float",data:o}],shaderSource:l}},Qd=(e,r,i,o)=>{let u={...Zd,cacheHint:`${i}`};return{...u,get:()=>Yd(e,u,r,i,o)}},th=e=>{if(!e||e.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let r=e[0],i=e[1],o=e[2];if(r.dims.length<3||i.dims.length!==1||o.dims.length!==1)throw new Error("Invalid input shape.");if(i.dims[0]!==r.dims[1]||o.dims[0]!==r.dims[1])throw new Error("Input shapes are mismatched.");if(r.type!=="float32"&&r.type!=="float64"||i.type!=="float32"&&i.type!=="float64"||o.type!=="float32"&&o.type!=="float64")throw new Error("Invalid input type.");if(e[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}});function eh(e,r){let i=e[0].dims[1],o=e[0].dims.length,u=-Math.floor((r.size-1)/2),n=Math.ceil((r.size-1)/2),s=`float(${r.alpha}) / float(${r.size})`,p=`float(${r.bias})`,c=`float(${r.beta})`,t=`
    float process(int indices[${o}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${u}; i <= ${n}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${i}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${p} + ${s} * square_sum, ${c});
    }`;return{...Ju,cacheHint:r.cacheKey,output:{dims:e[0].dims,type:e[0].type,textureType:0},shaderSource:t}}function rh(e,r){return{...Ju,cacheHint:r.cacheKey,get:()=>eh(e,r)}}var Xu,Ku,Ju,nh,Zu=x(()=>{at(),R(),Xu=(e,r,i)=>(nh(r),[e.run(rh(r,i),r)]),Ku=e=>{let r=e.attributes.getFloat("alpha",1e-4),i=e.attributes.getFloat("beta",.75),o=e.attributes.getFloat("bias",1),u=e.attributes.getInt("size");return F({alpha:r,beta:i,bias:o,size:u})},Ju={name:"LRN",inputNames:["X"],inputTypes:[0]},nh=e=>{if(!e||e.length!==1)throw new Error("LRN requires 1 input.");if(e[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(e[0].type!=="float32")throw new Error("input should be float type")}}),oh,Io,Yu,Qu,tl,ih,ah,sh,uh,lh,fh,ch,ph,el=x(()=>{at(),U(),X(),R(),oh={name:"Pad",inputNames:["A"],inputTypes:[0]},Io=(e,r,i)=>(sh(r),[e.run({...oh,cacheHint:i.cacheKey,get:()=>ah(e,r[0],i)},r)]),Yu=e=>{let r=e.attributes.getString("mode","constant"),i=e.attributes.getFloat("value",0),o=e.attributes.getInts("pads");return F({mode:r,value:i,pads:o})},Qu=(e,r,i)=>{uh(r);let o=ih(e,r,i);return Io(e,[r[0]],o)},tl=e=>e.attributes.getString("mode","constant"),ih=(e,r,i)=>{if(!e.session.isInitializer(r[1].dataId)||r.length>=3&&!e.session.isInitializer(r[2].dataId))throw new Error("dynamic pad attributes are not allowed");let o=Array.from(r[1].integerData),u=r.length>=3?r[2].floatData[0]:0;return F({mode:i,pads:o,value:u})},ah=(e,r,i)=>{let o=A.padShape(r.dims.slice(),i.pads),u=o.length,n=`
      ${lh(e,r,i)}
      float process(int[${u}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:o,type:r.type,textureType:0},shaderSource:n}},sh=e=>{if(!e||e.length!==1)throw new Error("Pad requires 1 input");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.")},uh=e=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(e[1].type!=="int32")throw new Error("Invalid input type.");if(e.length>=3&&e[2].type==="string")throw new Error("Invalid input type.")},lh=(e,r,i)=>{let o=D(e.session.backend.glContext.version),[u,n]=e.calculateTextureWidthAndHeight(r.dims,0),s=A.computeStrides(r.dims);switch(i.mode){case"constant":return fh(o,r.dims,s,u,n,i.pads,i.value);case"reflect":return ch(o,r.dims,s,u,n,i.pads);case"edge":return ph(o,r.dims,s,u,n,i.pads);default:throw new Error("Invalid mode")}},fh=(e,r,i,o,u,n,s)=>{let p=r.length,c="";for(let t=p-1;t>=0;--t)c+=`
        k = m[${t}] - ${n[t]};
        if (k < 0)  return constant;
        if (k >= ${r[t]}) return constant;
        offset += k * ${i[t]};
        `;return`
      float padA(int m[${p}]) {
        const float constant = float(${s});
        int offset = 0;
        int k = 0;
        ${c}
        vec2 coords = offsetToCoords(offset, ${o}, ${u});
        float value = getColorAsFloat(${e.texture2D}(A, coords));
        return value;
      }
      `},ch=(e,r,i,o,u,n)=>{let s=r.length,p="";for(let c=s-1;c>=0;--c)p+=`
        k = m[${c}] - ${n[c]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(r[c]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${r[c]}) { k = _2n_1 - k; }
        }
        offset += k * ${i[c]};
        `;return`
      float padA(int m[${s}]) {
        int offset = 0;
        int k = 0;
        ${p}
        vec2 coords = offsetToCoords(offset, ${o}, ${u});
        float value = getColorAsFloat(${e.texture2D}(A, coords));
        return value;
      }
      `},ph=(e,r,i,o,u,n)=>{let s=r.length,p="";for(let c=s-1;c>=0;--c)p+=`
        k = m[${c}] - ${n[c]};
        if (k < 0)  k = 0;
        if (k >= ${r[c]}) k = ${r[c]-1};
        offset += k * ${i[c]};
      `;return`
      float padA(int m[${s}]) {
        int offset = 0;
        int k = 0;
        ${p}
        vec2 coords = offsetToCoords(offset, ${o}, ${u});
        float value = getColorAsFloat(${e.texture2D}(A, coords));
        return value;
      }
      `}}),nl,ol,il,al,sl,ul,ll,fl,cl,dh,rl,pl,qr,dl,Hr,hh,hl=x(()=>{at(),U(),R(),nl=(e,r,i)=>{qr(r);let o={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:i.cacheKey};return[e.run({...o,get:()=>il(r,o,!1,i)},r)]},ol=e=>{let r=e.attributes.getString("auto_pad","NOTSET"),i=e.attributes.getInt("ceil_mode",0),o=e.attributes.getInt("count_include_pad",0)!==0,u=e.attributes.getInts("kernel_shape"),n=e.attributes.getInts("strides",[]),s=e.attributes.getInts("pads",[]);if(i!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return F({autoPad:r,ceilMode:i,countIncludePad:o,kernelShape:u,strides:n,pads:s})},il=(e,r,i,o)=>{let[u,n]=cl(e,o,i),s=A.size(u.kernelShape),p="value += _X(x);",c="";u.countIncludePad?c+=`value /= float(${s});`:c+=`value /= float(${s} - pad);`;let t=`
        ${dl(e[0].dims,u,p,c,"0.0")}
      `;return{...r,output:{dims:n,type:e[0].type,textureType:0},shaderSource:t}},al=(e,r,i)=>{qr(r);let o={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${i.countIncludePad}`};return[e.run({...o,get:()=>il(r,o,!0,i)},r)]},sl=e=>{let r=e.attributes.getInt("count_include_pad",0)!==0;return F({autoPad:"",ceilMode:0,countIncludePad:r,kernelShape:[],strides:[],pads:[]})},ul=(e,r,i)=>{qr(r);let o={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:i.cacheKey};return[e.run({...o,get:()=>fl(r,o,!1,i)},r)]},ll=e=>{let r=e.attributes.getString("auto_pad","NOTSET"),i=e.attributes.getInt("ceil_mode",0),o=e.attributes.getInts("kernel_shape"),u=e.attributes.getInts("strides",[]),n=e.attributes.getInts("pads",[]),s=e.attributes.getInt("storage_order",0),p=e.attributes.getInts("dilations",[]);if(s!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(i!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return F({autoPad:r,ceilMode:i,countIncludePad:!1,kernelShape:o,strides:u,pads:n,storageOrder:s,dilations:p})},fl=(e,r,i,o)=>{let[u,n]=cl(e,o,i),s=`
      value = max(_X(x), value);
    `,p="",c=`
      ${dl(e[0].dims,u,s,p,"-1e5")}
    `;return{...r,output:{dims:n,type:e[0].type,textureType:0},shaderSource:c}},cl=(e,r,i)=>{let o=e[0].dims.slice(),u=Object.hasOwnProperty.call(r,"dilations"),n=r.kernelShape.slice(),s=r.strides.slice(),p=u?r.dilations.slice():[],c=r.pads.slice();ce.adjustPoolAttributes(i,o,n,s,p,c);let t=ce.computePoolOutputShape(i,o,s,p,n,c,r.autoPad),l=Object.assign({},r);return u?Object.assign(l,{kernelShape:n,strides:s,pads:c,dilations:p,cacheKey:r.cacheKey}):Object.assign(l,{kernelShape:n,strides:s,pads:c,cacheKey:r.cacheKey}),[l,t]},dh={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},rl={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},pl=(e,r)=>(qr(r),[e.run({...rl,get:()=>fl(r,rl,!0,dh)},r)]),qr=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.")},dl=(e,r,i,o,u)=>{let n=e.length;if(r.kernelShape.length<=2){let s=r.kernelShape[r.kernelShape.length-1],p=r.strides[r.strides.length-1],c=r.pads[r.pads.length/2-1],t=r.pads[r.pads.length-1],l=e[n-1],a="",d="",h="";if(c+t!==0?a=`
          for (int i = 0; i < ${s}; i++) {
            x[${n} - 1] = indices[${n} - 1] * ${p} - ${c} + i;
            if (x[${n} - 1] < 0 || x[${n} - 1] >= ${l}) {
              pad++;
              continue;
            }
            ${i}
          }`:a=`
          for (int i = 0; i < ${s}; i++) {
            x[${n} - 1] = indices[${n} - 1] * ${p} - ${c} + i;
            ${i}
          }`,r.kernelShape.length===2){let f=r.kernelShape[r.kernelShape.length-2],g=r.strides[r.strides.length-2],y=r.pads[r.pads.length/2-2],w=r.pads[r.pads.length-2],m=e[n-2];y+w!==0?d=`
            for (int j = 0; j < ${f}; j++) {
              x[${n} - 2] = indices[${n} - 2] * ${g} - ${y} + j;
              if (x[${n} - 2] < 0 || x[${n} - 2] >= ${m}) {
                pad+= ${s};
                continue;
              }
          `:d=`
            for (int j = 0; j < ${f}; j++) {
              x[${n} - 2] = indices[${n} - 2] * ${g} - ${y} + j;
            `,h=`
          }
        `}return`
        float process(int indices[${n}]) {
          int x[${n}];
          copyVec(indices, x);

          float value = ${u};
          int pad = 0;
          ${d}
          ${a}
          ${h}
          ${o}
          return value;
        }
      `}else{let s=A.size(r.kernelShape),p=A.computeStrides(r.kernelShape),c=p.length,t=r.pads.length,l=hh(c),a=Hr(e,"inputDims"),d=Hr(r.pads,"pads"),h=Hr(p,"kernelStrides"),f=Hr(r.strides,"strides"),g=r.pads.reduce((w,m)=>w+m),y="";return g?y=`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${i}
          }`:y=`
          }
          ${i}
        `,`
        ${l}
        float process(int indices[${n}]) {
          int x[${n}];
          copyVec(indices, x);
          int offset[${c}];
          int pads[${t}];
          int inputDims[${n}];
          int kernelStrides[${c}];
          int strides[${c}];
          ${d}
          ${a}
          ${f}
          ${h}

          float value = ${u};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${s}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${n} - ${c}; j < ${n}; j++) {
              x[j] = indices[j] * strides[j - ${n} + ${c}]
                + offset[j - ${n} + ${c}] - pads[j - 2];
              ${y}
          }
          ${o}

          return value;
        }
      `}},Hr=(e,r)=>{let i="";for(let o=0;o<e.length;o++)i+=`
      ${r}[${o}] = ${e[o]};
    `;return i},hh=e=>`
  void offsetToIndices(int offset, int[${e}] strides, out int[${e}] indices) {
    if (${e} == 0) {
      return;
    }
    for (int i = 0; i < ${e} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${e} - 1] = offset;
  }`}),ye,re,mh,bh,ml,bl,gl,yl,xl,Tl,wl,vl=x(()=>{at(),rr(),U(),R(),ye=(e,r,i,o,u)=>{bh(r);let n={name:o,inputNames:["A"],inputTypes:[0]};return[e.run({...n,cacheHint:i.cacheKey,get:()=>mh(e,r,i,o,u,n)},r)]},re=e=>{let r=e.attributes.getInts("axes",[]),i=e.attributes.getInt("keepdims",1)===1;return F({axes:r,keepDims:i})},mh=(e,r,i,o,u,n)=>{let s=[],p=r[0].dims.length||1,c=[],t=A.normalizeAxes(i.axes,r[0].dims.length),l=u(r,t),a=l[1];for(let h=0;h<r[0].dims.length;h++)t.indexOf(h)>=0||t.length===0?(i.keepDims&&s.push(1),a=`
          for(int j${h} = 0; j${h} < ${r[0].dims[h]}; j${h}++) {
            inputIdx[${h}] = j${h};
            ${a}
          }`):(c.push(`inputIdx[${h}] = outputIdx[${s.length}];`),s.push(r[0].dims[h]));let d=`
      float process(int outputIdx[${s.length||1}]) {
        float value;                 // final result
        int inputIdx[${p}];      // addressing input data
        ${c.join(`
`)}
        ${l[0]}       // init ops for reduce max/min
        ${a}
        ${l[2]}       // final computation for reduce mean
        return value;
      }`;return{...n,output:{dims:s,type:r[0].type,textureType:0},shaderSource:d}},bh=e=>{if(!e||e.length!==1)throw new Error("Reduce op requires 1 input.");if(ee.indexOf(e[0].type)===-1)throw new Error("Invalid input type.")},ml=(e,r,i)=>ye(e,r,i,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),bl=(e,r,i)=>ye(e,r,i,"ReduceMean",(o,u)=>{let n=1;for(let s=0;s<o[0].dims.length;s++)(u.indexOf(s)>=0||u.length===0)&&(n*=o[0].dims[s]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${n}.;`]}),gl=(e,r,i)=>ye(e,r,i,"ReduceMax",(o,u)=>{let n=[];for(let s=0;s<o[0].dims.length;s++)(u.indexOf(s)>=0||u.length===0)&&n.push(`inputIdx[${s}] = 0;`);return[`${n.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),yl=(e,r,i)=>ye(e,r,i,"ReduceMin",(o,u)=>{let n=[];for(let s=0;s<o[0].dims.length;s++)(u.indexOf(s)>=0||u.length===0)&&n.push(`inputIdx[${s}] = 0;`);return[`${n.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),xl=(e,r,i)=>ye(e,r,i,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),Tl=(e,r,i)=>ye(e,r,i,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),wl=(e,r,i)=>ye(e,r,i,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])}),Il,_l=x(()=>{U(),Il=(e,r)=>{let i=A.calculateReshapedDims(r[0].dims,r[1].integerData);return e.session.pack?[e.reshapePacked(r[0],i)]:[e.reshapeUnpacked(r[0],i)]}}),Sl,_o,Ol,Al,nr,gh,So,jr,Oo=x(()=>{at(),X(),R(),Sl={name:"Upsample",inputNames:["X"],inputTypes:[0]},_o=(e,r,i)=>(So(r,i),[e.run({...Sl,cacheHint:i.cacheKey,get:()=>gh(e,r,i)},r)]),Ol=e=>nr(e,7),Al=e=>nr(e,9),nr=(e,r)=>{let i=r>=10,o=e.attributes.getString("mode","nearest");if(o!=="nearest"&&o!=="linear"&&(r<11||o!=="cubic"))throw new Error(`unrecognized mode: ${o}`);let u=[];r<9&&(u=e.attributes.getFloats("scales"),jr(u,o,i));let n=e.attributes.getFloat("extrapolation_value",0),s=r>10?e.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(s)===-1)throw new Error(`coordinate_transform_mode '${s}' is not supported`);let p=s==="tf_crop_and_resize",c=p,t=o==="nearest"&&r>=11?e.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(t)===-1)throw new Error(`nearest_mode '${t}' is not supported`);let l=e.attributes.getFloat("cubic_coeff_a",-.75),a=e.attributes.getInt("exclude_outside",0)!==0;if(a&&o!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let d=r<11?!0:o==="nearest"&&s==="asymmetric"&&t==="floor",h=0,f=0,g=0;return r>10?e.inputs.length>2?(h=1,f=2,g=3):(f=1,g=2):r===9&&(f=1),F({opset:r,isResize:i,mode:o,scales:u,extrapolationValue:n,coordinateTransformMode:s,useExtrapolation:c,needRoiInput:p,nearestMode:t,cubicCoefficientA:l,excludeOutside:a,useNearest2xOptimization:d,roiInputIdx:h,scalesInputIdx:f,sizesInputIdx:g})},gh=(e,r,i)=>{let o=D(e.session.backend.glContext.version),[u,n]=e.calculateTextureWidthAndHeight(r[0].dims,0),s=r[0].dims.map((g,y)=>Math.floor(g*i.scales[y])),[p,c]=e.calculateTextureWidthAndHeight(s,0),t=s.length,l=new Array(t),a=new Array(t),d=`
      int output_pitches[${t}];
      int input_pitches[${t}];
      `;for(let g=t-1;g>=0;g--)l[g]=g===t-1?1:l[g+1]*s[g+1],a[g]=g===t-1?1:a[g+1]*r[0].dims[g+1],d+=`
        output_pitches[${g}] = ${l[g]};
        input_pitches[${g}] = ${a[g]};
        `;let h=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${u}, ${n});
        float value = getColorAsFloat(${o.texture2D}(X, coords));
        return value;
      }
      `,f=i.mode==="nearest"?`
    ${h}
    float process(int indices[${t}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${p}, ${c});

      ${d}

      int d, m;
      for (int dim = 0; dim < ${t}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:t===4?`
    ${h}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${p}, ${c});

      ${d}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${r[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${h}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${p}, ${c});

      ${d}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${r[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return{...Sl,output:{dims:s,type:r[0].type,textureType:0},shaderSource:f,variables:[{name:"scales",type:"int",arrayLength:i.scales.length,data:i.scales.map(g=>Math.ceil(g))}]}},So=(e,r)=>{if(!e||r.opset<9&&e.length!==1||r.opset>=9&&r.opset<11&&e.length!==2||r.opset>=11&&e.length<2)throw new Error("invalid inputs.");if(r.scales.length>0&&e[0].dims.length!==r.scales.length)throw new Error("Invalid input shape.");if(e[0].type==="string")throw new Error("Invalid input tensor types.")},jr=(e,r,i)=>{if(i){for(let o of e)if(o<=0)throw new Error("Scale value should be greater than 0.")}else for(let o of e)if(o<1)throw new Error("Scale value should be greater than or equal to 1.");if((r==="linear"||r==="cubic")&&e.length!==2&&(e.length!==4||e[0]!==1||e[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${i?"Resize":"Upsample"} opeartor.`)}}),Ao,Po,Pl,El,yh,xh,Th,wh,Dl=x(()=>{X(),R(),Mt(),me(),Oo(),Ao={name:"Resize",inputNames:["A"],inputTypes:[2]},Po=(e,r,i)=>(So(r,i),[e.run({...Ao,cacheHint:i.cacheKey,get:()=>yh(e,r,i)},r)]),Pl=e=>nr(e,10),El=e=>nr(e,11),yh=(e,r,i)=>{let o=D(e.session.backend.glContext.version),[u,n]=xh(r,i);if(u.every(m=>m===1)&&i.coordinateTransformMode!=="tf_crop_and_resize")return{...Ao,output:{dims:n,type:r[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${o.texture2D}(X, TexCoords);
                    ${o.output} = v;
                }`};let s=n.length;if(s<2)throw new Error(`output dimension should be at least 2, but got ${s}`);let p=n[s-2],c=n[s-1],t=r[0].dims;if(s!==t.length)throw new Error(`output dimension should match input ${t.length}, but got ${s}`);let l=t[s-2],a=t[s-1],d=u[s-2],h=u[s-1],f="";if(i.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${i.mode}'`);switch(i.coordinateTransformMode){case"asymmetric":f=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":f=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":f=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${c}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${p}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${c}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${p}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":f=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${c}.0 - 1.0, ${p}.0 - 1.0, ${c}.0 - 1.0,
                            ${p}.0 - 1.0);
                        vec4 original = vec4(${a}.0 - 1.0, ${l}.0 - 1.0, ${a}.0 - 1.0,
                            ${l}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${i.coordinateTransformMode}'`)}let g=pt(s),y=Vt(),w=`
            const vec2 inputWH = vec2(${l}.0, ${a}.0);
            const vec4 scaleWHWH = vec4(float(${d}), float(${h}), float(${d}), float(${h}));
            ${y}
            ${f}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${g} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${p-1};
                bool hasNextCol = rc.z < ${c-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${o.output} = vec4(newValue);
            }
        `;return{...Ao,output:{dims:n,type:r[0].type,textureType:2},hasMain:!0,shaderSource:w}},xh=(e,r)=>{let i=e[0].dims,o=r.scales,u;if(o.length===0){let s=e[r.scalesInputIdx];if(s&&s.size!==0){if(e[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");o=Th(s,r.mode,r.isResize)}else{let p=e[r.sizesInputIdx];if(!p||p.size===0)throw new Error("Either scales or sizes MUST be provided as input.");u=Array.from(p.integerData),o=wh(u,i,r.mode,r.isResize)}}else if(e[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let n=u||i.map((s,p)=>Math.floor(s*o[p]));return[o,n]},Th=(e,r,i)=>{let o=Array.from(e.floatData);return jr(o,r,i),o},wh=(e,r,i,o)=>{let u=r.length,n=new Array(u);for(let s=0,p=u;s<p;s++)if(r[s]===0){if(e[s]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");n[s]=1}else n[s]=e[s]/r[s];return jr(n,i,o),n}}),Ll,vh,$l=x(()=>{he(),Ll=(e,r)=>(vh(r),[new et([r[0].dims.length],"int32",void 0,void 0,new Int32Array(r[0].dims))]),vh=e=>{if(!e||e.length!==1)throw new Error("Shape requires 1 input.")}}),Eo,kl,Bl,Fl,Ih,Nl,_h,Sh,Cl=x(()=>{at(),rr(),U(),R(),Eo={name:"Slice",inputNames:["A"],inputTypes:[0]},kl=(e,r,i)=>(Ih(r),[e.run({...Eo,cacheHint:i.cacheKey,get:()=>Fl(e,r[0],i)},r)]),Bl=e=>{let r=e.attributes.getInts("starts"),i=e.attributes.getInts("ends"),o=e.attributes.getInts("axes",[]);return F({starts:r,ends:i,axes:o})},Fl=(e,r,i)=>{let o=i.axes.length===0?r.dims.slice(0).map((l,a)=>a):i.axes,u=A.normalizeAxes(o,r.dims.length),n=i.starts.map((l,a)=>l>r.dims[u[a]]-1?r.dims[u[a]]:A.normalizeAxis(l,r.dims[u[a]])),s=i.ends.map((l,a)=>l>r.dims[u[a]]-1?r.dims[u[a]]:A.normalizeAxis(l,r.dims[u[a]])),p=r.dims.slice(),c=[];for(let l=0;l<u.length;l++)p[u[l]]=s[l]-n[l],n[l]>0&&c.push(`outputIdx[${u[l]}] += ${n[l]};`);let t=`
      float process(int outputIdx[${p.length}]) {
        ${c.join(`
      `)}
        return _A(outputIdx);
      }`;return{...Eo,output:{dims:p,type:r.type,textureType:0},shaderSource:t}},Ih=e=>{if(!e||e.length!==1)throw new Error("Slice requires 1 input.");if(ee.indexOf(e[0].type)===-1)throw new Error("Invalid input type.")},Nl=(e,r)=>{Sh(r);let i=_h(e,r);return[e.run({...Eo,cacheHint:i.cacheKey,get:()=>Fl(e,r[0],i)},[r[0]])]},_h=(e,r)=>{if(!e.session.isInitializer(r[1].dataId)||!e.session.isInitializer(r[2].dataId)||r.length>=4&&!e.session.isInitializer(r[3].dataId)||r.length>=5&&!e.session.isInitializer(r[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(r.length>=5&&r[4].integerData.some(s=>s!==1))throw new Error("currently non-1 steps is not supported for Slice");let i=Array.from(r[1].integerData),o=Array.from(r[2].integerData),u=r.length>=4?Array.from(r[3].integerData):[],n=`${u};${i};${o}`;return{starts:i,ends:o,axes:u,cacheKey:n}},Sh=e=>{if(!e||e.length<3||e.length>5)throw new Error("Invalid input number.");if(e[1].type!=="int32"||e[1].dims.length!==1)throw new Error("Invalid input type.");if(e[2].type!=="int32"||e[2].dims.length!==1)throw new Error("Invalid input type.");if(e.length>=4&&(e[3].type!=="int32"||e[3].dims.length!==1))throw new Error("Invalid input type.");if(e.length>=5&&(e[4].type!=="int32"||e[4].dims.length!==1))throw new Error("Invalid input type.")}}),Rl,Gl,Ml,Vl,Ul,zl,Wl,Hl,Oh,Ah,Ph,ql,jl=x(()=>{at(),U(),X(),R(),Wr(),Rl={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},Gl={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},Ml={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},Vl=(e,r,i)=>{ql(r);let o=r[0].dims.slice(),u=A.normalizeAxis(i.axis,o.length),n=A.sizeToDimension(o,u),s=A.sizeFromDimension(o,u);return Hl(e,r,i,n,s)},Ul=e=>F({axis:e.attributes.getInt("axis",1)}),zl=e=>F({axis:e.attributes.getInt("axis",-1)}),Wl=(e,r,i)=>{ql(r);let o=r[0].dims.slice(),u=A.normalizeAxis(i.axis,o.length),n=o.length,s=u!==n-1,p=[],c=[],t=[],l;s&&(c=Array.from({length:n}).map((f,g)=>g),c[u]=n-1,c[n-1]=u,c.map(f=>p.push(o[f])),l=F({perm:c}),t=ge(e,r,l));let a=s?A.sizeToDimension(p,n-1):A.sizeToDimension(o,n-1),d=s?A.sizeFromDimension(p,n-1):A.sizeFromDimension(o,n-1),h=Hl(e,s?t:r,i,a,d);return s?ge(e,h,l):h},Hl=(e,r,i,o,u)=>{let n=Oh(e,r[0],o,u,[o]),s=e.run({...Rl,cacheHint:i.cacheKey,get:()=>n},r),p=Ah(e,r[0],o,u,n.output.dims,[o]),c=e.run({...Gl,cacheHint:i.cacheKey,get:()=>p},[r[0],s]),t=Ph(e,r[0],o,u,n.output.dims,p.output.dims);return[e.run({...Ml,cacheHint:i.cacheKey,get:()=>t},[r[0],s,c])]},Oh=(e,r,i,o,u)=>{let[n,s]=e.calculateTextureWidthAndHeight(r.dims,0),p=u.length;if(i<1||o<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(u.length!==1)throw new Error("Dimensionality of the output should be 1");if(u[0]!==i)throw new Error("Shape of the output should be equal to logical row count");let c=D(e.session.backend.glContext.version),t=`
      float process(int[${p}] indices) {
        int logical_row_start_offset = indices[0] * ${o};

        float max = getColorAsFloat(${c.texture2D}(A, offsetToCoords(logical_row_start_offset, ${n},
        ${s} )));
        for(int i=1; i<${o}; ++i)
        {
          float current = getColorAsFloat(${c.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${n}, ${s})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return{...Rl,output:{dims:u,type:r.type,textureType:0},shaderSource:t}},Ah=(e,r,i,o,u,n)=>{let[s,p]=e.calculateTextureWidthAndHeight(r.dims,0),c=n.length;if(i<1||o<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(n.length!==1)throw new Error("Dimensionality of the output should be 1");if(n[0]!==i)throw new Error("Shape of the output should be equal to logical row count");if(u.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(u[0]!==i)throw new Error("Shape of the intermediate results should be equal to logical row count");let t=D(e.session.backend.glContext.version),l=`
      float process(int[${c}] indices) {
        int logical_row_start_offset = indices[0] * ${o};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${o}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${t.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${s}, ${p}))) - max);
        }

        return norm_factor;
      }`;return{...Gl,output:{dims:n,type:r.type,textureType:0},shaderSource:l}},Ph=(e,r,i,o,u,n)=>{let[s,p]=e.calculateTextureWidthAndHeight(r.dims,0),c=r.dims.length;if(i<1||o<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(u.length!==1||n.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(u[0]!==i||n[0]!==i)throw new Error("Shape of the intermediate results should be equal to logical row count");let t=`
      float process(int[${c}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${s}, ${p});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${o};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return{...Ml,output:{dims:r.dims,type:r.type,textureType:0},shaderSource:t}},ql=e=>{if(!e||e.length!==1)throw new Error("Softmax requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type")}}),Xl,Kl,Jl,Eh,Dh,Lh,Zl=x(()=>{at(),U(),R(),Xl={name:"Split",inputNames:["A"],inputTypes:[0]},Kl=(e,r,i)=>{Lh(r);let o=A.normalizeAxis(i.axis,r[0].dims.length),u=Eh(e,r,o,i),n=[];for(let s=0;s<u;++s)n.push(e.run({...Xl,cacheHint:`${i.cacheKey};${s}`,get:()=>Dh(e,r[0],i,o,s)},r));return n},Jl=e=>{let r=e.attributes.getInt("axis",0),i=e.attributes.getInts("split",[]),o=e.outputs.length;return F({axis:r,split:i,numOutputs:o})},Eh=(e,r,i,o)=>{let[,u]=Je.splitShape(r[0].dims,i,o.split,o.numOutputs);return u.length},Dh=(e,r,i,o,u)=>{let[n,s]=Je.splitShape(r.dims,o,i.split,i.numOutputs),p=s[u],c=n[u],t=`
      float process(int indices[${c.length}]) {
        indices[${o}] += ${p};
        return _A(indices);
      }
    `;return{...Xl,cacheHint:`${i.cacheKey}:${u}`,output:{dims:c,type:r.type,textureType:0},shaderSource:t}},Lh=e=>{if(!e||e.length!==1)throw new Error("Split requires one input.");if(e[0].type!=="int8"&&e[0].type!=="uint8"&&e[0].type!=="int16"&&e[0].type!=="uint16"&&e[0].type!=="int32"&&e[0].type!=="uint32"&&e[0].type!=="float32"&&e[0].type!=="float64"&&e[0].type!=="bool")throw new Error("Invalid input type.")}}),Do,Yl,Ql,$h,kh,tf=x(()=>{U(),Do=(e,r,i)=>{$h(r);let o=A.squeezeShape(r[0].dims,i);return[e.reshapeUnpacked(r[0],o)]},Yl=(e,r)=>(kh(r),Do(e,[r[0]],Array.from(r[1].integerData))),Ql=e=>e.attributes.getInts("axes"),$h=e=>{if(!e||e.length!==1)throw new Error("Squeeze requires 1 input.");if(e[0].type==="string")throw new Error("invalid input tensor types.")},kh=e=>{if(!e||e.length!==2)throw new Error("Squeeze requires 2 inputs.");if(e[1].type!=="int32")throw new Error("Invalid input type.")}}),ef,Bh,Fh,rf=x(()=>{X(),R(),ef=(e,r)=>{Fh(r);let i={name:"Sum",inputNames:r.map((o,u)=>`X${u}`),inputTypes:new Array(r.length).fill(0)};return[e.run({...i,get:()=>Bh(e,r,i)},r)]},Bh=(e,r,i)=>{let o=D(e.session.backend.glContext.version),u=r[0].dims.slice(),n=`
      void main() {
        vec4 result = ${r.map((s,p)=>`${o.texture2D}(X${p},TexCoords)`).join(" + ")};
        ${o.output} = result;
      }
    `;return{...i,output:{dims:u,type:r[0].type,textureType:0},hasMain:!0,shaderSource:n}},Fh=e=>{if(!e||e.length===0)throw new Error("Sum requires inputs.");let r=e[0].dims.length;for(let i=1;i<e.length;i++){if(r!==e[i].dims.length)throw new Error("Input shapes are mismatched.");for(let o=0;o<r;o++)if(e[0].dims[o]!==e[i].dims[o])throw new Error("Input shapes are not matched.")}if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.");for(let i=1;i<e.length;i++)if(e[0].type!==e[i].type)throw new Error("Input types are not matched.")}}),nf,Nh,Ch,of=x(()=>{rr(),R(),nf=(e,r)=>{Ch(r);let i={name:"Tile",inputNames:["A"],inputTypes:[0]};return[e.run({...i,get:()=>Nh(e,r,i)},r)]},Nh=(e,r,i)=>{let o=r[0].dims.slice(),u=new Array(o.length),n=[];for(let c=0;c<o.length;c++)u[c]=o[c]*r[1].numberData[c],n.push(`inputIdx[${c}] = int(mod(float(outputIdx[${c}]), ${o[c]}.));`);let s=u.length,p=`
      float process(int outputIdx[${s}]) {
        int inputIdx[${s}];
        ${n.join(`
`)}
        return _A(inputIdx);
      }
    `;return{...i,output:{dims:u,type:r[0].type,textureType:0},shaderSource:p}},Ch=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 input.");if(e[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(e[1].dims[0]!==e[0].dims.length)throw new Error("Invalid input shape.");if(ee.indexOf(e[0].type)===-1)throw new Error("Invalid input type.");if(e[1].type!=="int32"&&e[1].type!=="int16")throw new Error("Invalid repeat type.")}}),Lo,af,sf,Rh,Gh,uf=x(()=>{U(),Lo=(e,r,i)=>{Rh(r);let o=A.unsqueezeShape(r[0].dims,i);return[e.reshapeUnpacked(r[0],o)]},af=(e,r)=>(Gh(r),Lo(e,[r[0]],Array.from(r[1].integerData))),sf=e=>e.attributes.getInts("axes"),Rh=e=>{if(!e||e.length!==1)throw new Error("Unsqueeze requires 1 input.");if(e[0].type==="string")throw new Error("invalid input tensor types.")},Gh=e=>{if(!e||e.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(e[1].type!=="int32")throw new Error("Invalid input type.")}}),lf,ff=x(()=>{xs(),$s(),Fs(),Vs(),Vr(),_u(),Du(),ku(),Nu(),Mu(),zu(),ju(),Zu(),Ur(),el(),hl(),vl(),_l(),Dl(),$l(),Cl(),jl(),Zl(),tf(),rf(),of(),Wr(),ho(),uf(),Oo(),lf=[["Abs","","6+",Us],["Acos","","7+",zs],["Add","","7+",Ts],["And","","7+",ws],["Asin","","7+",Ws],["Atan","","7+",Hs],["AveragePool","","7+",nl,ol],["BatchNormalization","","7+",gs,ys],["Cast","","6+",ks,Bs],["Ceil","","6+",Xs],["Clip","","6-10",co,qs],["Clip","","11+",js],["Concat","","4+",Rs,Ms],["Conv","","1+",To,wo],["ConvTranspose","","1+",vu,Iu],["Cos","","7+",Ks],["Div","","7+",vs],["Dropout","","7+",po],["DepthToSpace","","1+",Pu,Eu],["Equal","","7+",Is],["Elu","","6+",Js,Zs],["Exp","","6+",Ys],["Flatten","","1+",Lu,$u],["Floor","","6+",Qs],["FusedConv","com.microsoft","1+",To,wo],["Gather","","1+",Bu,Fu],["Gemm","","7-10",vo,Ru],["Gemm","","11+",vo,Gu],["GlobalAveragePool","","1+",al,sl],["GlobalMaxPool","","1+",pl],["Greater","","7+",_s],["Identity","","1+",po],["ImageScaler","","1+",Vu,Uu],["InstanceNormalization","","6+",Hu,qu],["LeakyRelu","","6+",tu,eu],["Less","","7+",Ss],["LRN","","1+",Xu,Ku],["Log","","6+",ru],["MatMul","","1+",mu,bu],["MaxPool","","1+",ul,ll],["Mul","","7+",Os],["Neg","","6+",nu],["Not","","1+",ou],["Or","","7+",As],["Pad","","2-10",Io,Yu],["Pad","","11+",Qu,tl],["Pow","","7+",Ps],["PRelu","","7+",Es],["ReduceLogSum","","1+",Tl,re],["ReduceMax","","1+",gl,re],["ReduceMean","","1+",bl,re],["ReduceMin","","1+",yl,re],["ReduceProd","","1+",xl,re],["ReduceSum","","1-12",ml,re],["ReduceSumSquare","","1+",wl,re],["Relu","","6+",iu],["Reshape","","5+",Il],["Resize","","10",Po,Pl],["Resize","","11+",Po,El],["Shape","","1+",Ll],["Sigmoid","","6+",au],["Sin","","7+",su],["Slice","","10+",Nl],["Slice","","1-9",kl,Bl],["Softmax","","1-12",Vl,Ul],["Softmax","","13+",Wl,zl],["Split","","2-12",Kl,Jl],["Sqrt","","6+",uu],["Squeeze","","1-12",Do,Ql],["Squeeze","","13+",Yl],["Sub","","7+",Ds],["Sum","","6+",ef],["Tan","","7+",lu],["Tanh","","6+",fu],["Tile","","6+",nf],["Transpose","","1+",ge,Ou],["Upsample","","7-8",_o,Ol],["Upsample","","9",_o,Al],["Unsqueeze","","1-12",Lo,sf],["Unsqueeze","","13+",af],["Xor","","7+",Ls]]});function pf(e){let r={},i;for(;(i=cf.exec(e))!==null;){let o=i[3].split(",").map(u=>{let n=u.trim().split(" ");return n&&n.length===2?{type:n[0],name:n[1]}:null}).filter(u=>u!==null);r[i[2]]={params:o,body:i[4]}}for(let o in r){let u=Mh.replace("__FUNC__",o),n=new RegExp(u,"gm");for(;(i=n.exec(e))!==null;){let s=i[1],p=i[2],c=i[3].split(","),t=s?`${s} ${p};`:"",l=r[o].body,a="";r[o].params.forEach((h,f)=>{h&&(a+=`${h.type} ${h.name} = ${c[f]};
`)}),l=`${a}
 ${l}`,l=l.replace("return",`${p} = `);let d=`
      ${t}
      {
        ${l}
      }
      `;e=e.replace(i[0],d)}}return e=e.replace(cf,""),e}var cf,Mh,df=x(()=>{cf=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,Mh="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"});function Be(e,r){let i=[],o=[];for(let u=0;u<e.length;++u)e[u]!==1&&(i.push(e[u]),o.push(u));return{newShape:i,keptDims:o}}function zh(e){if(e.length===0)return 1;let r=e[0];for(let i=1;i<e.length;i++)r*=e[i];return r}function hf(e){let r=Math.ceil(Math.sqrt(e));return[r,Math.ceil(e/r)]}var Xr,$o=x(()=>{vt(),U(),Xr=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,r){let i=this.computeTexture(e,r);return r&&r.isPacked&&(i[0]/=2,i[1]/=2),r&&r.reverseWH?[i[1],i[0]]:i}computeTexture(e,r){let i=r&&r.isPacked;if(e.length===0)return i?[2,2]:[1,1];let o=this.maxTextureSize;if(r&&r.breakAxis!==void 0){let s=r.breakAxis>=e.length?1:e.slice(r.breakAxis).reduce((c,t)=>c*t),p=r.breakAxis<=0?1:e.slice(0,r.breakAxis).reduce((c,t)=>c*t);if(s>o||p>o)z.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${r.breakAxis}`);else return[s,p]}let u=e.slice(0);i&&(o=o*2,u=u.map((s,p)=>p>=u.length-2?u[p]%2===0?u[p]:u[p]+1:u[p]),u.length===1&&(u=[2,u[0]])),u.length!==2&&(u=Be(u).newShape);let n=zh(u);return u.length<=1&&n<=o?[1,n]:u.length===2&&u[0]<=o&&u[1]<=o?u:u.length===3&&u[0]*u[1]<=o&&u[2]<=o?[u[0]*u[1],u[2]]:u.length===3&&u[0]<=o&&u[1]*u[2]<=o?[u[0],u[1]*u[2]]:u.length===4&&u[0]*u[1]*u[2]<=o&&u[3]<=o?[u[0]*u[1]*u[2],u[3]]:u.length===4&&u[0]<=o&&u[1]*u[2]*u[3]<=o?[u[0],u[1]*u[2]*u[3]]:i?hf(n/4).map(s=>s*2):hf(n)}}}),Kr,mf=x(()=>{U(),Xt(),X(),$o(),Mt(),Kr=class extends Ot{constructor(e){super(e)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){let e="offsetToCoords";return{offsetToCoords:new O(`
      vec2 ${e}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){let e="coordsToOffset";return{coordsToOffset:new O(`
      int ${e}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let e=this.context.outputTextureLayout;return e.isPacked?this.getPackedOutputSamplingSnippet(e):this.getUnpackedOutputSamplingSnippet(e)}getPackedOutputSamplingSnippet(e){let r=e.unpackedShape,i=[e.width,e.height],o={},u="getOutputCoords";switch(r.length){case 0:o[u]=this.getOutputScalarCoords();break;case 1:o[u]=this.getOutputPacked1DCoords(r,i);break;case 2:o[u]=this.getOutputPacked2DCoords(r,i);break;case 3:o[u]=this.getOutputPacked3DCoords(r,i);break;default:o[u]=this.getOutputPackedNDCoords(r,i)}let n=`
      void setOutput(vec4 val) {
        ${D(this.context.glContext.version).output} = val;
      }
    `,s="floatTextureSetRGBA";return o[s]=new O(n),o}getUnpackedOutputSamplingSnippet(e){let r=e.unpackedShape,i=[e.width,e.height],o={},u="getOutputCoords";switch(r.length){case 0:o[u]=this.getOutputScalarCoords();break;case 1:o[u]=this.getOutputUnpacked1DCoords(r,i);break;case 2:o[u]=this.getOutputUnpacked2DCoords(r,i);break;case 3:o[u]=this.getOutputUnpacked3DCoords(r,i);break;case 4:o[u]=this.getOutputUnpacked4DCoords(r,i);break;case 5:o[u]=this.getOutputUnpacked5DCoords(r,i);break;case 6:o[u]=this.getOutputUnpacked6DCoords(r,i);break;default:throw new Error(`Unsupported output dimensionality: ${r.length}`)}let n=`
        void setOutput(float val) {
          ${D(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `,s="floatTextureSetR";return o[s]=new O(n),o}getOutputScalarCoords(){return new O(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(e,r){let i=r,o="";return i[0]===1?(o=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${i[1]}.0);
          }
        `,new O(o)):i[1]===1?(o=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${i[0]}.0);
          }
        `,new O(o)):(o=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${i[0]}, ${i[1]}));
          return 2 * (resTexRC.y * ${i[0]} + resTexRC.x);
        }
      `,new O(o))}getOutputPacked2DCoords(e,r){let i="";if(fe.arraysEqual(e,r))return i=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${r[0]}, ${r[1]}));
        }
      `,new O(i);let o=r,u=Math.ceil(e[1]/2);return i=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o[0]}, ${o[1]}));

          int index = resTexRC.y * ${o[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${u}) * 2;
          int c = 2 * (index / ${u});

          return ivec2(r, c);
        }
      `,new O(i)}getOutputPacked3DCoords(e,r){let i=[r[0],r[1]],o=Math.ceil(e[2]/2),u=o*Math.ceil(e[1]/2),n=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i[0]}, ${i[1]}));
          int index = resTexRC.y * ${i[0]} + resTexRC.x;

          int b = index / ${u};
          index -= b * ${u};

          // reverse r and c order for packed texture
          int r = imod(index, ${o}) * 2;
          int c = 2 * (index / ${o});

          return ivec3(b, r, c);
        }
      `;return new O(n)}getOutputPackedNDCoords(e,r){let i=[r[0],r[1]],o=Math.ceil(e[e.length-1]/2),u=o*Math.ceil(e[e.length-2]/2),n=u,s="",p="b, r, c";for(let t=2;t<e.length-1;t++)n*=e[e.length-t-1],s=`
      int b${t} = index / ${n};
      index -= b${t} * ${n};
    `+s,p=`b${t}, `+p;let c=`
      ivec${e.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${i[0]}, ${i[1]}));
        int index = resTexRC.y * ${i[0]} + resTexRC.x;

        ${s}

        int b = index / ${u};
        index -= b * ${u};

        // reverse r and c order for packed texture
        int r = imod(index, ${o}) * 2;
        int c = 2 * (index / ${o});

        return ivec${e.length}(${p});
      }
    `;return new O(c)}getOutputUnpacked1DCoords(e,r){let i=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          return resTexRC.y * ${r[0]} + resTexRC.x;
        }
      `;return new O(i)}getOutputUnpacked2DCoords(e,r){let i=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          int r = index / ${e[1]};
          int c = index - r * ${e[1]};
          return ivec2(r, c);
        }
      `;return new O(i)}getOutputUnpacked3DCoords(e,r){let i="",o=e.length,u=null;o<2&&(u=[]),u=new Array(o-1),u[o-2]=e[o-1];for(let p=o-3;p>=0;--p)u[p]=u[p+1]*e[p+1];let n=["r","c","d"],s=u.map((p,c)=>{let t=`int ${n[c]} = index / ${p}`,l=c===u.length-1?`int ${n[c+1]} = index - ${n[c]} * ${p}`:`index -= ${n[c]} * ${p}`;return`${t}; ${l};`}).join("");return i=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${s}
          return ivec3(r, c, d);
        }
      `,new O(i)}getOutputUnpacked4DCoords(e,r){let i="",o=e.length,u=null;o<2&&(u=[]),u=new Array(o-1),u[o-2]=e[o-1];for(let p=o-3;p>=0;--p)u[p]=u[p+1]*e[p+1];let n=["r","c","d","d2"],s=u.map((p,c)=>{let t=`int ${n[c]} = index / ${p}`,l=c===u.length-1?`int ${n[c+1]} = index - ${n[c]} * ${p}`:`index -= ${n[c]} * ${p}`;return`${t}; ${l};`}).join("");return i=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${s}
          return ivec4(r, c, d, d2);
        }
      `,new O(i)}getOutputUnpacked5DCoords(e,r){let i="",o=e.length,u=null;o<2&&(u=[]),u=new Array(o-1),u[o-2]=e[o-1];for(let p=o-3;p>=0;--p)u[p]=u[p+1]*e[p+1];let n=["r","c","d","d2","d3"],s=u.map((p,c)=>{let t=`int ${n[c]} = index / ${p}`,l=c===u.length-1?`int ${n[c+1]} = index - ${n[c]} * ${p}`:`index -= ${n[c]} * ${p}`;return`${t}; ${l};`}).join("");return i=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${r[0]}, ${r[1]}));
          int index = resTexRC.y * ${r[0]} + resTexRC.x;
          ${s}
          return ivec5(r, c, d, d2, d3);
        }
      `,new O(i)}getOutputUnpacked6DCoords(e,r){let i="",o=e.length,u=null;o<2&&(u=[]),u=new Array(o-1),u[o-2]=e[o-1];for(let p=o-3;p>=0;--p)u[p]=u[p+1]*e[p+1];let n=["r","c","d","d2","d3","d4"],s=u.map((p,c)=>{let t=`int ${n[c]} = index / ${p}`,l=c===u.length-1?`int ${n[c+1]} = index - ${n[c]} * ${p}`:`index -= ${n[c]} * ${p}`;return`${t}; ${l};`}).join("");return i=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${r[0]}, ${r[1]}));
         int index = resTexRC.y * ${r[0]} + resTexRC.x;
         ${s}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new O(i)}getCommonUtilFuncs(){let e={},r="uvFromFlat";e[r]=new O(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),r="packedUVfrom1D",e[r]=new O(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),r="packedUVfrom2D",e[r]=new O(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),r="packedUVfrom3D",e[r]=new O(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),r="sampleTexture";let i=D(this.context.glContext.version);return e[r]=new O(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${i.texture2D}(textureSampler, uv).r;
        }`),e}getInputsSamplingSnippets(){let e={},r=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((i,o)=>{let u=this.context.inputTextureLayouts[o],n=Br(i);u.isPacked?e[n]=this.getPackedSamplerFromInput(n,i,u):e[n]=this.getUnpackedSamplerFromInput(n,i,u);let s=es(i);u.unpackedShape.length<=r.unpackedShape.length&&(u.isPacked?e[s]=this.getPackedSamplerAtOutputCoords(s,u,r,i):e[s]=this.getUnpackedSamplerAtOutputCoords(s,u,r,i))}),e}getPackedSamplerAtOutputCoords(e,r,i,o){let u=r.unpackedShape,n=i.unpackedShape,s=Br(o),p=u.length,c=n.length,t=ct.getBroadcastDims(u,n),l=pt(c),a=c-p,d,h=Rt();p===0?d="":c<2&&t.length>=1?d="coords = 0;":d=t.map(T=>`coords.${h[T+a]} = 0;`).join(`
`);let f="";c<2&&p>0?f="coords":f=u.map((T,_)=>`coords.${h[_+a]}`).join(", ");let g="return outputValue;",y=A.size(u)===1,w=A.size(n)===1;if(p===1&&!y&&!w)g=`
        return vec4(outputValue.xy, outputValue.xy);
      `;else if(y&&!w)c===1?g=`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:g=`
          return vec4(outputValue.x);
        `;else if(t.length){let T=p-2,_=p-1;t.indexOf(T)>-1&&t.indexOf(_)>-1?g="return vec4(outputValue.x);":t.indexOf(T)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":t.indexOf(_)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}let m=`
        int lastDim = coords.${h[c-1]};
        coords.${h[c-1]} = coords.${h[c-2]};
        coords.${h[c-2]} = lastDim;
      `,v=`
      vec4 ${e}() {
        ${l} coords = getOutputCoords();
        ${m}
        ${d}
        vec4 outputValue = ${s}(${f});
        ${g}
      }
    `;return new O(v,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(e,r,i,o){let u=[i.width,i.height],n=[r.width,r.height],s=r.unpackedShape.length,p=i.unpackedShape.length,c=r.unpackedShape,t=i.unpackedShape,l=Br(o);if(s===p&&fe.arraysEqual(n,u)){let m=`
          float ${e}() {
            return sampleTexture(${o}, TexCoords);
          }
        `;return new O(m,["coordinates.sampleTexture"])}let a=pt(p),d=ct.getBroadcastDims(c,t),h=p-s,f,g=Rt();s===0?f="":p<2&&d.length>=1?f="coords = 0;":f=d.map(m=>`coords.${g[m+h]} = 0;`).join(`
`);let y="";p<2&&s>0?y="coords":y=r.unpackedShape.map((m,v)=>`coords.${g[v+h]}`).join(", ");let w=`
        float ${e}() {
          ${a} coords = getOutputCoords();
          ${f}
          return ${l}(${y});
        }
      `;return new O(w,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(e,r,i){switch(i.unpackedShape.length){case 0:return this.getPackedSamplerScalar(e,r);case 1:return this.getPackedSampler1D(e,r,i);case 2:return this.getPackedSampler2D(e,r,i);case 3:return this.getPackedSampler3D(e,r,i);default:return this.getPackedSamplerND(e,r,i)}}getUnpackedSamplerFromInput(e,r,i){let o=i.unpackedShape;switch(o.length){case 0:return this.getUnpackedSamplerScalar(e,r,i);case 1:return this.getUnpackedSampler1D(e,r,i);case 2:return this.getUnpackedSampler2D(e,r,i);case 3:return this.getUnpackedSampler3D(e,r,i);case 4:return this.getUnpackedSampler4D(e,r,i);case 5:return this.getUnpackedSampler5D(e,r,i);case 6:return this.getUnpackedSampler6D(e,r,i);default:throw new Error(`Unsupported dimension ${o.length}-D`)}}getPackedSamplerScalar(e,r){let i=D(this.context.glContext.version),o=`
          vec4 ${e}() {
            return ${i.texture2D}(${r}, halfCR);
          }
        `;return new O(o)}getPackedSampler1D(e,r,i){let o=[i.width,i.height],u=[o[1],o[0]],n=D(this.context.glContext.version),s=`vec4 ${e}(int index) {
      vec2 uv = packedUVfrom1D(
      ${u[0]}, ${u[1]}, index);
      return ${n.texture2D}(${r}, uv);
    }`;return new O(s,["coordinates.packedUVfrom1D"])}getPackedSampler2D(e,r,i){let o=i.unpackedShape,u=[i.width,i.height],n=D(this.context.glContext.version),s=u[0],p=u[1];if(u!=null&&fe.arraysEqual(o,u)){let a=`vec4 ${e}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${s}.0);
        return ${n.texture2D}(${r}, uv);
      }`;return new O(a)}let c=u,t=Math.ceil(o[1]/2),l=`vec4 ${e}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c[1]}, ${c[0]}, ${t}, row, col);
      return ${n.texture2D}(${r}, uv);
    }`;return new O(l,["coordinates.packedUVfrom2D"])}getPackedSampler3D(e,r,i){let o=i.unpackedShape,u=[i.width,i.height],n=[u[0],u[1]],s=D(this.context.glContext.version);if(o[0]===1){let d=o.slice(1),h=[1,2],f=Ee(o,d),g=["b","row","col"],y=JSON.parse(JSON.stringify(i));y.unpackedShape=f;let w=this.getPackedSamplerFromInput(e,r,y),m=`${w.routineBody}
      vec4 ${e}(int b, int row, int col) {
        return ${e}(${De(g,h)});
      } `;return new O(m,w.dependencies)}let p=n[0],c=n[1],t=Math.ceil(o[2]/2),l=t*Math.ceil(o[1]/2),a=`vec4 ${e}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${p}, ${l}, ${t}, b, row, col);
      return ${s.texture2D}(${r}, uv);}`;return new O(a,["coordinates.packedUVfrom3D"])}getPackedSamplerND(e,r,i){let o=i.unpackedShape,u=o.length,n=[i.width,i.height],s=D(this.context.glContext.version),p=[n[0],n[1]],c=p[1],t=p[0],l=Math.ceil(o[u-1]/2),a=l*Math.ceil(o[u-2]/2),d="int b, int row, int col",h=`b * ${a} + (row / 2) * ${l} + (col / 2)`;for(let g=2;g<u-1;g++)d=`int b${g}, `+d,a*=o[u-g-1],h=`b${g} * ${a} + `+h;let f=`vec4 ${e}(${d}) {
      int index = ${h};
      int texR = index / ${t};
      int texC = index - texR * ${t};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${t}, ${c});
      return ${s.texture2D}(${r}, uv);
    }`;return new O(f)}getUnpackedSamplerScalar(e,r,i){let[o,u]=[i.width,i.height];if(o===1&&u===1){let s=`
          float ${e}() {
            return sampleTexture(${r}, halfCR);
          }
        `;return new O(s,["coordinates.sampleTexture"])}let n=`
        float ${e}() {
          int offset_${r} = coordsToOffset(TexCoords, ${o}, ${u});
          vec2 uv = uvFromFlat(${o}, ${u}, offset_${r});
          return sampleTexture(${r}, uv);
        }
      `;return new O(n,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(e,r,i){let o=i.width,u=i.height;if(u===1&&o===1){let s=`
        float ${e}(int index) {
          return sampleTexture(${r}, halfCR);
        }
      `;return new O(s,["coordinates.sampleTexture"])}if(u===1){let s=`
          float ${e}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${o}.0, 0.5);
            return sampleTexture(${r}, uv);
          }
        `;return new O(s,["coordinates.sampleTexture"])}if(o===1){let s=`
          float ${e}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${u}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new O(s,["coordinates.sampleTexture"])}let n=`
        float ${e}(int index) {
          vec2 uv = uvFromFlat(${o}, ${u}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new O(n,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(e,r,i){let o=i.unpackedShape,u=[i.height,i.width];if(u!=null&&fe.arraysEqual(o,u)){let a=u[1],d=u[0],h=`
          float ${e}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${a}.0, ${d}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new O(h,["coordinates.sampleTexture"])}let{newShape:n,keptDims:s}=Be(o),p=n;if(p.length<o.length){let a=Ee(o,p),d=JSON.parse(JSON.stringify(i));d.unpackedShape=a;let h=["col","row"],f=`
          ${this.getUnpackedSamplerFromInput(e,r,d).routineBody}
          float ${e}(int row, int col) {
            return ${e}(${De(h,s)});
          }
        `;return new O(f,["coordinates.sampleTexture"])}let c=u[1],t=u[0];if(t===1){let a=`
          float ${e}(int row, int col) {
            int offset_${r} = coordsToOffset(TexCoords, ${c}, ${t});
            float index = dot(vec3(row, col, offset_${r}), vec3(${o[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
            return sampleTexture(${r}, uv);
          }
        `;return new O(a,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(c===1){let a=`
          float ${e}(int row, int col) {
            int offset_${r} = coordsToOffset(TexCoords, ${c}, ${t});
            float index = dot(vec3(row, col, offset_${r}), vec3(${o[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${t}.0, 0.5);
            return sampleTexture(${r}, uv);
          }
        `;return new O(a,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let l=`
        float ${e}(int row, int col) {
          int index = col * ${o[1]} + row;
          vec2 uv = uvFromFlat(${c}, ${t}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new O(l,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(e,r,i){let o=i.unpackedShape,u=o[1]*o[2],n=o[2],{newShape:s,keptDims:p}=Be(o),c=s;if(c.length<o.length){let d=Ee(o,c),h=["batch","col","row"],f=JSON.parse(JSON.stringify(i));f.unpackedShape=d;let g=this.getUnpackedSamplerFromInput(e,r,f),y=p.reverse(),w=`
          ${g.routineBody}
          float ${e}(int batch, int row, int col) {
            return ${e}(${De(h,y)});
          }
        `;return new O(w,g.dependencies)}let t=i.width,l=i.height,a=`
          float ${e}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${u} + col * ${n} + row;
            vec2 uv = uvFromFlat(${t}, ${l}, index);
            return sampleTexture(${r}, uv);
          }
      `;return new O(a,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(e,r,i){let o=i.unpackedShape,u=o[3],n=o[2]*u,s=o[1]*n,p=i.width,c=i.height,t=`
        float ${e}(int row, int col, int depth, int depth2) {
          int index = row * ${s} + col * ${n} +
              depth2 * ${u} + depth;
          vec2 uv = uvFromFlat(${p}, ${c}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new O(t,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(e,r,i){let o=i.unpackedShape,u=o[4],n=o[3]*u,s=o[2]*n,p=o[1]*s,{newShape:c,keptDims:t}=Be(o);if(c.length<o.length){let h=Ee(o,c),f=["row","col","depth","depth2","depth3"],g=JSON.parse(JSON.stringify(i));g.unpackedShape=h;let y=`
          ${this.getUnpackedSamplerFromInput(e,r,g).routineBody}
          float ${e}(int row, int col, int depth, int depth2, int depth3) {
            return ${e}(${De(f,t)});
          }
        `;return new O(y,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let l=i.width,a=i.height,d=`
        float ${e}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${p} + col * ${s} + depth * ${n} +
          depth3 * ${u} + depth2;
          vec2 uv = uvFromFlat(${l}, ${a}, index);
          return sampleTexture(${r}, uv);
        }
      `;return new O(d,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(e,r,i){let o=i.unpackedShape,u=o[5],n=o[4]*u,s=o[3]*n,p=o[2]*s,c=o[1]*p,{newShape:t,keptDims:l}=Be(o);if(t.length<o.length){let f=Ee(o,t),g=["row","col","depth","depth2","depth3","depth4"],y=JSON.parse(JSON.stringify(i));y.unpackedShape=f;let w=`
            ${this.getUnpackedSamplerFromInput(e,r,y).routineBody}
            float ${e}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${e}(${De(g,l)});
            }
          `;return new O(w,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let a=i.width,d=i.height,h=`
          float ${e}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${c} + col * ${p} + depth * ${s} +
            depth2 * ${n} + depth3 * ${u} + depth4;
            vec2 uv = uvFromFlat(${a}, ${d}, index);
            return sampleTexture(${r}, uv);
          }
        `;return new O(h,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let e=this.context.outputTextureLayout,r=e.shape.length,i=e.strides,o=e.width,u=e.height,n=[];for(let p=0;p<r-1;++p)n.push(`
        c[${p}] = offset / ${i[p]};`),n.push(`
        offset -= c[${p}] * ${i[p]};`);n.push(`
        c[${r-1}] = offset;`);let s=`
      void toVec(vec2 texCoords, out int c[${r}]) {
        int offset = coordsToOffset(texCoords, ${o}, ${u});
        ${n.join("")}
      }
      void toVec(int offset, out int c[${r}]) {
        ${n.join("")}
      }
    `;return{toVec:new O(s,["coordinates.coordsToOffset"])}}valueFrom(){let e={};return this.context.programInfo.inputNames.forEach((r,i)=>{let o=this.context.inputTextureLayouts[i],u=(o.unpackedShape.length>0?o.unpackedShape:o.shape).length,n=`_${r}`;e[n]=new O(this.getValueFromSingle(r,u,o.width,o.height,!1),[`shapeUtils.indicesToOffset${n}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),n=n+"_T",e[n]=new O(this.getValueFromSingle(r,u,o.width,o.height,!0),[`shapeUtils.indicesToOffset${n}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),e}getValueFromSingle(e,r,i,o,u){let n=`_${e}`;u&&(n=n+"_T");let s=D(this.context.glContext.version);return`
        float ${n}(int m[${r}]) {
          int offset = indicesToOffset${n}(m);
          vec2 coords = offsetToCoords(offset, ${i}, ${o});
          float value = getColorAsFloat(${s.texture2D}(${e}, coords));
          return value;
        }
        `}getPackedValueFrom(e,r,i,o,u){let n=`_${e}_Pack`;u&&(n=n+"_T");let s=D(this.context.glContext.version);return`
        vec4 ${n}(int m[${r}]) {
          int offset = indicesToOffset_${e}(m);
          vec2 coords = offsetToCoords(offset, ${i}, ${o});
          return ${s.texture2D}(${e}, coords);
        }
        `}}}),Jr,bf=x(()=>{Xt(),Jr=class Xe extends Ot{constructor(r){super(r)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new O(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new O(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let r=Xe.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new O(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${r}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let r=Xe.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new O(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${r}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let r=new ArrayBuffer(4),i=new Uint32Array(r),o=new Uint8Array(r);if(i[0]=3735928559,o[0]===239)return!0;if(o[0]===222)return!1;throw new Error("unknown endianness")}}}),Zr,gf=x(()=>{Xt(),X(),Zr=class extends Ot{constructor(e){super(e)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let e=D(this.context.glContext.version);return{setFragColor:new O(`
        void setFragColor(float value) {
            ${e.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new O(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}}),Yr,yf=x(()=>{Xt(),Yr=class Te extends Ot{constructor(r){super(r)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let r=this.context.outputTextureLayout.shape.length,i={};return this.context.programInfo.inputNames.forEach((o,u)=>{let n=this.context.inputTextureLayouts[u].unpackedShape;if(n.length<=r){let s=n.length,p=r-s,c=`bcastIndices_${o}`,t="";for(let a=0;a<s;++a)t+=`
          realIndices[${a}] = int( mod(float(bcastedIndices[${p+a}]), ${n[a]}.0) );
          `;let l=`
        void ${c} (int bcastedIndices[${r}], out int realIndices[${s}]) {
          ${t}
        }
        `;i[c]=new O(l)}}),i}bcastMatmulIndex(){let r=this.context.outputTextureLayout.shape.length,i={};return this.context.programInfo.inputNames.forEach((o,u)=>{let n=this.context.inputTextureLayouts[u].shape;if(!(n.length<2||n.length>r)){let s=n.length,p=r-s,c=`bcastMatmulIndices_${o}`,t="";for(let a=0;a<s-2;++a)t+=`
          realIndices[${a}] = int( mod(float(bcastedIndices[${p+a}]), ${n[a]}.0) );
          `;let l=`
        void ${c}(int bcastedIndices[${r}], out int realIndices[${s}]) {
          ${t}
          realIndices[${s-1}] = bcastedIndices[${r-1}];
          realIndices[${s-2}] = bcastedIndices[${r-2}];
        }
        `;i[c]=new O(l)}}),i}indicesToOffset(){let r={};return this.context.programInfo.inputNames.forEach((i,o)=>{let u=this.context.inputTextureLayouts[o].shape,n=this.context.inputTextureLayouts[o].strides,s=u.length,p=`indicesToOffset_${i}`;r[p]=new O(Te.indexToOffsetSingle(p,s,n)),p=`indicesToOffset_${i}_T`,r[p]=new O(Te.indexToOffsetSingle(p,s,n.slice().reverse()))}),r}static indexToOffsetSingle(r,i,o){let u="";for(let n=i-1;n>=0;--n)u+=`
        offset += indices[${n}] * ${o[n]};
        `;return`
      int ${r}(int indices[${i}]) {
        int offset = 0;
        ${u}
        return offset;
      }
      `}offsetToIndices(){let r={};return this.context.programInfo.inputNames.forEach((i,o)=>{let u=this.context.inputTextureLayouts[o].shape,n=this.context.inputTextureLayouts[o].strides,s=u.length,p=`offsetToIndices_${i}`;r[p]=new O(Te.offsetToIndicesSingle(p,s,n)),p=`offsetToIndices_${i}_T`,r[p]=new O(Te.offsetToIndicesSingle(p,s,n.slice().reverse()))}),r}static offsetToIndicesSingle(r,i,o){let u=[];for(let n=0;n<i-1;++n)u.push(`
      indices[${n}] = offset / ${o[n]};`),u.push(`
        offset -= indices[${n}] * ${o[n]};`);return u.push(`
      indices[${i-1}] = offset;`),`
      void ${r}(int offset, out int indices[${i}]) {
        ${u.join("")}
      }
      `}incrementIndices(){let r={};return this.context.programInfo.inputNames.forEach((i,o)=>{let u=this.context.inputTextureLayouts[o].shape,n=u.length,s=`incrementIndices_${i}`,p="";for(let t=0;t<n;++t)p+=`
        shape[${t}] = ${u[t]};`;let c=`
        void ${s}(int axis, out int indices[${n}]) {
          int shape[${n}];
          ${p};
          for(int i = ${n} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;r[s]=new O(c)}),r}}}),Qr,xf=x(()=>{Xt(),Qr=class extends Ot{constructor(e){super(e)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let e=this.context.outputTextureLayout.shape.length,r={add:"+=",sub:"-=",mul:"*=",div:"/="},i={};for(let o in r){let u=`${o}Vec`,n="";for(let p=0;p<e;++p)n+=`
          dest[${p}] ${r[o]} src[${p}];
          `;let s=`
        void ${u}(int src[${e}], out int dest[${e}]) {
          ${n}
        }
        `;i[u]=new O(s)}return i}copyVec(){let e=this.context.outputTextureLayout.shape.length,r="";for(let o=0;o<e;++o)r+=`
        dest[${o}] = src[${o}];
        `;let i=`
      void copyVec(int src[${e}], out int dest[${e}]) {
        ${r}
      }
      `;return{copyVec:new O(i)}}setVecItem(){let e=this.context.outputTextureLayout.shape.length,r=`
        if(index < 0)
            index =${e} + index;
        if (index == 0)
            m[0] = value;
        `;for(let o=1;o<e-1;++o)r+=`
        else if (index == ${o})
            m[${o}] = value;
            `;r+=`
        else
            m[${e-1}] = value;
        `;let i=`
      void setVecItem(out int m[${e}], int index, int value) {
        ${r}
      }
        `;return{setVecItem:new O(i)}}getVecItem(){let e=this.context.outputTextureLayout.shape.length,r=`
        if(index < 0)
            index = ${e} + index;
        if (index == 0)
            return m[0];
      `;for(let o=1;o<e-1;++o)r+=`
        else if (index == ${o})
            return m[${o}];
      `;r+=`
        else
            return m[${e-1}];
        `;let i=`
      int getVecItem(int m[${e}], int index) {
        ${r}
      }
    `;return{getVecItem:new O(i)}}}}),ko,Tf=x(()=>{mf(),bf(),gf(),yf(),xf(),ko={encoding:Jr,fragcolor:Zr,vec:Qr,shapeUtils:Yr,coordinates:Kr}}),tn,wf=x(()=>{Xt(),df(),Tf(),X(),tn=class{constructor(e,r,i,o){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new Rr(e,r,i,o),Object.keys(ko).forEach(n=>{let s=new ko[n](this.context);this.libs[n]=s});let u=this.glslLibRoutineDependencyGraph;for(let n in this.libs){let s=this.libs[n].getFunctions();for(let p in s){let c=n+"."+p,t;u[c]?(t=u[c],t.routineBody=s[p].routineBody):(t=new er(c,s[p].routineBody),u[c]=t);let l=s[p].dependencies;if(l)for(let a=0;a<l.length;++a)if(u[l[a]])t.addDependency(u[l[a]]);else{let d=new er(l[a]);u[l[a]]=d,t.addDependency(d)}}}}preprocess(){let e=this.context.programInfo,r=e.shaderSource;return this.context.programInfo.hasMain||(r=`${r}
      ${ts(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),r=pf(r),`${Qa(this.context.glContext.version)}
    ${this.getUniforms(e.inputNames,e.variables)}
    ${this.getImports(r)}
    ${r}`}getImports(e){let r=this.selectGlslLibRoutinesToBeIncluded(e);if(r.length===0)return"";let i="";for(let o=0;o<r.length;++o)if(r[o].routineBody)i+=r[o].routineBody+`
`;else throw new Error(`Missing body for the Glsl Library routine: ${r[o].name}`);return i}selectGlslLibRoutinesToBeIncluded(e){let r=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(i=>{let o=i.split(".")[1];e.indexOf(o)!==-1&&r.push(this.glslLibRoutineDependencyGraph[i])}),Gr.returnOrderedNodes(r)}getUniforms(e,r){let i=[];if(e)for(let o of e)i.push(`uniform sampler2D ${o};`);if(r)for(let o of r)i.push(`uniform ${o.type} ${o.name}${o.arrayLength?`[${o.arrayLength}]`:""};`);return i.join(`
`)}}}),en,vf=x(()=>{$t(),vt(),wf(),X(),en=class{constructor(e,r,i){this.profiler=e,this.glContext=r,this.textureLayoutStrategy=i,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,r){this.repo.set(e,r)}run(e,r,i){this.profiler.event("op",`ProgramManager.run ${e.programInfo.name??"unknown kernel"}`,()=>{let o=this.glContext.gl,u=e.program;o.useProgram(u);try{this.bindOutput(i),this.attributesBound||this.bindAttributes(e.attribLocations),this.bindUniforms(e.uniformLocations,e.programInfo.variables??[],r)}catch(n){throw z.error("ProgramManager",e.programInfo.shaderSource),n}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(e=>this.glContext.deleteProgram(e.program))}build(e,r,i){return this.profiler.event("backend","ProgramManager.build",()=>{let o=new tn(this.glContext,e,r,i),u=o.preprocess(),n=this.compile(u);return{programInfo:e,program:n,uniformLocations:this.getUniformLocations(n,o.context.programInfo.inputNames,o.context.programInfo.variables),attribLocations:this.getAttribLocations(n)}})}compile(e){if(!this.vertexShader){z.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let o=Ya(this.glContext.version);this.vertexShader=this.glContext.compileShader(o,this.glContext.gl.VERTEX_SHADER)}$.debug&&z.verbose("ProrgramManager",`FragShader:
${e}
`);let r=this.glContext.compileShader(e,this.glContext.gl.FRAGMENT_SHADER),i=this.glContext.createProgram(this.vertexShader,r);return this.glContext.deleteShader(r),i}bindOutput(e){let r=e.width,i=e.height;z.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${r}/${i}, shape=${e.shape}, type=${e.tensor.type}`),this.glContext.attachFramebuffer(e.texture,r,i)}bindAttributes(e){let r=e.position,i=e.textureCoord;this.glContext.setVertexAttributes(r,i),this.attributesBound=!0}bindUniforms(e,r,i){var n;let o=this.glContext.gl,u=0;for(let{name:s,type:p,location:c,arrayLength:t}of e){let l=(n=r.find(a=>a.name===s))==null?void 0:n.data;if(p!=="sampler2D"&&!l)throw new Error(`variable '${s}' does not have data defined in program info`);switch(p){case"sampler2D":this.bindTexture(i[u],c,u),u++;break;case"float":t?o.uniform1fv(c,l):o.uniform1f(c,l);break;case"int":t?o.uniform1iv(c,l):o.uniform1i(c,l);break;default:throw new Error(`Uniform not implemented: ${p}`)}}}bindTexture(e,r,i){this.glContext.bindTextureToUniform(e.texture,i,r)}getAttribLocations(e){return{position:this.getAttribLocation(e,"position"),textureCoord:this.getAttribLocation(e,"textureCoord")}}getUniformLocations(e,r,i){let o=[];if(r)for(let u of r)o.push({name:u,type:"sampler2D",location:this.getUniformLocation(e,u)});if(i)for(let u of i)o.push({...u,location:this.getUniformLocation(e,u.name)});return o}getUniformLocation(e,r){let i=this.glContext.gl.getUniformLocation(e,r);if(i===null)throw new Error(`Uniform ${r} not found.`);return i}getAttribLocation(e,r){return this.glContext.gl.getAttribLocation(e,r)}}}),rn,If=x(()=>{vt(),Qe(),rn=class{constructor(e,r,i,o){this.glContext=e,this.layoutStrategy=r,this.profiler=i,this.config=o,this.pendingRead=new Map,o.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(e,r,i,o){let u=this.toEncoderType(e),n=this.glContext.getEncoder(u,r.channels||1,o);if(r.isPacked&&o===1)throw new Error("not implemented");let s=r.width,p=r.height,c,t;if(this.config.reuseTextures){c=`${s}x${p}_${n.format}_${n.internalFormat}_${n.textureType}`,t=this.inUseTextures.get(c),t||(t=[],this.inUseTextures.set(c,t));let a=this.idleTextures.get(c);if(a&&a.length>0){let d=a.pop();return t.push(d),o===1&&this.glContext.updateTexture(d,s,p,n,this.toTextureData(e,i)),d}}z.verbose("TextureManager",`Creating new texture of size ${r.width}x${r.height}`);let l=this.glContext.allocateTexture(s,p,n,this.toTextureData(e,i));return this.config.reuseTextures&&(t.push(l),this.textureLookup.set(l,c)),l}readTexture(e,r,i){return i||(i=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let o=e.shape.reduce((n,s)=>n*s)*i,u=this.glContext.readTexture(e.texture,e.width,e.height,o,this.toEncoderType(r),i);return this.toTensorData(r,u)})}async readTextureAsync(e,r,i){let o=e.tensor.dataId;if(i||(i=1),this.pendingRead.has(o)){let u=this.pendingRead.get(o);return new Promise(n=>u==null?void 0:u.push(n))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(o,[]);let u=e.shape.reduce((c,t)=>c*t)*i;await this.glContext.createAndWaitForFence();let n=this.glContext.readTexture(e.texture,e.width,e.height,u,this.toEncoderType(r),i),s=this.toTensorData(r,n),p=this.pendingRead.get(o);return this.pendingRead.delete(o),p==null||p.forEach(c=>c(s)),s})}readUint8TextureAsFloat(e){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let r=e.shape.reduce((o,u)=>o*u),i=this.glContext.readTexture(e.texture,e.width,e.height,r*4,"byte",4);return new Float32Array(i.buffer,i.byteOffset,r)})}releaseTexture(e,r){let i;if(this.config.reuseTextures&&(i=this.textureLookup.get(e.texture),i)){r&&this.textureLookup.delete(i);let o=this.inUseTextures.get(i);if(o){let u=o.indexOf(e.texture);if(u!==-1){o.splice(u,1);let n=this.idleTextures.get(i);n||(n=[],this.idleTextures.set(i,n)),n.push(e.texture)}}}(!i||r)&&(z.verbose("TextureManager",`Deleting texture of size ${e.width}x${e.height}`),this.glContext.deleteTexture(e.texture))}toTensorData(e,r){switch(e){case"int16":return r instanceof Int16Array?r:Int16Array.from(r);case"int32":return r instanceof Int32Array?r:Int32Array.from(r);case"int8":return r instanceof Int8Array?r:Int8Array.from(r);case"uint16":return r instanceof Uint16Array?r:Uint16Array.from(r);case"uint32":return r instanceof Uint32Array?r:Uint32Array.from(r);case"uint8":case"bool":return r instanceof Uint8Array?r:Uint8Array.from(r);case"float32":return r instanceof Float32Array?r:Float32Array.from(r);case"float64":return r instanceof Float64Array?r:Float64Array.from(r);default:throw new Error(`TensorData type ${e} is not supported`)}}toTextureData(e,r){if(r)return r instanceof Float32Array?r:new Float32Array(r)}toEncoderType(e){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}}),nn,_f=x(()=>{vt(),Ri(),ms(),ff(),vf(),$o(),If(),nn=class{constructor(e,r){this.backend=e,this.context=r,this.layoutStrategy=new Xr(e.glContext.maxTextureSize),this.programManager=new en(this.context.profiler,e.glContext,this.layoutStrategy),this.textureManager=new rn(e.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:e.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=e.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new Cr(this)}onGraphInitialized(e){let r=e.getValues().filter(i=>i.from===-1&&i.tensor).map(i=>i.tensor.dataId);this.initializers=new Set(r)}isInitializer(e){return this.initializers?this.initializers.has(e):!1}addInitializer(e){this.initializers.add(e)}getTextureData(e,r){return r?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,r,i=!1){z.verbose("WebGLSessionHandler","Storing Texture data in cache"),i?this.packedTextureDataCache.set(e,r):this.unpackedTextureDataCache.set(e,r)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.unpackedTextureDataCache=new Map}resolve(e,r,i){let o=Ci(e,r,lf);return{impl:o.opImpl,context:o.opInit?o.opInit(e,i):e}}}});function Wh(e){let r=0;for(;r<e.length&&e[r]();++r);return r-1}var or,Sf=x(()=>{$t(),Qe(),Qe(),Mt(),or=class{constructor(e,r){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=e,this.version=r,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(e,r,i,o){let u=this.gl,n=u.createTexture();u.bindTexture(u.TEXTURE_2D,n),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_MIN_FILTER,u.NEAREST),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_MAG_FILTER,u.NEAREST),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_WRAP_S,u.CLAMP_TO_EDGE),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_WRAP_T,u.CLAMP_TO_EDGE);let s=o?i.encode(o,e*r):null;return u.texImage2D(u.TEXTURE_2D,0,i.internalFormat,e,r,0,i.format,i.textureType,s),this.checkError(),n}updateTexture(e,r,i,o,u){let n=this.gl;n.bindTexture(n.TEXTURE_2D,e);let s=o.encode(u,r*i);n.texSubImage2D(n.TEXTURE_2D,0,0,0,r,i,o.format,o.textureType,s),this.checkError()}attachFramebuffer(e,r,i){let o=this.gl;o.bindTexture(o.TEXTURE_2D,e),o.bindFramebuffer(o.FRAMEBUFFER,this.framebuffer),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,e,0),this.checkError(),o.viewport(0,0,r,i),o.scissor(0,0,r,i)}readTexture(e,r,i,o,u,n){let s=this.gl;n||(n=1),this.frameBufferBound||this.attachFramebuffer(e,r,i);let p=this.getEncoder(u,n),c=p.allocate(r*i);return s.bindTexture(s.TEXTURE_2D,e),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,e,0),s.readPixels(0,0,r,i,s.RGBA,p.textureType,c),this.checkError(),p.decode(c,o)}isFramebufferReady(){return!0}getActiveTexture(){let e=this.gl;return`TEXTURE${e.getParameter(this.gl.ACTIVE_TEXTURE)-e.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(e,r){let i=this.gl;i.vertexAttribPointer(e,3,i.FLOAT,!1,20,0),i.enableVertexAttribArray(e),r!==-1&&(i.vertexAttribPointer(r,2,i.FLOAT,!1,20,12),i.enableVertexAttribArray(r)),this.checkError()}createProgram(e,r){let i=this.gl,o=i.createProgram();return i.attachShader(o,e),i.attachShader(o,r),i.linkProgram(o),o}compileShader(e,r){let i=this.gl,o=i.createShader(r);if(!o)throw new Error(`createShader() returned null with type ${r}`);if(i.shaderSource(o,e),i.compileShader(o),i.getShaderParameter(o,i.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${i.getShaderInfoLog(o)}
Shader source:
${e}`);return o}deleteShader(e){this.gl.deleteShader(e)}bindTextureToUniform(e,r,i){let o=this.gl;o.activeTexture(o.TEXTURE0+r),this.checkError(),o.bindTexture(o.TEXTURE_2D,e),this.checkError(),o.uniform1i(i,r),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if($.debug){let e=this.gl,r=e.getError(),i="";switch(r){case e.NO_ERROR:return;case e.INVALID_ENUM:i="INVALID_ENUM";break;case e.INVALID_VALUE:i="INVALID_VALUE";break;case e.INVALID_OPERATION:i="INVALID_OPERATION";break;case e.INVALID_FRAMEBUFFER_OPERATION:i="INVALID_FRAMEBUFFER_OPERATION";break;case e.OUT_OF_MEMORY:i="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:i="CONTEXT_LOST_WEBGL";break;default:i=`Unknown WebGL Error: ${r.toString(16)}`}throw new Error(i)}}deleteTexture(e){this.gl.deleteTexture(e)}deleteProgram(e){this.gl.deleteProgram(e)}getEncoder(e,r,i=0){if(this.version===2)return new Fr(this.gl,r);switch(e){case"float":return i===1||this.isRenderFloat32Supported?new Ye(this.gl,r):new Ye(this.gl,r,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new Nr(this.gl,r);default:throw new Error(`Invalid dataType: ${e}`)}}clearActiveTextures(){let e=this.gl;for(let r=0;r<this.maxTextureImageUnits;++r)e.activeTexture(e.TEXTURE0+r),e.bindTexture(e.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.framebuffer),e.bindBuffer(e.ARRAY_BUFFER,null),e.deleteBuffer(this.vertexbuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let e=this.gl,r=e.createBuffer();if(!r)throw new Error("createBuffer() returned null");let i=this.createDefaultGeometry();return e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,i,e.STATIC_DRAW),this.checkError(),r}createFramebuffer(){let e=this.gl.createFramebuffer();if(!e)throw new Error("createFramebuffer returned null");return e}queryVitalParameters(){let e=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let e=this.gl,r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let i=this.version===2?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,i,1,1,0,e.RGBA,e.FLOAT,null);let o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let u=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(o),u}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let e=this.gl,r,i,o,u,n;try{r=e.createTexture(),i=e.createFramebuffer(),e.bindTexture(e.TEXTURE_2D,r);let s=this.version===2?e.RGBA32F:e.RGBA;return e.texImage2D(e.TEXTURE_2D,0,s,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0),e.enable(e.BLEND),o=e.createShader(e.VERTEX_SHADER),!o||(e.shaderSource(o,"void main(){}"),e.compileShader(o),u=e.createShader(e.FRAGMENT_SHADER),!u)||(e.shaderSource(u,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),e.compileShader(u),n=e.createProgram(),!n)?!1:(e.attachShader(n,o),e.attachShader(n,u),e.linkProgram(n),e.useProgram(n),e.drawArrays(e.POINTS,0,1),e.getError()===e.NO_ERROR)}finally{e.disable(e.BLEND),n&&e.deleteProgram(n),o&&e.deleteShader(o),u&&e.deleteShader(u),i&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(i)),r&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(r))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,r=this.disjointTimerQueryWebgl2Extension,i=e.createQuery();return e.beginQuery(r.TIME_ELAPSED_EXT,i),i}else throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,r=this.disjointTimerQueryWebgl2Extension;e.endQuery(r.TIME_ELAPSED_EXT);return}else throw new Error("WebGL1 profiling currently not supported")}isTimerResultAvailable(e){let r=!1,i=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let o=this.gl,u=this.disjointTimerQueryWebgl2Extension;r=o.getQueryParameter(e,o.QUERY_RESULT_AVAILABLE),i=o.getParameter(u.GPU_DISJOINT_EXT)}else throw new Error("WebGL1 profiling currently not supported");return r&&!i}getTimerResult(e){let r=0;if(this.version===2){let i=this.gl;r=i.getQueryParameter(e,i.QUERY_RESULT),i.deleteQuery(e)}else throw new Error("WebGL1 profiling currently not supported");return r/1e6}async waitForQueryAndGetTime(e){return await no(()=>this.isTimerResultAvailable(e)),this.getTimerResult(e)}async createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let r,i=e,o=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),o===null?r=()=>!0:r=()=>{let u=i.clientWaitSync(o,0,0);return u===i.ALREADY_SIGNALED||u===i.CONDITION_SATISFIED},{query:o,isFencePassed:r}}async pollFence(e){return new Promise(r=>{this.addItemToPoll(()=>e.isFencePassed(),()=>r())})}pollItems(){let e=Wh(this.itemsToPoll.map(r=>r.isDoneFn));for(let r=0;r<=e;++r){let{resolveFn:i}=this.itemsToPoll[r];i()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}async addItemToPoll(e,r){this.itemsToPoll.push({isDoneFn:e,resolveFn:r}),!(this.itemsToPoll.length>1)&&await no(()=>(this.pollItems(),this.itemsToPoll.length===0))}}});function Bo(e){let r;if((!e||e==="webgl2")&&"webgl2"in Fe?r=Fe.webgl2:(!e||e==="webgl")&&"webgl"in Fe&&(r=Fe.webgl),!r)try{let o=qh();r=Of(o,e)}catch{let o=Hh();r=Of(o,e)}e=e||r.version===1?"webgl":"webgl2";let i=r.gl;return Fe[e]=r,i.isContextLost()?(delete Fe[e],Bo(e)):(i.disable(i.DEPTH_TEST),i.disable(i.STENCIL_TEST),i.disable(i.BLEND),i.disable(i.DITHER),i.disable(i.POLYGON_OFFSET_FILL),i.disable(i.SAMPLE_COVERAGE),i.enable(i.SCISSOR_TEST),i.enable(i.CULL_FACE),i.cullFace(i.BACK),r)}function Of(e,r){let i={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},o,u=i;if((!r||r==="webgl2")&&(o=e.getContext("webgl2",u),o))try{return new or(o,2)}catch(n){z.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${n}`)}if((!r||r==="webgl")&&(o=e.getContext("webgl",u)||e.getContext("experimental-webgl",u),o))try{return new or(o,1)}catch(n){z.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${n}`)}throw new Error("WebGL is not supported")}function Hh(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let e=document.createElement("canvas");return e.width=1,e.height=1,e}function qh(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}var Fe,Af=x(()=>{vt(),Sf(),Fe={}}),on,Pf=x(()=>{$t(),vt(),_f(),Af(),on=class{get contextId(){return $.webgl.contextId}set contextId(e){$.webgl.contextId=e}get matmulMaxBatchSize(){return $.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(e){$.webgl.matmulMaxBatchSize=e}get textureCacheMode(){return $.webgl.textureCacheMode}set textureCacheMode(e){$.webgl.textureCacheMode=e}get pack(){return $.webgl.pack}set pack(e){$.webgl.pack=e}get async(){return $.webgl.async}set async(e){$.webgl.async=e}initialize(){try{return this.glContext=Bo(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),z.setWithEnv($),$.webgl.context||Object.defineProperty($.webgl,"context",{value:this.glContext.gl}),z.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return z.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(e){return new nn(this,e)}dispose(){this.glContext.dispose()}}});async function Fo(e){if(e){let r=typeof e=="string"?[e]:e;for(let i of r){let o=Ef.get(i);if(o)return o;let u=await Xh(i);if(u)return u}}else return Fo(["webgl"]);throw new Error("no available backend to use")}async function Xh(e){let r=jh;if(typeof r[e]<"u"&&Kh(r[e])){let i=r[e],o=i.initialize();if(typeof o=="object"&&"then"in o&&(o=await o),o)return Ef.set(e,i),i}}function Kh(e){let r=e;return"initialize"in r&&typeof r.initialize=="function"&&"createSessionHandler"in r&&typeof r.createSessionHandler=="function"&&"dispose"in r&&typeof r.dispose=="function"}var Ef,jh,Df=x(()=>{Pf(),Ef=new Map,jh={webgl:new on}}),No,an,Lf=x(()=>{vt(),No=class{constructor(e,r){this.op=e,this.node=r}},an=class{constructor(e,r,i){this.graph=e,this.profiler=i,this.initialize(r)}initialize(e){this.profiler.event("session","ExecutionPlan.initialize",()=>{let r=this.graph.getNodes();if(r.length!==e.length)throw new Error("The size of nodes and OPs do not match.");this._ops=e.map((i,o)=>new No(i,r[o])),this.reset(),this._starter=[],this._ops.forEach((i,o)=>{let u=!0;for(let n of i.node.inputs)if(!this._values[n]&&this.graph.getInputIndices().indexOf(n)===-1){u=!1;break}u&&this._starter.push(o)})})}reset(){this._values=this.graph.getValues().map(e=>e.tensor)}async execute(e,r){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let i=e.createInferenceHandler(),o=this.graph.getInputIndices();if(r.length!==o.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${r.length} expected: ${o.length}`);r.forEach((t,l)=>{let a=o[l];this._values[a]=t});let u=this._starter.slice(0),n=this.graph.getValues(),s=this.graph.getNodes(),p=0;for(;p<u.length;){let t=u[p++],l=this._ops[t],a=l.node.inputs.map(g=>this._values[g]);if(a.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${l.node}`);let d=a;z.verbose("ExecPlan",`Running op:${l.node.name} (${d.map((g,y)=>`'${l.node.inputs[y]}': ${g.type}[${g.dims.join(",")}]`).join(", ")})`);let h=await this.profiler.event("node",l.node.name,async()=>l.op.impl(i,d,l.op.context));if(h.length!==l.node.outputs.length)throw new Error("the size of output does not match model definition.");h.forEach((g,y)=>{let w=l.node.outputs[y];if(this._values[w])throw new Error(`output [${w}] already has value: op:${l.node.name}`);this._values[w]=g});let f=new Set;h.forEach((g,y)=>{let w=l.node.outputs[y];for(let m of n[w].to){let v=s[m],T=!0;for(let _ of v.inputs)if(!this._values[_]){T=!1;break}T&&f.add(m)}}),u.push(...f)}let c=[];for(let t=0;t<this.graph.getOutputIndices().length;t++){let l=this.graph.getOutputIndices()[t],a=this._values[l];if(a===void 0)throw new Error(`required output [${l}] does not have value`);l===0?await a.getData():a.data,c.push(a)}return z.verbose("ExecPlan","disposing of inferenceHandler"),i.dispose(),c})}}}),C,Et,ir,$f=x(()=>{qe(),C=Ie(Ae()),he(),U(),Et=P.experimental.fbs,ir=class Oe{constructor(r){if(this._attributes=new Map,r!=null){for(let i of r)i instanceof C.onnx.AttributeProto?this._attributes.set(i.name,[Oe.getValue(i),Oe.getType(i)]):i instanceof Et.Attribute&&this._attributes.set(i.name(),[Oe.getValue(i),Oe.getType(i)]);if(this._attributes.size<r.length)throw new Error("duplicated attribute names")}}set(r,i,o){this._attributes.set(r,[o,i])}delete(r){this._attributes.delete(r)}getFloat(r,i){return this.get(r,"float",i)}getInt(r,i){return this.get(r,"int",i)}getString(r,i){return this.get(r,"string",i)}getTensor(r,i){return this.get(r,"tensor",i)}getFloats(r,i){return this.get(r,"floats",i)}getInts(r,i){return this.get(r,"ints",i)}getStrings(r,i){return this.get(r,"strings",i)}getTensors(r,i){return this.get(r,"tensors",i)}get(r,i,o){let u=this._attributes.get(r);if(u===void 0){if(o!==void 0)return o;throw new Error(`required attribute not found: ${r}`)}if(u[1]!==i)throw new Error(`type mismatch: expected ${i} but got ${u[1]}`);return u[0]}static getType(r){let i=r instanceof C.onnx.AttributeProto?r.type:r.type();switch(i){case C.onnx.AttributeProto.AttributeType.FLOAT:return"float";case C.onnx.AttributeProto.AttributeType.INT:return"int";case C.onnx.AttributeProto.AttributeType.STRING:return"string";case C.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case C.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case C.onnx.AttributeProto.AttributeType.INTS:return"ints";case C.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case C.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${C.onnx.AttributeProto.AttributeType[i]}`)}}static getValue(r){let i=r instanceof C.onnx.AttributeProto?r.type:r.type();if(i===C.onnx.AttributeProto.AttributeType.GRAPH||i===C.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let o=this.getValueNoCheck(r);if(i===C.onnx.AttributeProto.AttributeType.INT&&bt.isLong(o))return bt.longToNumber(o);if(i===C.onnx.AttributeProto.AttributeType.INTS){let u=o,n=new Array(u.length);for(let s=0;s<u.length;s++){let p=u[s];n[s]=bt.longToNumber(p)}return n}if(i===C.onnx.AttributeProto.AttributeType.TENSOR)return r instanceof C.onnx.AttributeProto?et.fromProto(o):et.fromOrtTensor(o);if(i===C.onnx.AttributeProto.AttributeType.TENSORS){if(r instanceof C.onnx.AttributeProto)return o.map(u=>et.fromProto(u));if(r instanceof Et.Attribute)return o.map(u=>et.fromOrtTensor(u))}return i===C.onnx.AttributeProto.AttributeType.STRING&&r instanceof C.onnx.AttributeProto?Ze(o):i===C.onnx.AttributeProto.AttributeType.STRINGS&&r instanceof C.onnx.AttributeProto?o.map(Ze):o}static getValueNoCheck(r){return r instanceof C.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(r):this.getValueNoCheckFromOrtFormat(r)}static getValueNoCheckFromOnnxFormat(r){switch(r.type){case C.onnx.AttributeProto.AttributeType.FLOAT:return r.f;case C.onnx.AttributeProto.AttributeType.INT:return r.i;case C.onnx.AttributeProto.AttributeType.STRING:return r.s;case C.onnx.AttributeProto.AttributeType.TENSOR:return r.t;case C.onnx.AttributeProto.AttributeType.GRAPH:return r.g;case C.onnx.AttributeProto.AttributeType.FLOATS:return r.floats;case C.onnx.AttributeProto.AttributeType.INTS:return r.ints;case C.onnx.AttributeProto.AttributeType.STRINGS:return r.strings;case C.onnx.AttributeProto.AttributeType.TENSORS:return r.tensors;case C.onnx.AttributeProto.AttributeType.GRAPHS:return r.graphs;default:throw new Error(`unsupported attribute type: ${C.onnx.AttributeProto.AttributeType[r.type]}`)}}static getValueNoCheckFromOrtFormat(r){switch(r.type()){case Et.AttributeType.FLOAT:return r.f();case Et.AttributeType.INT:return r.i();case Et.AttributeType.STRING:return r.s();case Et.AttributeType.TENSOR:return r.t();case Et.AttributeType.GRAPH:return r.g();case Et.AttributeType.FLOATS:return r.floatsArray();case Et.AttributeType.INTS:{let i=[];for(let o=0;o<r.intsLength();o++)i.push(r.ints(o));return i}case Et.AttributeType.STRINGS:{let i=[];for(let o=0;o<r.stringsLength();o++)i.push(r.strings(o));return i}case Et.AttributeType.TENSORS:{let i=[];for(let o=0;o<r.tensorsLength();o++)i.push(r.tensors(o));return i}default:throw new Error(`unsupported attribute type: ${Et.AttributeType[r.type()]}`)}}}}),Ro,sn,Go,zt,un,Co,kf=x(()=>{$f(),qe(),Ro=Ie(Ae()),he(),U(),sn=P.experimental.fbs,Go={from:(e,r)=>new Co(e,r)},zt=class{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=st.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}},un=class{constructor(e,r){e instanceof Ro.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new ir(e.attribute)):e instanceof sn.Node&&(this.name=r??e.name(),this.opType=e.opType(),this.attributes=new ir(st.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}},Co=class{constructor(e,r){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(r),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof Ro.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else if(e instanceof sn.Graph)this.buildGraphFromOrtFormat(e);else throw new TypeError("Graph type is not supported.")}buildGraphFromOnnxFormat(e){let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let i=new Map;if(!e.input)throw new Error("missing information in graph: input");let o=[];for(let u of e.input){if(r.has(u.name))throw new Error(`duplicated input name: ${u.name}`);let n=this._allData.push(new zt(u))-1;r.set(u.name,n),o.push(u.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(let u of e.initializer){let n=r.get(u.name);if(n===void 0){let s=new zt;s.type={shape:{dims:st.tensorDimsFromProto(u.dims)},tensorType:st.tensorDataTypeFromProto(u.dataType)},n=this._allData.push(s)-1,r.set(u.name,n)}this._allData[n]._from=-1,this._allData[n].tensor=et.fromProto(u)}for(let u=0;u<this._allData.length;u++)this._allData[u].tensor||(this._allInputIndices.push(u),this._allInputNames.push(o[u]));if(!e.output)throw new Error("missing information in graph: output");for(let u of e.output){if(r.has(u.name))throw new Error(`duplicated output name: ${u.name}`);let n=this._allData.push(new zt(u))-1;r.set(u.name,n),this._allOutputIndices.push(n),this._allOutputNames.push(u.name)}if(!e.node)throw new Error("missing information in graph: node");for(let u of e.node){if(!u.name)for(let s=0;;s++){let p=`unnamed_${u.opType}_${s}`;if(!i.has(p)){u.name=p;break}}if(i.has(u.name))throw new Error(`duplicated node name: ${u.name}`);let n=this._nodes.push(new un(u))-1;i.set(u.name,n)}for(let u=0;u<this._nodes.length;u++){let n=this._nodes[u],s=e.node[u];if(!s.output)throw new Error(`missing output for node: ${s.name}`);for(let p of s.output){let c=r.get(p);if(typeof c>"u"&&(c=this._allData.push(new zt)-1,r.set(p,c)),n.outputs.push(c),this._allData[c]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${c}`);if(this._allData[c]._from=u,s.opType==="Constant"){if(!s.attribute||s.attribute.length!==1||!s.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!s.output||s.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");n.outputs.pop(),n.executeNode=!1,this._allData[c]._from=-1,this._allData[c].tensor=et.fromProto(s.attribute[0].t)}}}for(let u=0;u<this._nodes.length;u++){let n=this._nodes[u],s=e.node[u];if(!s.input)throw new Error(`missing input for node: ${s.name}`);for(let p of s.input){let c=r.get(p);if(typeof c>"u"){if(p===""&&(s.input.length===3||s.input.length===4)&&s.opType==="Resize")continue;throw new Error(`unrecognized input '${p}' for node: ${s.name}`)}n.inputs.push(c),this._allData[c]._to.push(u)}}return!0}buildGraphFromOrtFormat(e){var u,n,s;let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let i=new Map,o=[];for(let p=0;p<e.inputsLength();p++){let c=e.inputs(p);if(r.has(c))throw new Error(`duplicated input name: ${c}`);for(let t=0;t<e.nodeArgsLength();t++)if(((u=e.nodeArgs(t))==null?void 0:u.name())===c){let l=new zt;if(((s=(n=e.nodeArgs(t))==null?void 0:n.type())==null?void 0:s.valueType())!==sn.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let a=e.nodeArgs(t).type().value(new sn.TensorTypeAndShape),d=st.tensorDataTypeFromProto(a.elemType()),h=a.shape(),f=[];for(let y=0;y<h.dimLength();y++)f.push(bt.longToNumber(h.dim(y).value().dimValue()));l.type={shape:{dims:f},tensorType:d};let g=this._allData.push(l)-1;r.set(c,g),o.push(c)}}for(let p=0;p<e.initializersLength();p++){let c=e.initializers(p),t=r.get(c.name());if(t===void 0){let l=new zt,a=st.tensorDimsFromORTFormat(c),d=st.tensorDataTypeFromProto(c.dataType());l.type={shape:{dims:a},tensorType:d},t=this._allData.push(l)-1,r.set(c.name(),t)}this._allData[t]._from=-1,this._allData[t].tensor=et.fromOrtTensor(c)}for(let p=0;p<this._allData.length;p++)this._allData[p].tensor||(this._allInputIndices.push(p),this._allInputNames.push(o[p]));for(let p=0;p<e.outputsLength();p++){let c=e.outputs(p);if(r.has(c))throw new Error(`duplicated output name: ${c}`);let t=this._allData.push(new zt)-1;r.set(c,t),this._allOutputIndices.push(t),this._allOutputNames.push(c)}if(!e.nodes)throw new Error("missing information in graph: node");for(let p=0;p<e.nodesLength();p++){let c=e.nodes(p),t=c.name();if(!t)for(let a=0;t=`unnamed_${c.opType()}_${a}`,!!i.has(t);a++);if(i.has(t))throw new Error(`duplicated node name: ${t}`);let l=this._nodes.push(new un(c,t))-1;i.set(t,l)}for(let p=0;p<this._nodes.length;p++){let c=this._nodes[p],t=e.nodes(p);if(t==null)throw new Error(`No node exists at index ${p}`);if((t==null?void 0:t.outputsLength())===0)throw new Error(`missing output for node: ${t.name}`);for(let l=0;l<(t==null?void 0:t.outputsLength());l++){let a=t==null?void 0:t.outputs(l),d=r.get(a);if(typeof d>"u"&&(d=this._allData.push(new zt)-1,r.set(a,d)),c.outputs.push(d),this._allData[d]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${d}`);if(this._allData[d]._from=p,t.opType()==="Constant"){if(t.attributesLength()!==1||!t.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(t.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");c.outputs.pop(),c.executeNode=!1,this._allData[d]._from=-1,this._allData[d].tensor=et.fromOrtTensor(t.attributes(0).t())}}}for(let p=0;p<this._nodes.length;p++){let c=this._nodes[p],t=e.nodes(p);if(t.inputsLength()===0)throw new Error(`missing input for node: ${t.name}`);for(let l=0;l<t.inputsLength();l++){let a=t.inputs(l),d=r.get(a);if(typeof d>"u")throw new Error(`unrecognized input '${a}' for node: ${t.name()}`);c.inputs.push(d),this._allData[d]._to.push(p)}}}checkIsAcyclic(){let e=new Set;this._allInputIndices.forEach(o=>{this._allData[o]._to.forEach(u=>{e.add(u)})});let r=Array.from(e),i=new Array(this._nodes.length).fill("white");for(;r.length>0;){let o=r.pop();i[o]==="gray"?i[o]="black":(r.push(o),i[o]="gray",this._nodes[o].outputs.forEach(u=>{let n=this._allData[u];if(typeof n.tensor<"u")throw new Error("node outputs should not be initialized");if(n._from!==o)throw new Error("from property of the Value object doesn't match index of Node being processed");n._to.forEach(s=>{if(i[s]==="gray")throw new Error("model graph is cyclic");i[s]==="white"&&r.push(s)})}))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0,r=new Array(this._nodes.length,0),i=0;for(let o=0;o<this._nodes.length;o++)r[o]=i,this._nodes[o].executeNode?(i!==o&&(this._nodes[i]=this._nodes[o]),i++):this._nodes[o].outputs.forEach(u=>{this._allData[u]._from=-2});this._nodes.splice(i,this._nodes.length-i);for(let o=0;o<this._allData.length;o++){let u=this._allData[o];u._from!==void 0&&u._from!==-1&&u._from!==-2&&(u._from=r[u._from]);for(let n=0;n<u._to.length;n++)if(u._to[n]>=0)u._to[n]=r[u._to[n]];else throw new Error("Trying to update a removed node")}e=0;for(let o=0;o<this._allData.length;o++){if(this._allData[o].from===-2&&this._allOutputIndices.indexOf(o+e)===-1){e++,this._allData.splice(o,1),o--;continue}if(e>0){let u=-1;this._allData[o].from!==void 0&&this._allData[o].from!==-1?(u=this._nodes[this._allData[o].from].outputs.indexOf(o+e),u!==-1&&(this._nodes[this._allData[o].from].outputs[u]=o)):(u=this._allInputIndices.indexOf(o+e),u!==-1&&(this._allInputIndices[u]=o)),this._allData[o].to.forEach(n=>{u=this._nodes[n].inputs.indexOf(o+e),u!==-1&&(this._nodes[n].inputs[u]=o)}),this._allData[o].to.length===0&&(u=this._allOutputIndices.indexOf(o+e),u!==-1&&(this._allOutputIndices[u]=o))}}}deleteNode(e){let r=this._nodes[e];if(r.outputs.length>1){for(let s=1;s<r.outputs.length;s++)if(this._allData[r.outputs[s]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}r.executeNode=!1;let i=r.inputs[0],o=r.outputs[0],u=this._allData[o].to;for(let s=0;s<r.inputs.length;s++){let p=this._allData[r.inputs[s]].to.indexOf(e);if(p===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[r.inputs[s]].to.splice(p,1)}this._allData[o]._to=[];let n=this._allOutputIndices.indexOf(o);if(n!==-1&&(this._allOutputIndices[n]=i),u&&u.length>0)for(let s of u){let p=this._nodes[s].inputs.indexOf(o);if(p===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[s].inputs[p]=i,this._allData[i].to.push(s)}}removeAllDropoutNodes(){let e=0;for(let r of this._nodes){if(r.opType==="Dropout"){if(r.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(r.outputs.length!==1&&r.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(r.outputs.length===2&&this._allData[r.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(let r of this._nodes)r.opType==="Identity"&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let e of this._nodes)if(e.opType==="Conv"){let r=this._allData[e.outputs[0]]._to;if(r.length===1&&this.isActivation(this._nodes[r[0]])){let i=this._nodes[r[0]];if(i.opType==="Clip")if(i.inputs.length===1)try{e.attributes.set("activation_params","floats",[i.attributes.getFloat("min"),i.attributes.getFloat("max")])}catch{e.attributes.set("activation_params","floats",[pe,de])}else if(i.inputs.length>=3&&this._allData[i.inputs[1]].tensor!==void 0&&this._allData[i.inputs[2]].tensor!==void 0)e.attributes.set("activation_params","floats",[this._allData[i.inputs[1]].tensor.floatData[0],this._allData[i.inputs[2]].tensor.floatData[0]]);else continue;e.attributes.set("activation","string",i.opType),this.deleteNode(r[0])}}}}}),Bf,Jh,ln,Ff=x(()=>{Pr(),kf(),qe(),Bf=Ie(Ae()),U(),Jh=P.experimental.fbs,ln=class{constructor(){}load(e,r,i){let o;if(!i)try{this.loadFromOnnxFormat(e,r);return}catch(u){if(i!==void 0)throw u;o=u}try{this.loadFromOrtFormat(e,r)}catch(u){throw i!==void 0?u:new Error(`Failed to load model as ONNX format: ${o}
as ORT format: ${u}`)}}loadFromOnnxFormat(e,r){let i=Bf.onnx.ModelProto.decode(e);if(bt.longToNumber(i.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=i.opsetImport.map(o=>({domain:o.domain,version:bt.longToNumber(o.version)})),this._graph=Go.from(i.graph,r)}loadFromOrtFormat(e,r){let i=new b.ByteBuffer(e),o=Jh.InferenceSession.getRootAsInferenceSession(i).model();if(bt.longToNumber(o.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let u=0;u<o.opsetImportLength();u++){let n=o.opsetImport(u);this._opsets.push({domain:n==null?void 0:n.domain(),version:bt.longToNumber(n.version())})}this._graph=Go.from(o.graph(),r)}get graph(){return this._graph}get opsets(){return this._opsets}}}),fn,Nf=x(()=>{Df(),Lf(),vt(),Ff(),fn=class{constructor(e={}){this._initialized=!1,this.backendHint=e.backendHint,this.profiler=Or.create(e.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(e,r,i){await this.profiler.event("session","Session.loadModel",async()=>{let o=await Fo(this.backendHint);if(this.sessionHandler=o.createSessionHandler(this.context),this._model=new ln,typeof e=="string"){let u=e.endsWith(".ort");{let n=await(await fetch(e)).arrayBuffer();this.initialize(new Uint8Array(n),u)}}else if(ArrayBuffer.isView(e))this.initialize(e);else{let u=new Uint8Array(e,r||0,i||e.byteLength);this.initialize(u)}})}initialize(e,r){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let i=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(e,i,r),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new an(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(e){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let r=this.normalizeAndValidateInputs(e),i=await this._executionPlan.execute(this.sessionHandler,r);return this.createOutput(i)})}normalizeAndValidateInputs(e){let r=this._model.graph.getInputNames();if(Array.isArray(e)){if(e.length!==r.length)throw new Error(`incorrect input array length: expected ${r.length} but got ${e.length}`)}else{if(e.size!==r.length)throw new Error(`incorrect input map size: expected ${r.length} but got ${e.size}`);let i=new Array(e.size),o=0;for(let u=0;u<r.length;++u){let n=e.get(r[u]);if(!n)throw new Error(`missing input tensor for: '${name}'`);i[o++]=n}e=i}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let i=this._model.graph.getInputIndices(),o=this._model.graph.getValues(),u=new Array(i.length);for(let n=0;n<i.length;++n){let s=o[i[n]];u[n]=s.type.shape.dims,this.context.graphInputTypes.push(s.type.tensorType),this.context.graphInputDims.push(e[n].dims)}this.validateInputTensorDims(u,e,!0)}else this.validateInputTensorDims(this.context.graphInputDims,e,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,e),e}validateInputTensorTypes(e,r){for(let i=0;i<r.length;i++){let o=e[i],u=r[i].type;if(o!==u)throw new Error(`input tensor[${i}] check failed: expected type '${o}' but got ${u}`)}}validateInputTensorDims(e,r,i){for(let o=0;o<r.length;o++){let u=e[o],n=r[o].dims;if(!this.compareTensorDims(u,n,i))throw new Error(`input tensor[${o}] check failed: expected shape '[${u.join(",")}]' but got [${n.join(",")}]`)}}compareTensorDims(e,r,i){if(e.length!==r.length)return!1;for(let o=0;o<e.length;++o)if(e[o]!==r[o]&&(!i||e[o]!==0))return!1;return!0}createOutput(e){let r=this._model.graph.getOutputNames();if(e.length!==r.length)throw new Error("expected number of outputs do not match number of generated outputs");let i=new Map;for(let o=0;o<r.length;++o)i.set(r[o],e[o]);return i}initializeOps(e){let r=e.getNodes();this._ops=new Array(r.length);for(let i=0;i<r.length;i++)this._ops[i]=this.sessionHandler.resolve(r[i],this._model.opsets,e)}}}),cn,Cf=x(()=>{$t(),he(),cn=class{constructor(e){this.session=e,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(e,r,i){let o=new Map;for(let s in e)if(Object.hasOwnProperty.call(e,s)){let p=e[s];o.set(s,new et(p.dims,p.type,void 0,void 0,p.data))}let u=await this.session.run(o),n={};return u.forEach((s,p)=>{n[p]=new rt(s.type,s.data,s.dims)}),n}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}}),Rf={};ze(Rf,{onnxjsBackend:()=>Zh});var Mo,Zh,Gf=x(()=>{Nf(),Cf(),Mo=class{async init(){}async createInferenceSessionHandler(e,r){let i=new fn(r);return typeof e=="string"?await i.loadModel(e):await i.loadModel(e),new cn(i)}},Zh=new Mo}),pn=x(()=>{}),Uf={};ze(Uf,{default:()=>Yh});var Mf,Vf,Yh,zf=x(()=>{var e;Vo(),xe(),ar(),Mf="ort-wasm-proxy-worker",Vf=((e=globalThis.self)==null?void 0:e.name)===Mf,Vf&&(self.onmessage=r=>{let{type:i,in:o}=r.data;try{switch(i){case"init-wasm":dn(o.wasm).then(()=>{hn(o).then(()=>{postMessage({type:i})},u=>{postMessage({type:i,err:u})})},u=>{postMessage({type:i,err:u})});break;case"init-ep":{let{epName:u,env:n}=o;mn(n,u).then(()=>{postMessage({type:i})},s=>{postMessage({type:i,err:s})});break}case"copy-from":{let{buffer:u}=o,n=sr(u);postMessage({type:i,out:n});break}case"create":{let{model:u,options:n}=o;bn(u,n).then(s=>{postMessage({type:i,out:s})},s=>{postMessage({type:i,err:s})});break}case"release":gn(o),postMessage({type:i});break;case"run":{let{sessionId:u,inputIndices:n,inputs:s,outputIndices:p,options:c}=o;yn(u,n,s,p,new Array(p.length).fill(null),c).then(t=>{t.some(l=>l[3]!=="cpu")?postMessage({type:i,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:i,out:t},Tn([...s,...t]))},t=>{postMessage({type:i,err:t})});break}case"end-profiling":xn(o),postMessage({type:i});break;default:}}catch(u){postMessage({type:i,err:u})}}),Yh=Vf?null:r=>new Worker(r??Dt,{type:"classic",name:Mf})}),Dt,Qh,Hf,tm,em,qf,rm,Wf,jf,Xf,ar=x(()=>{var e,r;pn(),Dt=typeof document<"u"?(e=document.currentScript)==null?void 0:e.src:typeof self<"u"?(r=self.location)==null?void 0:r.href:void 0,Qh=typeof location>"u"?void 0:location.origin,Hf=(i,o)=>{try{let u=o??Dt;return(u?new URL(i,u):new URL(i)).origin===Qh}catch{return!1}},tm=(i,o)=>{let u=o??Dt;try{return(u?new URL(i,u):new URL(i)).href}catch{return}},em=(i,o)=>`${o??"./"}${i}`,qf=async i=>{let o=await(await fetch(i,{credentials:"same-origin"})).blob();return URL.createObjectURL(o)},rm=async i=>(await import(i)).default,Wf=(zf(),hr(Uf)).default,jf=async()=>{if(!Dt)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Hf(Dt))return[void 0,Wf()];let i=await qf(Dt);return[i,Wf(i)]},Xf=async(i,o,u)=>{{let n="ort-wasm-simd-threaded.mjs",s=i??tm(n,o),p=u&&s&&!Hf(s,o),c=p?await qf(s):s??em(n,o);return[p?c:void 0,await rm(c)]}}}),Uo,zo,wn,Kf,nm,om,dn,nt,xe=x(()=>{ar(),zo=!1,wn=!1,Kf=!1,nm=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},om=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},dn=async e=>{if(zo)return Promise.resolve();if(wn)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Kf)throw new Error("previous call to 'initializeWebAssembly()' failed.");wn=!0;let r=e.initTimeout,i=e.numThreads;if(!om())throw new Error("WebAssembly SIMD is not supported in the current environment.");let o=nm();i>1&&!o&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+i+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=i=1);let u=e.wasmPaths,n=typeof u=="string"?u:void 0,s=u==null?void 0:u.mjs,p=(s==null?void 0:s.href)??s,c=u==null?void 0:u.wasm,t=(c==null?void 0:c.href)??c,l=e.wasmBinary,[a,d]=await Xf(p,n,i>1),h=!1,f=[];if(r>0&&f.push(new Promise(g=>{setTimeout(()=>{h=!0,g()},r)})),f.push(new Promise((g,y)=>{let w={numThreads:i};l?w.wasmBinary=l:(t||n)&&(w.locateFile=(m,v)=>t??(n??v)+m),d(w).then(m=>{wn=!1,zo=!0,Uo=m,g(),a&&URL.revokeObjectURL(a)},m=>{wn=!1,Kf=!0,y(m)})})),await Promise.race(f),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},nt=()=>{if(zo&&Uo)return Uo;throw new Error("WebAssembly is not initialized yet.")}}),ot,ur,Y,vn=x(()=>{xe(),ot=(e,r)=>{let i=nt(),o=i.lengthBytesUTF8(e)+1,u=i._malloc(o);return i.stringToUTF8(e,u,o),r.push(u),u},ur=(e,r,i,o)=>{if(typeof e=="object"&&e!==null){if(i.has(e))throw new Error("Circular reference in options");i.add(e)}Object.entries(e).forEach(([u,n])=>{let s=r?r+u:u;if(typeof n=="object")ur(n,s+".",i,o);else if(typeof n=="string"||typeof n=="number")o(s,n.toString());else if(typeof n=="boolean")o(s,n?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof n}`)})},Y=e=>{let r=nt(),i=r.stackSave();try{let o=r.stackAlloc(8);r._OrtGetLastError(o,o+4);let u=r.HEAP32[o/4],n=r.HEAPU32[o/4+1],s=n?r.UTF8ToString(n):"";throw new Error(`${e} ERROR_CODE: ${u}, ERROR_MESSAGE: ${s}`)}finally{r.stackRestore(i)}}}),Jf,Zf=x(()=>{xe(),vn(),Jf=e=>{let r=nt(),i=0,o=[],u=e||{};try{if((e==null?void 0:e.logSeverityLevel)===void 0)u.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if((e==null?void 0:e.logVerbosityLevel)===void 0)u.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);(e==null?void 0:e.terminate)===void 0&&(u.terminate=!1);let n=0;return(e==null?void 0:e.tag)!==void 0&&(n=ot(e.tag,o)),i=r._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,n),i===0&&Y("Can't create run options."),(e==null?void 0:e.extra)!==void 0&&ur(e.extra,"",new WeakSet,(s,p)=>{let c=ot(s,o),t=ot(p,o);r._OrtAddRunConfigEntry(i,c,t)!==0&&Y(`Can't set a run config entry: ${s} - ${p}.`)}),[i,o]}catch(n){throw i!==0&&r._OrtReleaseRunOptions(i),o.forEach(s=>r._free(s)),n}}}),im,am,sm,um,Yf,Qf=x(()=>{xe(),vn(),im=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},am=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},sm=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let r=e.extra.session;r.use_ort_model_bytes_directly||(r.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(i=>(typeof i=="string"?i:i.name)==="webgpu")&&(e.enableMemPattern=!1)},um=(e,r,i)=>{for(let o of r){let u=typeof o=="string"?o:o.name;switch(u){case"webnn":if(u="WEBNN",typeof o!="string"){let s=o==null?void 0:o.deviceType;if(s){let p=ot("deviceType",i),c=ot(s,i);nt()._OrtAddSessionConfigEntry(e,p,c)!==0&&Y(`Can't set a session config entry: 'deviceType' - ${s}.`)}}break;case"webgpu":if(u="JS",typeof o!="string"){let s=o;if(s!=null&&s.preferredLayout){if(s.preferredLayout!=="NCHW"&&s.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let p=ot("preferredLayout",i),c=ot(s.preferredLayout,i);nt()._OrtAddSessionConfigEntry(e,p,c)!==0&&Y(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${u}`)}let n=ot(u,i);nt()._OrtAppendExecutionProvider(e,n)!==0&&Y(`Can't append execution provider: ${u}.`)}},Yf=e=>{let r=nt(),i=0,o=[],u=e||{};sm(u);try{let n=im(u.graphOptimizationLevel??"all"),s=am(u.executionMode??"sequential"),p=typeof u.logId=="string"?ot(u.logId,o):0,c=u.logSeverityLevel??2;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log serverity level is not valid: ${c}`);let t=u.logVerbosityLevel??0;if(!Number.isInteger(t)||t<0||t>4)throw new Error(`log verbosity level is not valid: ${t}`);let l=typeof u.optimizedModelFilePath=="string"?ot(u.optimizedModelFilePath,o):0;if(i=r._OrtCreateSessionOptions(n,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,p,c,t,l),i===0&&Y("Can't create session options."),u.executionProviders&&um(i,u.executionProviders,o),u.enableGraphCapture!==void 0){if(typeof u.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${u.enableGraphCapture}`);let a=ot("enableGraphCapture",o),d=ot(u.enableGraphCapture.toString(),o);r._OrtAddSessionConfigEntry(i,a,d)!==0&&Y(`Can't set a session config entry: 'enableGraphCapture' - ${u.enableGraphCapture}.`)}if(u.freeDimensionOverrides)for(let[a,d]of Object.entries(u.freeDimensionOverrides)){if(typeof a!="string")throw new Error(`free dimension override name must be a string: ${a}`);if(typeof d!="number"||!Number.isInteger(d)||d<0)throw new Error(`free dimension override value must be a non-negative integer: ${d}`);let h=ot(a,o);r._OrtAddFreeDimensionOverride(i,h,d)!==0&&Y(`Can't set a free dimension override: ${a} - ${d}.`)}return u.extra!==void 0&&ur(u.extra,"",new WeakSet,(a,d)=>{let h=ot(a,o),f=ot(d,o);r._OrtAddSessionConfigEntry(i,h,f)!==0&&Y(`Can't set a session config entry: ${a} - ${d}.`)}),[i,o]}catch(n){throw i!==0&&r._OrtReleaseSessionOptions(i),o.forEach(s=>r._free(s)),n}}}),Wo,tc,Ho,ec,rc,In,nc,qo=x(()=>{Wo=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},tc=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},Ho=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],ec=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},rc=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},In=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool",nc=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}}),lr,jo=x(()=>{pn(),lr=async e=>{if(typeof e=="string"){let r=await fetch(e);if(!r.ok)throw new Error(`failed to load external data file: ${e}`);let i=r.headers.get("Content-Length"),o=i?parseInt(i,10):0;if(o<1073741824)return new Uint8Array(await r.arrayBuffer());{if(!r.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let u=r.body.getReader(),n;try{n=new ArrayBuffer(o)}catch(p){if(p instanceof RangeError){let c=Math.ceil(o/65536);n=new WebAssembly.Memory({initial:c,maximum:c}).buffer}else throw p}let s=0;for(;;){let{done:p,value:c}=await u.read();if(p)break;let t=c.byteLength;new Uint8Array(n,s,t).set(c),s+=t}return new Uint8Array(n,0,o)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),lm,hn,mn,Ne,fm,sr,bn,gn,oc,yn,xn,Tn,Vo=x(()=>{Zf(),Qf(),qo(),xe(),vn(),jo(),lm=(e,r)=>{nt()._OrtInit(e,r)!==0&&Y("Can't initialize onnxruntime.")},hn=async e=>{lm(e.wasm.numThreads,rc(e.logLevel))},mn=async(e,r)=>{},Ne=new Map,fm=e=>{let r=nt(),i=r.stackSave();try{let o=r.stackAlloc(8);return r._OrtGetInputOutputCount(e,o,o+4)!==0&&Y("Can't get session input/output count."),[r.HEAP32[o/4],r.HEAP32[o/4+1]]}finally{r.stackRestore(i)}},sr=e=>{let r=nt(),i=r._malloc(e.byteLength);if(i===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return r.HEAPU8.set(e,i),[i,e.byteLength]},bn=async(e,r)=>{var l;let i,o,u=nt();Array.isArray(e)?[i,o]=e:e.buffer===u.HEAPU8.buffer?[i,o]=[e.byteOffset,e.byteLength]:[i,o]=sr(e);let n=0,s=0,p=[],c=[],t=[];try{if([s,p]=Yf(r),(r==null?void 0:r.externalData)&&u.mountExternalData){let m=[];for(let v of r.externalData){let T=typeof v=="string"?v:v.path;m.push(lr(typeof v=="string"?v:v.data).then(_=>{u.mountExternalData(T,_)}))}await Promise.all(m)}for(let m of(r==null?void 0:r.executionProviders)??[])if((typeof m=="string"?m:m.name)==="webnn"){if(u.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof m!="string"){let v=m,T=v==null?void 0:v.context,_=v==null?void 0:v.gpuDevice,B=v==null?void 0:v.deviceType,E=v==null?void 0:v.numThreads,K=v==null?void 0:v.powerPreference;T?u.currentContext=T:_?u.currentContext=await navigator.ml.createContext(_):u.currentContext=await navigator.ml.createContext({deviceType:B,numThreads:E,powerPreference:K})}else u.currentContext=await navigator.ml.createContext();break}n=await u._OrtCreateSession(i,o,s),n===0&&Y("Can't create a session."),u.currentContext&&(u.currentContext=void 0);let[a,d]=fm(n),h=!!(r!=null&&r.enableGraphCapture),f=[],g=[],y=[];for(let m=0;m<a;m++){let v=u._OrtGetInputName(n,m);v===0&&Y("Can't get an input name."),c.push(v),f.push(u.UTF8ToString(v))}for(let m=0;m<d;m++){let v=u._OrtGetOutputName(n,m);v===0&&Y("Can't get an output name."),t.push(v);let T=u.UTF8ToString(v);g.push(T)}return Ne.set(n,[n,c,t,null,h,!1]),[n,f,g]}catch(a){throw c.forEach(d=>u._OrtFree(d)),t.forEach(d=>u._OrtFree(d)),n!==0&&u._OrtReleaseSession(n),a}finally{u._free(i),s!==0&&u._OrtReleaseSessionOptions(s),p.forEach(a=>u._free(a)),(l=u.unmountExternalData)==null||l.call(u)}},gn=e=>{var c;let r=nt(),i=Ne.get(e);if(!i)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,u,n,s,p]=i;s&&(p&&r._OrtClearBoundOutputs(s.handle),r._OrtReleaseBinding(s.handle)),(c=r.jsepOnReleaseSession)==null||c.call(r,e),u.forEach(t=>r._OrtFree(t)),n.forEach(t=>r._OrtFree(t)),r._OrtReleaseSession(o),Ne.delete(e)},oc=(e,r,i,o,u,n=!1)=>{if(!e){r.push(0);return}let s=nt(),p=e[0],c=e[1],t=e[3],l,a;if(p==="string"&&t==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(n&&t!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${u} when enableGraphCapture is true.`);if(t==="gpu-buffer"){let f=e[2].gpuBuffer,g=Ho(Wo(p));a=c.reduce((w,m)=>w*m,1)*g;let y=s.jsepRegisterBuffer;if(!y)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');l=y(o,u,f,a)}else{let f=e[2];if(Array.isArray(f)){a=4*f.length,l=s._malloc(a),i.push(l);let g=l/4;for(let y=0;y<f.length;y++){if(typeof f[y]!="string")throw new TypeError(`tensor data at index ${y} is not a string`);s.HEAPU32[g++]=ot(f[y],i)}}else a=f.byteLength,l=s._malloc(a),i.push(l),s.HEAPU8.set(new Uint8Array(f.buffer,f.byteOffset,a),l)}let d=s.stackSave(),h=s.stackAlloc(4*c.length);try{let f=h/4;c.forEach(y=>s.HEAP32[f++]=y);let g=s._OrtCreateTensor(Wo(p),l,a,h,c.length,nc(t));g===0&&Y(`Can't create tensor for input/output. session=${o}, index=${u}.`),r.push(g)}finally{s.stackRestore(d)}},yn=async(e,r,i,o,u,n)=>{var je;let s=nt(),p=Ne.get(e);if(!p)throw new Error(`cannot run inference. invalid session id: ${e}`);let c=p[0],t=p[1],l=p[2],a=p[3],d=p[4];p[5];let h=r.length,f=o.length,g=0,y=[],w=[],m=[],v=[],T=s.stackSave(),_=s.stackAlloc(h*4),B=s.stackAlloc(h*4),E=s.stackAlloc(f*4),K=s.stackAlloc(f*4);try{[g,y]=Jf(n);for(let S=0;S<h;S++)oc(i[S],w,v,e,r[S],d);for(let S=0;S<f;S++)oc(u[S],m,v,e,h+o[S],d);let G=_/4,St=B/4,Nt=E/4,Ft=K/4;for(let S=0;S<h;S++)s.HEAPU32[G++]=w[S],s.HEAPU32[St++]=t[r[S]];for(let S=0;S<f;S++)s.HEAPU32[Nt++]=m[S],s.HEAPU32[Ft++]=l[o[S]];(je=s.jsepOnRunStart)==null||je.call(s,c);let Ke;Ke=await s._OrtRun(c,B,_,h,K,f,E,g),Ke!==0&&Y("failed to call OrtRun().");let Q=[];for(let S=0;S<f;S++){let Ve=s.HEAPU32[E/4+S];if(Ve===m[S]){Q.push(u[S]);continue}let Ct=s.stackSave(),te=s.stackAlloc(4*4),it=!1,M,W=0;try{s._OrtGetTensorData(Ve,te,te+4,te+8,te+12)!==0&&Y(`Can't access output tensor data on index ${S}.`);let Me=te/4,lt=s.HEAPU32[Me++];W=s.HEAPU32[Me++];let dt=s.HEAPU32[Me++],Gt=s.HEAPU32[Me++],ne=[];for(let k=0;k<Gt;k++)ne.push(s.HEAPU32[dt/4+k]);s._OrtFree(dt);let le=ne.reduce((k,L)=>k*L,1);M=tc(lt);let gt=a==null?void 0:a.outputPreferredLocations[o[S]];if(M==="string"){if(gt==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let k=[],L=W/4;for(let J=0;J<le;J++){let mt=s.HEAPU32[L++],Ht=J===le-1?void 0:s.HEAPU32[L]-mt;k.push(s.UTF8ToString(mt,Ht))}Q.push([M,ne,k,"cpu"])}else if(gt==="gpu-buffer"&&le>0){let k=s.jsepGetBuffer;if(!k)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let L=k(W),J=Ho(lt);if(J===void 0||!In(M))throw new Error(`Unsupported data type: ${M}`);it=!0,Q.push([M,ne,{gpuBuffer:L,download:s.jsepCreateDownloader(L,le*J,M),dispose:()=>{s._OrtReleaseTensor(Ve)}},"gpu-buffer"])}else{let k=ec(M),L=new k(le);new Uint8Array(L.buffer,L.byteOffset,L.byteLength).set(s.HEAPU8.subarray(W,W+L.byteLength)),Q.push([M,ne,L,"cpu"])}}finally{s.stackRestore(Ct),M==="string"&&W&&s._free(W),it||s._OrtReleaseTensor(Ve)}}return a&&!d&&(s._OrtClearBoundOutputs(a.handle),Ne.set(e,[c,t,l,a,d,!1])),Q}finally{s.stackRestore(T),w.forEach(G=>s._OrtReleaseTensor(G)),m.forEach(G=>s._OrtReleaseTensor(G)),v.forEach(G=>s._free(G)),g!==0&&s._OrtReleaseRunOptions(g),y.forEach(G=>s._free(G))}},xn=e=>{let r=nt(),i=Ne.get(e);if(!i)throw new Error("invalid session id");let o=i[0],u=r._OrtEndProfiling(o);u===0&&Y("Can't get an profile file name."),r._OrtFree(u)},Tn=e=>{let r=[];for(let i of e){let o=i[2];!Array.isArray(o)&&"buffer"in o&&r.push(o.buffer)}return r}}),we,Lt,fr,Sn,On,_n,Xo,Ko,Ce,Re,pm,ic,ac,sc,uc,lc,fc,cc,Jo=x(()=>{$t(),Vo(),xe(),ar(),we=()=>!!$.wasm.proxy&&typeof document<"u",fr=!1,Sn=!1,On=!1,Ko=new Map,Ce=(e,r)=>{let i=Ko.get(e);i?i.push(r):Ko.set(e,[r])},Re=()=>{if(fr||!Sn||On||!Lt)throw new Error("worker not ready")},pm=e=>{switch(e.data.type){case"init-wasm":fr=!1,e.data.err?(On=!0,Xo[1](e.data.err)):(Sn=!0,Xo[0]()),_n&&(URL.revokeObjectURL(_n),_n=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let r=Ko.get(e.data.type);e.data.err?r.shift()[1](e.data.err):r.shift()[0](e.data.out);break}}},ic=async()=>{if(!Sn){if(fr)throw new Error("multiple calls to 'initWasm()' detected.");if(On)throw new Error("previous call to 'initWasm()' failed.");if(fr=!0,we())return new Promise((e,r)=>{Lt==null||Lt.terminate(),jf().then(([i,o])=>{try{Lt=o,Lt.onerror=n=>r(n),Lt.onmessage=pm,Xo=[e,r];let u={type:"init-wasm",in:$};Lt.postMessage(u),_n=i}catch(u){r(u)}},r)});try{await dn($.wasm),await hn($),Sn=!0}catch(e){throw On=!0,e}finally{fr=!1}}},ac=async e=>{if(we())return Re(),new Promise((r,i)=>{Ce("init-ep",[r,i]);let o={type:"init-ep",in:{epName:e,env:$}};Lt.postMessage(o)});await mn($,e)},sc=async e=>we()?(Re(),new Promise((r,i)=>{Ce("copy-from",[r,i]);let o={type:"copy-from",in:{buffer:e}};Lt.postMessage(o,[e.buffer])})):sr(e),uc=async(e,r)=>{if(we()){if(r!=null&&r.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Re(),new Promise((i,o)=>{Ce("create",[i,o]);let u={type:"create",in:{model:e,options:{...r}}},n=[];e instanceof Uint8Array&&n.push(e.buffer),Lt.postMessage(u,n)})}else return bn(e,r)},lc=async e=>{if(we())return Re(),new Promise((r,i)=>{Ce("release",[r,i]);let o={type:"release",in:e};Lt.postMessage(o)});gn(e)},fc=async(e,r,i,o,u,n)=>{if(we()){if(i.some(s=>s[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(u.some(s=>s))throw new Error("pre-allocated output tensor is not supported for proxy.");return Re(),new Promise((s,p)=>{Ce("run",[s,p]);let c=i,t={type:"run",in:{sessionId:e,inputIndices:r,inputs:c,outputIndices:o,options:n}};Lt.postMessage(t,Tn(c))})}else return yn(e,r,i,o,u,n)},cc=async e=>{if(we())return Re(),new Promise((r,i)=>{Ce("end-profiling",[r,i]);let o={type:"end-profiling",in:e};Lt.postMessage(o)});xn(e)}}),pc,dm,An,dc=x(()=>{$t(),Jo(),qo(),pn(),jo(),pc=(e,r)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${r()}`)}},dm=e=>{switch(e[3]){case"cpu":return new rt(e[0],e[2],e[1]);case"gpu-buffer":{let r=e[0];if(!In(r))throw new Error(`not supported data type: ${r} for deserializing GPU tensor`);let{gpuBuffer:i,download:o,dispose:u}=e[2];return rt.fromGpuBuffer(i,{dataType:r,dims:e[1],download:o,dispose:u})}default:throw new Error(`invalid data location: ${e[3]}`)}},An=class{async fetchModelAndCopyToWasmMemory(e){return sc(await lr(e))}async loadModel(e,r){Kt();let i;typeof e=="string"?i=await this.fetchModelAndCopyToWasmMemory(e):i=e,[this.sessionId,this.inputNames,this.outputNames]=await uc(i,r),Jt()}async dispose(){return lc(this.sessionId)}async run(e,r,i){Kt();let o=[],u=[];Object.entries(e).forEach(a=>{let d=a[0],h=a[1],f=this.inputNames.indexOf(d);if(f===-1)throw new Error(`invalid input '${d}'`);o.push(h),u.push(f)});let n=[],s=[];Object.entries(r).forEach(a=>{let d=a[0],h=a[1],f=this.outputNames.indexOf(d);if(f===-1)throw new Error(`invalid output '${d}'`);n.push(h),s.push(f)});let p=o.map((a,d)=>pc(a,()=>`input "${this.inputNames[u[d]]}"`)),c=n.map((a,d)=>a?pc(a,()=>`output "${this.outputNames[s[d]]}"`):null),t=await fc(this.sessionId,u,p,s,c,i),l={};for(let a=0;a<t.length;a++)l[this.outputNames[s[a]]]=n[a]??dm(t[a]);return Jt(),l}startProfiling(){}endProfiling(){cc(this.sessionId)}}}),hm,Pn,hc=x(()=>{$t(),Jo(),dc(),ar(),hm=()=>{if((typeof $.wasm.initTimeout!="number"||$.wasm.initTimeout<0)&&($.wasm.initTimeout=0),$.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof $.wasm.proxy!="boolean"&&($.wasm.proxy=!1),typeof $.wasm.trace!="boolean"&&($.wasm.trace=!1),typeof $.wasm.numThreads!="number"||!Number.isInteger($.wasm.numThreads)||$.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)$.wasm.numThreads=1;else{let e=typeof navigator>"u"?En("node:os").cpus().length:navigator.hardwareConcurrency;$.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}$.wasm.wasmPaths===void 0&&Dt&&Dt.indexOf("blob:")!==0&&($.wasm.wasmPaths=Dt.substring(0,Dt.lastIndexOf("/")+1))},Pn=class{async init(e){hm(),await ic(),await ac(e)}async createInferenceSessionHandler(e,r){let i=new An;return await i.loadModel(e,r),Promise.resolve(i)}}}),mc={};ze(mc,{wasmBackend:()=>mm});var mm,bc=x(()=>{hc(),mm=new Pn}),gm={};ze(gm,{InferenceSession:()=>Si,TRACE:()=>$n,TRACE_FUNC_BEGIN:()=>Kt,TRACE_FUNC_END:()=>Jt,Tensor:()=>rt,TrainingSession:()=>$i,default:()=>bm,env:()=>$,registerBackend:()=>ie}),$t(),$t(),$t();var Bi="1.19.0",bm=Bn;{let e=(Gf(),hr(Rf)).onnxjsBackend;ie("webgl",e,-10)}{let e=(bc(),hr(mc)).wasmBackend;ie("cpu",e,10),ie("wasm",e,10)}return Object.defineProperty($.versions,"web",{value:Bi,enumerable:!0}),hr(gm)})();/*! Bundled license information:

	long/index.js:
	  (**
	   * @license
	   * Copyright 2009 The Closure Library Authors
	   * Copyright 2020 Daniel Wirtz / The long.js Authors.
	   *
	   * Licensed under the Apache License, Version 2.0 (the "License");
	   * you may not use this file except in compliance with the License.
	   * You may obtain a copy of the License at
	   *
	   *     http://www.apache.org/licenses/LICENSE-2.0
	   *
	   * Unless required by applicable law or agreed to in writing, software
	   * distributed under the License is distributed on an "AS IS" BASIS,
	   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	   * See the License for the specific language governing permissions and
	   * limitations under the License.
	   *
	   * SPDX-License-Identifier: Apache-2.0
	   *)
	*/module.exports=ort})(ort_min);var ort_minExports=ort_min.exports,_common={},utils$1={};Object.defineProperty(utils$1,"__esModule",{value:!0});utils$1.encodeWAV=utils$1.arrayBufferToBase64=utils$1.minFramesForTargetMS=void 0;function minFramesForTargetMS(e,r,i=16e3){return Math.ceil(e*i/1e3/r)}utils$1.minFramesForTargetMS=minFramesForTargetMS;function arrayBufferToBase64(e){for(var r="",i=new Uint8Array(e),o=i.byteLength,u=0;u<o;u++)r+=String.fromCharCode(i[u]);return btoa(r)}utils$1.arrayBufferToBase64=arrayBufferToBase64;function encodeWAV(e,r=3,i=16e3,o=1,u=32){var n=u/8,s=o*n,p=new ArrayBuffer(44+e.length*n),c=new DataView(p);return writeString(c,0,"RIFF"),c.setUint32(4,36+e.length*n,!0),writeString(c,8,"WAVE"),writeString(c,12,"fmt "),c.setUint32(16,16,!0),c.setUint16(20,r,!0),c.setUint16(22,o,!0),c.setUint32(24,i,!0),c.setUint32(28,i*s,!0),c.setUint16(32,s,!0),c.setUint16(34,u,!0),writeString(c,36,"data"),c.setUint32(40,e.length*n,!0),r===1?floatTo16BitPCM(c,44,e):writeFloat32(c,44,e),p}utils$1.encodeWAV=encodeWAV;function writeFloat32(e,r,i){for(var o=0;o<i.length;o++,r+=4)e.setFloat32(r,i[o],!0)}function floatTo16BitPCM(e,r,i){for(var o=0;o<i.length;o++,r+=2){var u=Math.max(-1,Math.min(1,i[o]));e.setInt16(r,u<0?u*32768:u*32767,!0)}}function writeString(e,r,i){for(var o=0;o<i.length;o++)e.setUint8(r+o,i.charCodeAt(o))}var nonRealTimeVad={},frameProcessor={},messages={};Object.defineProperty(messages,"__esModule",{value:!0});messages.Message=void 0;var Message;(function(e){e.AudioFrame="AUDIO_FRAME",e.SpeechStart="SPEECH_START",e.VADMisfire="VAD_MISFIRE",e.SpeechEnd="SPEECH_END",e.SpeechStop="SPEECH_STOP"})(Message||(messages.Message=Message={}));var logging={};(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.log=e.LOG_PREFIX=void 0,e.LOG_PREFIX="[VAD]";const r=["error","debug","warn"];function i(u){return(...n)=>{console[u](e.LOG_PREFIX,...n)}}const o=r.reduce((u,n)=>(u[n]=i(n),u),{});e.log=o})(logging);Object.defineProperty(frameProcessor,"__esModule",{value:!0});frameProcessor.FrameProcessor=frameProcessor.validateOptions=frameProcessor.defaultFrameProcessorOptions=void 0;const messages_1=messages,logging_1$2=logging,RECOMMENDED_FRAME_SAMPLES=[512,1024,1536];frameProcessor.defaultFrameProcessorOptions={positiveSpeechThreshold:.5,negativeSpeechThreshold:.5-.15,preSpeechPadFrames:1,redemptionFrames:8,frameSamples:1536,minSpeechFrames:3,submitUserSpeechOnPause:!1};function validateOptions(e){RECOMMENDED_FRAME_SAMPLES.includes(e.frameSamples)||logging_1$2.log.warn("You are using an unusual frame size"),(e.positiveSpeechThreshold<0||e.negativeSpeechThreshold>1)&&logging_1$2.log.error("postiveSpeechThreshold should be a number between 0 and 1"),(e.negativeSpeechThreshold<0||e.negativeSpeechThreshold>e.positiveSpeechThreshold)&&logging_1$2.log.error("negativeSpeechThreshold should be between 0 and postiveSpeechThreshold"),e.preSpeechPadFrames<0&&logging_1$2.log.error("preSpeechPadFrames should be positive"),e.redemptionFrames<0&&logging_1$2.log.error("preSpeechPadFrames should be positive")}frameProcessor.validateOptions=validateOptions;const concatArrays=e=>{const r=e.reduce((o,u)=>(o.push(o.at(-1)+u.length),o),[0]),i=new Float32Array(r.at(-1));return e.forEach((o,u)=>{const n=r[u];i.set(o,n)}),i};class FrameProcessor{constructor(r,i,o){this.modelProcessFunc=r,this.modelResetFunc=i,this.options=o,this.speaking=!1,this.redemptionCounter=0,this.active=!1,this.reset=()=>{this.speaking=!1,this.audioBuffer=[],this.modelResetFunc(),this.redemptionCounter=0},this.pause=()=>(this.active=!1,this.options.submitUserSpeechOnPause?this.endSegment():(this.reset(),{})),this.resume=()=>{this.active=!0},this.endSegment=()=>{const u=this.audioBuffer;this.audioBuffer=[];const n=this.speaking;this.reset();const s=u.reduce((p,c)=>p+ +c.isSpeech,0);if(n)if(s>=this.options.minSpeechFrames){const p=concatArrays(u.map(c=>c.frame));return{msg:messages_1.Message.SpeechEnd,audio:p}}else return{msg:messages_1.Message.VADMisfire};return{}},this.process=async u=>{if(!this.active)return{};const n=await this.modelProcessFunc(u);if(this.audioBuffer.push({frame:u,isSpeech:n.isSpeech>=this.options.positiveSpeechThreshold}),n.isSpeech>=this.options.positiveSpeechThreshold&&this.redemptionCounter&&(this.redemptionCounter=0),n.isSpeech>=this.options.positiveSpeechThreshold&&!this.speaking)return this.speaking=!0,{probs:n,msg:messages_1.Message.SpeechStart};if(n.isSpeech<this.options.negativeSpeechThreshold&&this.speaking&&++this.redemptionCounter>=this.options.redemptionFrames){this.redemptionCounter=0,this.speaking=!1;const s=this.audioBuffer;if(this.audioBuffer=[],s.reduce((c,t)=>c+ +t.isSpeech,0)>=this.options.minSpeechFrames){const c=concatArrays(s.map(t=>t.frame));return{probs:n,msg:messages_1.Message.SpeechEnd,audio:c}}else return{probs:n,msg:messages_1.Message.VADMisfire}}if(!this.speaking)for(;this.audioBuffer.length>this.options.preSpeechPadFrames;)this.audioBuffer.shift();return{probs:n}},this.audioBuffer=[],this.reset()}}frameProcessor.FrameProcessor=FrameProcessor;var models={},_a;Object.defineProperty(models,"__esModule",{value:!0});models.Silero=void 0;const logging_1$1=logging;class Silero{constructor(r,i){this.ort=r,this.modelFetcher=i,this.init=async()=>{logging_1$1.log.debug("initializing vad");const o=await this.modelFetcher();this._session=await this.ort.InferenceSession.create(o),this._sr=new this.ort.Tensor("int64",[16000n]),this.reset_state(),logging_1$1.log.debug("vad is initialized")},this.reset_state=()=>{const o=Array(128).fill(0);this._h=new this.ort.Tensor("float32",o,[2,1,64]),this._c=new this.ort.Tensor("float32",o,[2,1,64])},this.process=async o=>{const n={input:new this.ort.Tensor("float32",o,[1,o.length]),h:this._h,c:this._c,sr:this._sr},s=await this._session.run(n);this._h=s.hn,this._c=s.cn;const[p]=s.output.data;return{notSpeech:1-p,isSpeech:p}}}}models.Silero=Silero;_a=Silero;Silero.new=async(e,r)=>{const i=new _a(e,r);return await i.init(),i};var resampler={};Object.defineProperty(resampler,"__esModule",{value:!0});resampler.Resampler=void 0;const logging_1=logging;class Resampler{constructor(r){this.options=r,this.process=i=>{const o=[];for(this.fillInputBuffer(i);this.hasEnoughDataForFrame();){const u=this.generateOutputFrame();o.push(u)}return o},this.stream=async function*(i){for(this.fillInputBuffer(i);this.hasEnoughDataForFrame();)yield this.generateOutputFrame()},r.nativeSampleRate<16e3&&logging_1.log.error("nativeSampleRate is too low. Should have 16000 = targetSampleRate <= nativeSampleRate"),this.inputBuffer=[]}fillInputBuffer(r){for(const i of r)this.inputBuffer.push(i)}hasEnoughDataForFrame(){return this.inputBuffer.length*this.options.targetSampleRate/this.options.nativeSampleRate>=this.options.targetFrameSize}generateOutputFrame(){const r=new Float32Array(this.options.targetFrameSize);let i=0,o=0;for(;i<this.options.targetFrameSize;){let u=0,n=0;for(;o<Math.min(this.inputBuffer.length,(i+1)*this.options.nativeSampleRate/this.options.targetSampleRate);){const s=this.inputBuffer[o];s!==void 0&&(u+=s,n++),o++}r[i]=u/n,i++}return this.inputBuffer=this.inputBuffer.slice(o),r}}resampler.Resampler=Resampler;(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.PlatformAgnosticNonRealTimeVAD=e.defaultNonRealTimeVADOptions=void 0;const r=frameProcessor,i=messages,o=models,u=resampler;e.defaultNonRealTimeVADOptions={...r.defaultFrameProcessorOptions,ortConfig:void 0};class n{static async _new(p,c,t={}){const l={...e.defaultNonRealTimeVADOptions,...t};l.ortConfig!==void 0&&l.ortConfig(c);const a=new this(p,c,l);return await a.init(),a}constructor(p,c,t){this.modelFetcher=p,this.ort=c,this.options=t,this.init=async()=>{const l=await o.Silero.new(this.ort,this.modelFetcher);this.frameProcessor=new r.FrameProcessor(l.process,l.reset_state,{frameSamples:this.options.frameSamples,positiveSpeechThreshold:this.options.positiveSpeechThreshold,negativeSpeechThreshold:this.options.negativeSpeechThreshold,redemptionFrames:this.options.redemptionFrames,preSpeechPadFrames:this.options.preSpeechPadFrames,minSpeechFrames:this.options.minSpeechFrames,submitUserSpeechOnPause:this.options.submitUserSpeechOnPause}),this.frameProcessor.resume()},this.run=async function*(l,a){const d={nativeSampleRate:a,targetSampleRate:16e3,targetFrameSize:this.options.frameSamples},h=new u.Resampler(d);let f=0,g=0,y=0;for await(const v of h.stream(l)){const{msg:T,audio:_}=await this.frameProcessor.process(v);switch(T){case i.Message.SpeechStart:f=y*this.options.frameSamples/16;break;case i.Message.SpeechEnd:g=(y+1)*this.options.frameSamples/16,yield{audio:_,start:f,end:g};break}y++}const{msg:w,audio:m}=this.frameProcessor.endSegment();w==i.Message.SpeechEnd&&(yield{audio:m,start:f,end:y*this.options.frameSamples/16})},(0,r.validateOptions)(t)}}e.PlatformAgnosticNonRealTimeVAD=n})(nonRealTimeVad);(function(e){var r=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(s,p,c,t){t===void 0&&(t=c);var l=Object.getOwnPropertyDescriptor(p,c);(!l||("get"in l?!p.__esModule:l.writable||l.configurable))&&(l={enumerable:!0,get:function(){return p[c]}}),Object.defineProperty(s,t,l)}:function(s,p,c,t){t===void 0&&(t=c),s[t]=p[c]}),i=commonjsGlobal&&commonjsGlobal.__setModuleDefault||(Object.create?function(s,p){Object.defineProperty(s,"default",{enumerable:!0,value:p})}:function(s,p){s.default=p}),o=commonjsGlobal&&commonjsGlobal.__importStar||function(s){if(s&&s.__esModule)return s;var p={};if(s!=null)for(var c in s)c!=="default"&&Object.prototype.hasOwnProperty.call(s,c)&&r(p,s,c);return i(p,s),p},u=commonjsGlobal&&commonjsGlobal.__exportStar||function(s,p){for(var c in s)c!=="default"&&!Object.prototype.hasOwnProperty.call(p,c)&&r(p,s,c)};Object.defineProperty(e,"__esModule",{value:!0}),e.utils=void 0;const n=o(utils$1);e.utils={minFramesForTargetMS:n.minFramesForTargetMS,arrayBufferToBase64:n.arrayBufferToBase64,encodeWAV:n.encodeWAV},u(nonRealTimeVad,e),u(frameProcessor,e),u(messages,e),u(logging,e),u(models,e),u(resampler,e)})(_common);var utils={};Object.defineProperty(utils,"__esModule",{value:!0});utils.audioFileToArray=void 0;async function audioFileToArray(e){const r=new OfflineAudioContext(1,1,44100),i=new FileReader;let o=null;if(await new Promise(s=>{i.addEventListener("loadend",p=>{const c=i.result;r.decodeAudioData(c,t=>{o=t,r.startRendering().then(l=>{console.log("Rendering completed successfully"),s()}).catch(l=>{console.error(`Rendering failed: ${l}`)})},t=>{console.log(`Error with decoding audio data: ${t}`)})}),i.readAsArrayBuffer(e)}),o===null)throw Error("some shit");let u=o,n=new Float32Array(u.length);for(let s=0;s<u.length;s++)for(let p=0;p<u.numberOfChannels;p++)n[s]+=u.getChannelData(p)[s];return{audio:n,sampleRate:u.sampleRate}}utils.audioFileToArray=audioFileToArray;var defaultModelFetcher$1={};Object.defineProperty(defaultModelFetcher$1,"__esModule",{value:!0});defaultModelFetcher$1.defaultModelFetcher=void 0;const defaultModelFetcher=e=>fetch(e).then(r=>r.arrayBuffer());defaultModelFetcher$1.defaultModelFetcher=defaultModelFetcher;var assetPath$1={};Object.defineProperty(assetPath$1,"__esModule",{value:!0});assetPath$1.assetPath=void 0;const isWeb=typeof window<"u"&&typeof window.document<"u",currentScript=isWeb?window.document.currentScript:null;let basePath="/";currentScript&&(basePath=currentScript.src.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"));const assetPath=e=>basePath+e;assetPath$1.assetPath=assetPath;var realTimeVad={};(function(e){var r=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(l,a,d,h){h===void 0&&(h=d);var f=Object.getOwnPropertyDescriptor(a,d);(!f||("get"in f?!a.__esModule:f.writable||f.configurable))&&(f={enumerable:!0,get:function(){return a[d]}}),Object.defineProperty(l,h,f)}:function(l,a,d,h){h===void 0&&(h=d),l[h]=a[d]}),i=commonjsGlobal&&commonjsGlobal.__setModuleDefault||(Object.create?function(l,a){Object.defineProperty(l,"default",{enumerable:!0,value:a})}:function(l,a){l.default=a}),o=commonjsGlobal&&commonjsGlobal.__importStar||function(l){if(l&&l.__esModule)return l;var a={};if(l!=null)for(var d in l)d!=="default"&&Object.prototype.hasOwnProperty.call(l,d)&&r(a,l,d);return i(a,l),a};Object.defineProperty(e,"__esModule",{value:!0}),e.AudioNodeVAD=e.MicVAD=e.defaultRealTimeVADOptions=e.ort=void 0;const u=o(ort_minExports),n=_common,s=assetPath$1,p=defaultModelFetcher$1;e.ort=u,e.defaultRealTimeVADOptions={...n.defaultFrameProcessorOptions,onFrameProcessed:l=>{},onVADMisfire:()=>{n.log.debug("VAD misfire")},onSpeechStart:()=>{n.log.debug("Detected speech start")},onSpeechEnd:()=>{n.log.debug("Detected speech end")},workletURL:(0,s.assetPath)("vad.worklet.bundle.min.js"),modelURL:(0,s.assetPath)("silero_vad.onnx"),modelFetcher:p.defaultModelFetcher,stream:void 0,ortConfig:void 0};class c{static async new(a={}){const d={...e.defaultRealTimeVADOptions,...a};(0,n.validateOptions)(d);let h;d.stream===void 0?h=await navigator.mediaDevices.getUserMedia({audio:{...d.additionalAudioConstraints,channelCount:1,echoCancellation:!0,autoGainControl:!0,noiseSuppression:!0}}):h=d.stream;const f=new AudioContext,g=new MediaStreamAudioSourceNode(f,{mediaStream:h}),y=await t.new(f,d);return y.receive(g),new c(d,f,h,y,g)}constructor(a,d,h,f,g,y=!1){this.options=a,this.audioContext=d,this.stream=h,this.audioNodeVAD=f,this.sourceNode=g,this.listening=y,this.pause=()=>{this.audioNodeVAD.pause(),this.listening=!1},this.start=()=>{this.audioNodeVAD.start(),this.listening=!0},this.destroy=()=>{this.listening&&this.pause(),this.options.stream===void 0&&this.stream.getTracks().forEach(w=>w.stop()),this.sourceNode.disconnect(),this.audioNodeVAD.destroy(),this.audioContext.close()}}}e.MicVAD=c;class t{static async new(a,d={}){const h={...e.defaultRealTimeVADOptions,...d};(0,n.validateOptions)(h),h.ortConfig!==void 0&&h.ortConfig(e.ort);try{await a.audioWorklet.addModule(h.workletURL)}catch(m){throw console.error(`Encountered an error while loading worklet. Please make sure the worklet vad.bundle.min.js included with @ricky0123/vad-web is available at the specified path:
        ${h.workletURL}
        If need be, you can customize the worklet file location using the \`workletURL\` option.`),m}const f=new AudioWorkletNode(a,"vad-helper-worklet",{processorOptions:{frameSamples:h.frameSamples}});let g;try{g=await n.Silero.new(e.ort,()=>h.modelFetcher(h.modelURL))}catch(m){throw console.error(`Encountered an error while loading model file. Please make sure silero_vad.onnx, included with @ricky0123/vad-web, is available at the specified path:
      ${h.modelURL}
      If need be, you can customize the model file location using the \`modelsURL\` option.`),m}const y=new n.FrameProcessor(g.process,g.reset_state,{frameSamples:h.frameSamples,positiveSpeechThreshold:h.positiveSpeechThreshold,negativeSpeechThreshold:h.negativeSpeechThreshold,redemptionFrames:h.redemptionFrames,preSpeechPadFrames:h.preSpeechPadFrames,minSpeechFrames:h.minSpeechFrames,submitUserSpeechOnPause:h.submitUserSpeechOnPause}),w=new t(a,h,y,f);return f.port.onmessage=async m=>{var v;switch((v=m.data)==null?void 0:v.message){case n.Message.AudioFrame:const T=m.data.data,_=new Float32Array(T);await w.processFrame(_);break}},w}constructor(a,d,h,f){this.ctx=a,this.options=d,this.frameProcessor=h,this.entryNode=f,this.pause=()=>{const g=this.frameProcessor.pause();this.handleFrameProcessorEvent(g)},this.start=()=>{this.frameProcessor.resume()},this.receive=g=>{g.connect(this.entryNode)},this.processFrame=async g=>{const y=await this.frameProcessor.process(g);this.handleFrameProcessorEvent(y)},this.handleFrameProcessorEvent=g=>{switch(g.probs!==void 0&&this.options.onFrameProcessed(g.probs),g.msg){case n.Message.SpeechStart:this.options.onSpeechStart();break;case n.Message.VADMisfire:this.options.onVADMisfire();break;case n.Message.SpeechEnd:this.options.onSpeechEnd(g.audio);break}},this.destroy=()=>{this.entryNode.port.postMessage({message:n.Message.SpeechStop}),this.entryNode.disconnect()}}}e.AudioNodeVAD=t})(realTimeVad);(function(e){var r=commonjsGlobal&&commonjsGlobal.__createBinding||(Object.create?function(a,d,h,f){f===void 0&&(f=h);var g=Object.getOwnPropertyDescriptor(d,h);(!g||("get"in g?!d.__esModule:g.writable||g.configurable))&&(g={enumerable:!0,get:function(){return d[h]}}),Object.defineProperty(a,f,g)}:function(a,d,h,f){f===void 0&&(f=h),a[f]=d[h]}),i=commonjsGlobal&&commonjsGlobal.__setModuleDefault||(Object.create?function(a,d){Object.defineProperty(a,"default",{enumerable:!0,value:d})}:function(a,d){a.default=d}),o=commonjsGlobal&&commonjsGlobal.__importStar||function(a){if(a&&a.__esModule)return a;var d={};if(a!=null)for(var h in a)h!=="default"&&Object.prototype.hasOwnProperty.call(a,h)&&r(d,a,h);return i(d,a),d};Object.defineProperty(e,"__esModule",{value:!0}),e.defaultRealTimeVADOptions=e.AudioNodeVAD=e.MicVAD=e.NonRealTimeVAD=e.Message=e.FrameProcessor=e.utils=e.defaultNonRealTimeVADOptions=void 0;const u=o(ort_minExports),n=_common;Object.defineProperty(e,"FrameProcessor",{enumerable:!0,get:function(){return n.FrameProcessor}}),Object.defineProperty(e,"Message",{enumerable:!0,get:function(){return n.Message}});const s=utils,p=defaultModelFetcher$1,c=assetPath$1;e.defaultNonRealTimeVADOptions={modelURL:(0,c.assetPath)("silero_vad.onnx"),modelFetcher:p.defaultModelFetcher};class t extends n.PlatformAgnosticNonRealTimeVAD{static async new(d={}){const{modelURL:h,modelFetcher:f}={...e.defaultNonRealTimeVADOptions,...d};return await this._new(()=>f(h),u,d)}}e.NonRealTimeVAD=t,e.utils={audioFileToArray:s.audioFileToArray,...n.utils};var l=realTimeVad;Object.defineProperty(e,"MicVAD",{enumerable:!0,get:function(){return l.MicVAD}}),Object.defineProperty(e,"AudioNodeVAD",{enumerable:!0,get:function(){return l.AudioNodeVAD}}),Object.defineProperty(e,"defaultRealTimeVADOptions",{enumerable:!0,get:function(){return l.defaultRealTimeVADOptions}})})(dist);export{commonjsGlobal as c,dist as d,getDefaultExportFromCjs as g};
